"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/fast-equals";
exports.ids = ["vendor-chunks/fast-equals"];
exports.modules = {

/***/ "(ssr)/./node_modules/fast-equals/dist/esm/index.mjs":
/*!*****************************************************!*\
  !*** ./node_modules/fast-equals/dist/esm/index.mjs ***!
  \*****************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   circularDeepEqual: () => (/* binding */ circularDeepEqual),\n/* harmony export */   circularShallowEqual: () => (/* binding */ circularShallowEqual),\n/* harmony export */   createCustomEqual: () => (/* binding */ createCustomEqual),\n/* harmony export */   deepEqual: () => (/* binding */ deepEqual),\n/* harmony export */   sameValueZeroEqual: () => (/* binding */ sameValueZeroEqual),\n/* harmony export */   shallowEqual: () => (/* binding */ shallowEqual),\n/* harmony export */   strictCircularDeepEqual: () => (/* binding */ strictCircularDeepEqual),\n/* harmony export */   strictCircularShallowEqual: () => (/* binding */ strictCircularShallowEqual),\n/* harmony export */   strictDeepEqual: () => (/* binding */ strictDeepEqual),\n/* harmony export */   strictShallowEqual: () => (/* binding */ strictShallowEqual)\n/* harmony export */ });\nvar getOwnPropertyNames = Object.getOwnPropertyNames, getOwnPropertySymbols = Object.getOwnPropertySymbols;\nvar hasOwnProperty = Object.prototype.hasOwnProperty;\n/**\n * Combine two comparators into a single comparators.\n */ function combineComparators(comparatorA, comparatorB) {\n    return function isEqual(a, b, state) {\n        return comparatorA(a, b, state) && comparatorB(a, b, state);\n    };\n}\n/**\n * Wrap the provided `areItemsEqual` method to manage the circular state, allowing\n * for circular references to be safely included in the comparison without creating\n * stack overflows.\n */ function createIsCircular(areItemsEqual) {\n    return function isCircular(a, b, state) {\n        if (!a || !b || typeof a !== \"object\" || typeof b !== \"object\") {\n            return areItemsEqual(a, b, state);\n        }\n        var cache = state.cache;\n        var cachedA = cache.get(a);\n        var cachedB = cache.get(b);\n        if (cachedA && cachedB) {\n            return cachedA === b && cachedB === a;\n        }\n        cache.set(a, b);\n        cache.set(b, a);\n        var result = areItemsEqual(a, b, state);\n        cache.delete(a);\n        cache.delete(b);\n        return result;\n    };\n}\n/**\n * Get the properties to strictly examine, which include both own properties that are\n * not enumerable and symbol properties.\n */ function getStrictProperties(object) {\n    return getOwnPropertyNames(object).concat(getOwnPropertySymbols(object));\n}\n/**\n * Whether the object contains the property passed as an own property.\n */ var hasOwn = Object.hasOwn || function(object, property) {\n    return hasOwnProperty.call(object, property);\n};\n/**\n * Whether the values passed are strictly equal or both NaN.\n */ function sameValueZeroEqual(a, b) {\n    return a || b ? a === b : a === b || a !== a && b !== b;\n}\nvar OWNER = \"_owner\";\nvar getOwnPropertyDescriptor = Object.getOwnPropertyDescriptor, keys = Object.keys;\n/**\n * Whether the arrays are equal in value.\n */ function areArraysEqual(a, b, state) {\n    var index = a.length;\n    if (b.length !== index) {\n        return false;\n    }\n    while(index-- > 0){\n        if (!state.equals(a[index], b[index], index, index, a, b, state)) {\n            return false;\n        }\n    }\n    return true;\n}\n/**\n * Whether the dates passed are equal in value.\n */ function areDatesEqual(a, b) {\n    return sameValueZeroEqual(a.getTime(), b.getTime());\n}\n/**\n * Whether the `Map`s are equal in value.\n */ function areMapsEqual(a, b, state) {\n    if (a.size !== b.size) {\n        return false;\n    }\n    var matchedIndices = {};\n    var aIterable = a.entries();\n    var index = 0;\n    var aResult;\n    var bResult;\n    while(aResult = aIterable.next()){\n        if (aResult.done) {\n            break;\n        }\n        var bIterable = b.entries();\n        var hasMatch = false;\n        var matchIndex = 0;\n        while(bResult = bIterable.next()){\n            if (bResult.done) {\n                break;\n            }\n            var _a = aResult.value, aKey = _a[0], aValue = _a[1];\n            var _b = bResult.value, bKey = _b[0], bValue = _b[1];\n            if (!hasMatch && !matchedIndices[matchIndex] && (hasMatch = state.equals(aKey, bKey, index, matchIndex, a, b, state) && state.equals(aValue, bValue, aKey, bKey, a, b, state))) {\n                matchedIndices[matchIndex] = true;\n            }\n            matchIndex++;\n        }\n        if (!hasMatch) {\n            return false;\n        }\n        index++;\n    }\n    return true;\n}\n/**\n * Whether the objects are equal in value.\n */ function areObjectsEqual(a, b, state) {\n    var properties = keys(a);\n    var index = properties.length;\n    if (keys(b).length !== index) {\n        return false;\n    }\n    var property;\n    // Decrementing `while` showed faster results than either incrementing or\n    // decrementing `for` loop and than an incrementing `while` loop. Declarative\n    // methods like `some` / `every` were not used to avoid incurring the garbage\n    // cost of anonymous callbacks.\n    while(index-- > 0){\n        property = properties[index];\n        if (property === OWNER && (a.$$typeof || b.$$typeof) && a.$$typeof !== b.$$typeof) {\n            return false;\n        }\n        if (!hasOwn(b, property) || !state.equals(a[property], b[property], property, property, a, b, state)) {\n            return false;\n        }\n    }\n    return true;\n}\n/**\n * Whether the objects are equal in value with strict property checking.\n */ function areObjectsEqualStrict(a, b, state) {\n    var properties = getStrictProperties(a);\n    var index = properties.length;\n    if (getStrictProperties(b).length !== index) {\n        return false;\n    }\n    var property;\n    var descriptorA;\n    var descriptorB;\n    // Decrementing `while` showed faster results than either incrementing or\n    // decrementing `for` loop and than an incrementing `while` loop. Declarative\n    // methods like `some` / `every` were not used to avoid incurring the garbage\n    // cost of anonymous callbacks.\n    while(index-- > 0){\n        property = properties[index];\n        if (property === OWNER && (a.$$typeof || b.$$typeof) && a.$$typeof !== b.$$typeof) {\n            return false;\n        }\n        if (!hasOwn(b, property)) {\n            return false;\n        }\n        if (!state.equals(a[property], b[property], property, property, a, b, state)) {\n            return false;\n        }\n        descriptorA = getOwnPropertyDescriptor(a, property);\n        descriptorB = getOwnPropertyDescriptor(b, property);\n        if ((descriptorA || descriptorB) && (!descriptorA || !descriptorB || descriptorA.configurable !== descriptorB.configurable || descriptorA.enumerable !== descriptorB.enumerable || descriptorA.writable !== descriptorB.writable)) {\n            return false;\n        }\n    }\n    return true;\n}\n/**\n * Whether the primitive wrappers passed are equal in value.\n */ function arePrimitiveWrappersEqual(a, b) {\n    return sameValueZeroEqual(a.valueOf(), b.valueOf());\n}\n/**\n * Whether the regexps passed are equal in value.\n */ function areRegExpsEqual(a, b) {\n    return a.source === b.source && a.flags === b.flags;\n}\n/**\n * Whether the `Set`s are equal in value.\n */ function areSetsEqual(a, b, state) {\n    if (a.size !== b.size) {\n        return false;\n    }\n    var matchedIndices = {};\n    var aIterable = a.values();\n    var aResult;\n    var bResult;\n    while(aResult = aIterable.next()){\n        if (aResult.done) {\n            break;\n        }\n        var bIterable = b.values();\n        var hasMatch = false;\n        var matchIndex = 0;\n        while(bResult = bIterable.next()){\n            if (bResult.done) {\n                break;\n            }\n            if (!hasMatch && !matchedIndices[matchIndex] && (hasMatch = state.equals(aResult.value, bResult.value, aResult.value, bResult.value, a, b, state))) {\n                matchedIndices[matchIndex] = true;\n            }\n            matchIndex++;\n        }\n        if (!hasMatch) {\n            return false;\n        }\n    }\n    return true;\n}\n/**\n * Whether the TypedArray instances are equal in value.\n */ function areTypedArraysEqual(a, b) {\n    var index = a.length;\n    if (b.length !== index) {\n        return false;\n    }\n    while(index-- > 0){\n        if (a[index] !== b[index]) {\n            return false;\n        }\n    }\n    return true;\n}\nvar ARGUMENTS_TAG = \"[object Arguments]\";\nvar BOOLEAN_TAG = \"[object Boolean]\";\nvar DATE_TAG = \"[object Date]\";\nvar MAP_TAG = \"[object Map]\";\nvar NUMBER_TAG = \"[object Number]\";\nvar OBJECT_TAG = \"[object Object]\";\nvar REG_EXP_TAG = \"[object RegExp]\";\nvar SET_TAG = \"[object Set]\";\nvar STRING_TAG = \"[object String]\";\nvar isArray = Array.isArray;\nvar isTypedArray = typeof ArrayBuffer === \"function\" && ArrayBuffer.isView ? ArrayBuffer.isView : null;\nvar assign = Object.assign;\nvar getTag = Object.prototype.toString.call.bind(Object.prototype.toString);\n/**\n * Create a comparator method based on the type-specific equality comparators passed.\n */ function createEqualityComparator(_a) {\n    var areArraysEqual = _a.areArraysEqual, areDatesEqual = _a.areDatesEqual, areMapsEqual = _a.areMapsEqual, areObjectsEqual = _a.areObjectsEqual, arePrimitiveWrappersEqual = _a.arePrimitiveWrappersEqual, areRegExpsEqual = _a.areRegExpsEqual, areSetsEqual = _a.areSetsEqual, areTypedArraysEqual = _a.areTypedArraysEqual;\n    /**\n     * compare the value of the two objects and return true if they are equivalent in values\n     */ return function comparator(a, b, state) {\n        // If the items are strictly equal, no need to do a value comparison.\n        if (a === b) {\n            return true;\n        }\n        // If the items are not non-nullish objects, then the only possibility\n        // of them being equal but not strictly is if they are both `NaN`. Since\n        // `NaN` is uniquely not equal to itself, we can use self-comparison of\n        // both objects, which is faster than `isNaN()`.\n        if (a == null || b == null || typeof a !== \"object\" || typeof b !== \"object\") {\n            return a !== a && b !== b;\n        }\n        var constructor = a.constructor;\n        // Checks are listed in order of commonality of use-case:\n        //   1. Common complex object types (plain object, array)\n        //   2. Common data values (date, regexp)\n        //   3. Less-common complex object types (map, set)\n        //   4. Less-common data values (promise, primitive wrappers)\n        // Inherently this is both subjective and assumptive, however\n        // when reviewing comparable libraries in the wild this order\n        // appears to be generally consistent.\n        // Constructors should match, otherwise there is potential for false positives\n        // between class and subclass or custom object and POJO.\n        if (constructor !== b.constructor) {\n            return false;\n        }\n        // `isPlainObject` only checks against the object's own realm. Cross-realm\n        // comparisons are rare, and will be handled in the ultimate fallback, so\n        // we can avoid capturing the string tag.\n        if (constructor === Object) {\n            return areObjectsEqual(a, b, state);\n        }\n        // `isArray()` works on subclasses and is cross-realm, so we can avoid capturing\n        // the string tag or doing an `instanceof` check.\n        if (isArray(a)) {\n            return areArraysEqual(a, b, state);\n        }\n        // `isTypedArray()` works on all possible TypedArray classes, so we can avoid\n        // capturing the string tag or comparing against all possible constructors.\n        if (isTypedArray != null && isTypedArray(a)) {\n            return areTypedArraysEqual(a, b, state);\n        }\n        // Try to fast-path equality checks for other complex object types in the\n        // same realm to avoid capturing the string tag. Strict equality is used\n        // instead of `instanceof` because it is more performant for the common\n        // use-case. If someone is subclassing a native class, it will be handled\n        // with the string tag comparison.\n        if (constructor === Date) {\n            return areDatesEqual(a, b, state);\n        }\n        if (constructor === RegExp) {\n            return areRegExpsEqual(a, b, state);\n        }\n        if (constructor === Map) {\n            return areMapsEqual(a, b, state);\n        }\n        if (constructor === Set) {\n            return areSetsEqual(a, b, state);\n        }\n        // Since this is a custom object, capture the string tag to determing its type.\n        // This is reasonably performant in modern environments like v8 and SpiderMonkey.\n        var tag = getTag(a);\n        if (tag === DATE_TAG) {\n            return areDatesEqual(a, b, state);\n        }\n        if (tag === REG_EXP_TAG) {\n            return areRegExpsEqual(a, b, state);\n        }\n        if (tag === MAP_TAG) {\n            return areMapsEqual(a, b, state);\n        }\n        if (tag === SET_TAG) {\n            return areSetsEqual(a, b, state);\n        }\n        if (tag === OBJECT_TAG) {\n            // The exception for value comparison is custom `Promise`-like class instances. These should\n            // be treated the same as standard `Promise` objects, which means strict equality, and if\n            // it reaches this point then that strict equality comparison has already failed.\n            return typeof a.then !== \"function\" && typeof b.then !== \"function\" && areObjectsEqual(a, b, state);\n        }\n        // If an arguments tag, it should be treated as a standard object.\n        if (tag === ARGUMENTS_TAG) {\n            return areObjectsEqual(a, b, state);\n        }\n        // As the penultimate fallback, check if the values passed are primitive wrappers. This\n        // is very rare in modern JS, which is why it is deprioritized compared to all other object\n        // types.\n        if (tag === BOOLEAN_TAG || tag === NUMBER_TAG || tag === STRING_TAG) {\n            return arePrimitiveWrappersEqual(a, b, state);\n        }\n        // If not matching any tags that require a specific type of comparison, then we hard-code false because\n        // the only thing remaining is strict equality, which has already been compared. This is for a few reasons:\n        //   - Certain types that cannot be introspected (e.g., `WeakMap`). For these types, this is the only\n        //     comparison that can be made.\n        //   - For types that can be introspected, but rarely have requirements to be compared\n        //     (`ArrayBuffer`, `DataView`, etc.), the cost is avoided to prioritize the common\n        //     use-cases (may be included in a future release, if requested enough).\n        //   - For types that can be introspected but do not have an objective definition of what\n        //     equality is (`Error`, etc.), the subjective decision is to be conservative and strictly compare.\n        // In all cases, these decisions should be reevaluated based on changes to the language and\n        // common development practices.\n        return false;\n    };\n}\n/**\n * Create the configuration object used for building comparators.\n */ function createEqualityComparatorConfig(_a) {\n    var circular = _a.circular, createCustomConfig = _a.createCustomConfig, strict = _a.strict;\n    var config = {\n        areArraysEqual: strict ? areObjectsEqualStrict : areArraysEqual,\n        areDatesEqual: areDatesEqual,\n        areMapsEqual: strict ? combineComparators(areMapsEqual, areObjectsEqualStrict) : areMapsEqual,\n        areObjectsEqual: strict ? areObjectsEqualStrict : areObjectsEqual,\n        arePrimitiveWrappersEqual: arePrimitiveWrappersEqual,\n        areRegExpsEqual: areRegExpsEqual,\n        areSetsEqual: strict ? combineComparators(areSetsEqual, areObjectsEqualStrict) : areSetsEqual,\n        areTypedArraysEqual: strict ? areObjectsEqualStrict : areTypedArraysEqual\n    };\n    if (createCustomConfig) {\n        config = assign({}, config, createCustomConfig(config));\n    }\n    if (circular) {\n        var areArraysEqual$1 = createIsCircular(config.areArraysEqual);\n        var areMapsEqual$1 = createIsCircular(config.areMapsEqual);\n        var areObjectsEqual$1 = createIsCircular(config.areObjectsEqual);\n        var areSetsEqual$1 = createIsCircular(config.areSetsEqual);\n        config = assign({}, config, {\n            areArraysEqual: areArraysEqual$1,\n            areMapsEqual: areMapsEqual$1,\n            areObjectsEqual: areObjectsEqual$1,\n            areSetsEqual: areSetsEqual$1\n        });\n    }\n    return config;\n}\n/**\n * Default equality comparator pass-through, used as the standard `isEqual` creator for\n * use inside the built comparator.\n */ function createInternalEqualityComparator(compare) {\n    return function(a, b, _indexOrKeyA, _indexOrKeyB, _parentA, _parentB, state) {\n        return compare(a, b, state);\n    };\n}\n/**\n * Create the `isEqual` function used by the consuming application.\n */ function createIsEqual(_a) {\n    var circular = _a.circular, comparator = _a.comparator, createState = _a.createState, equals = _a.equals, strict = _a.strict;\n    if (createState) {\n        return function isEqual(a, b) {\n            var _a = createState(), _b = _a.cache, cache = _b === void 0 ? circular ? new WeakMap() : undefined : _b, meta = _a.meta;\n            return comparator(a, b, {\n                cache: cache,\n                equals: equals,\n                meta: meta,\n                strict: strict\n            });\n        };\n    }\n    if (circular) {\n        return function isEqual(a, b) {\n            return comparator(a, b, {\n                cache: new WeakMap(),\n                equals: equals,\n                meta: undefined,\n                strict: strict\n            });\n        };\n    }\n    var state = {\n        cache: undefined,\n        equals: equals,\n        meta: undefined,\n        strict: strict\n    };\n    return function isEqual(a, b) {\n        return comparator(a, b, state);\n    };\n}\n/**\n * Whether the items passed are deeply-equal in value.\n */ var deepEqual = createCustomEqual();\n/**\n * Whether the items passed are deeply-equal in value based on strict comparison.\n */ var strictDeepEqual = createCustomEqual({\n    strict: true\n});\n/**\n * Whether the items passed are deeply-equal in value, including circular references.\n */ var circularDeepEqual = createCustomEqual({\n    circular: true\n});\n/**\n * Whether the items passed are deeply-equal in value, including circular references,\n * based on strict comparison.\n */ var strictCircularDeepEqual = createCustomEqual({\n    circular: true,\n    strict: true\n});\n/**\n * Whether the items passed are shallowly-equal in value.\n */ var shallowEqual = createCustomEqual({\n    createInternalComparator: function() {\n        return sameValueZeroEqual;\n    }\n});\n/**\n * Whether the items passed are shallowly-equal in value based on strict comparison\n */ var strictShallowEqual = createCustomEqual({\n    strict: true,\n    createInternalComparator: function() {\n        return sameValueZeroEqual;\n    }\n});\n/**\n * Whether the items passed are shallowly-equal in value, including circular references.\n */ var circularShallowEqual = createCustomEqual({\n    circular: true,\n    createInternalComparator: function() {\n        return sameValueZeroEqual;\n    }\n});\n/**\n * Whether the items passed are shallowly-equal in value, including circular references,\n * based on strict comparison.\n */ var strictCircularShallowEqual = createCustomEqual({\n    circular: true,\n    createInternalComparator: function() {\n        return sameValueZeroEqual;\n    },\n    strict: true\n});\n/**\n * Create a custom equality comparison method.\n *\n * This can be done to create very targeted comparisons in extreme hot-path scenarios\n * where the standard methods are not performant enough, but can also be used to provide\n * support for legacy environments that do not support expected features like\n * `RegExp.prototype.flags` out of the box.\n */ function createCustomEqual(options) {\n    if (options === void 0) {\n        options = {};\n    }\n    var _a = options.circular, circular = _a === void 0 ? false : _a, createCustomInternalComparator = options.createInternalComparator, createState = options.createState, _b = options.strict, strict = _b === void 0 ? false : _b;\n    var config = createEqualityComparatorConfig(options);\n    var comparator = createEqualityComparator(config);\n    var equals = createCustomInternalComparator ? createCustomInternalComparator(comparator) : createInternalEqualityComparator(comparator);\n    return createIsEqual({\n        circular: circular,\n        comparator: comparator,\n        createState: createState,\n        equals: equals,\n        strict: strict\n    });\n}\n //# sourceMappingURL=index.mjs.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvZmFzdC1lcXVhbHMvZGlzdC9lc20vaW5kZXgubWpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7QUFBQSxJQUFJQSxzQkFBc0JDLE9BQU9ELG1CQUFtQixFQUFFRSx3QkFBd0JELE9BQU9DLHFCQUFxQjtBQUMxRyxJQUFJQyxpQkFBaUJGLE9BQU9HLFNBQVMsQ0FBQ0QsY0FBYztBQUNwRDs7Q0FFQyxHQUNELFNBQVNFLG1CQUFtQkMsV0FBVyxFQUFFQyxXQUFXO0lBQ2hELE9BQU8sU0FBU0MsUUFBUUMsQ0FBQyxFQUFFQyxDQUFDLEVBQUVDLEtBQUs7UUFDL0IsT0FBT0wsWUFBWUcsR0FBR0MsR0FBR0MsVUFBVUosWUFBWUUsR0FBR0MsR0FBR0M7SUFDekQ7QUFDSjtBQUNBOzs7O0NBSUMsR0FDRCxTQUFTQyxpQkFBaUJDLGFBQWE7SUFDbkMsT0FBTyxTQUFTQyxXQUFXTCxDQUFDLEVBQUVDLENBQUMsRUFBRUMsS0FBSztRQUNsQyxJQUFJLENBQUNGLEtBQUssQ0FBQ0MsS0FBSyxPQUFPRCxNQUFNLFlBQVksT0FBT0MsTUFBTSxVQUFVO1lBQzVELE9BQU9HLGNBQWNKLEdBQUdDLEdBQUdDO1FBQy9CO1FBQ0EsSUFBSUksUUFBUUosTUFBTUksS0FBSztRQUN2QixJQUFJQyxVQUFVRCxNQUFNRSxHQUFHLENBQUNSO1FBQ3hCLElBQUlTLFVBQVVILE1BQU1FLEdBQUcsQ0FBQ1A7UUFDeEIsSUFBSU0sV0FBV0UsU0FBUztZQUNwQixPQUFPRixZQUFZTixLQUFLUSxZQUFZVDtRQUN4QztRQUNBTSxNQUFNSSxHQUFHLENBQUNWLEdBQUdDO1FBQ2JLLE1BQU1JLEdBQUcsQ0FBQ1QsR0FBR0Q7UUFDYixJQUFJVyxTQUFTUCxjQUFjSixHQUFHQyxHQUFHQztRQUNqQ0ksTUFBTU0sTUFBTSxDQUFDWjtRQUNiTSxNQUFNTSxNQUFNLENBQUNYO1FBQ2IsT0FBT1U7SUFDWDtBQUNKO0FBQ0E7OztDQUdDLEdBQ0QsU0FBU0Usb0JBQW9CQyxNQUFNO0lBQy9CLE9BQU92QixvQkFBb0J1QixRQUFRQyxNQUFNLENBQUN0QixzQkFBc0JxQjtBQUNwRTtBQUNBOztDQUVDLEdBQ0QsSUFBSUUsU0FBU3hCLE9BQU93QixNQUFNLElBQ3JCLFNBQVVGLE1BQU0sRUFBRUcsUUFBUTtJQUN2QixPQUFPdkIsZUFBZXdCLElBQUksQ0FBQ0osUUFBUUc7QUFDdkM7QUFDSjs7Q0FFQyxHQUNELFNBQVNFLG1CQUFtQm5CLENBQUMsRUFBRUMsQ0FBQztJQUM1QixPQUFPRCxLQUFLQyxJQUFJRCxNQUFNQyxJQUFJRCxNQUFNQyxLQUFNRCxNQUFNQSxLQUFLQyxNQUFNQTtBQUMzRDtBQUVBLElBQUltQixRQUFRO0FBQ1osSUFBSUMsMkJBQTJCN0IsT0FBTzZCLHdCQUF3QixFQUFFQyxPQUFPOUIsT0FBTzhCLElBQUk7QUFDbEY7O0NBRUMsR0FDRCxTQUFTQyxlQUFldkIsQ0FBQyxFQUFFQyxDQUFDLEVBQUVDLEtBQUs7SUFDL0IsSUFBSXNCLFFBQVF4QixFQUFFeUIsTUFBTTtJQUNwQixJQUFJeEIsRUFBRXdCLE1BQU0sS0FBS0QsT0FBTztRQUNwQixPQUFPO0lBQ1g7SUFDQSxNQUFPQSxVQUFVLEVBQUc7UUFDaEIsSUFBSSxDQUFDdEIsTUFBTXdCLE1BQU0sQ0FBQzFCLENBQUMsQ0FBQ3dCLE1BQU0sRUFBRXZCLENBQUMsQ0FBQ3VCLE1BQU0sRUFBRUEsT0FBT0EsT0FBT3hCLEdBQUdDLEdBQUdDLFFBQVE7WUFDOUQsT0FBTztRQUNYO0lBQ0o7SUFDQSxPQUFPO0FBQ1g7QUFDQTs7Q0FFQyxHQUNELFNBQVN5QixjQUFjM0IsQ0FBQyxFQUFFQyxDQUFDO0lBQ3ZCLE9BQU9rQixtQkFBbUJuQixFQUFFNEIsT0FBTyxJQUFJM0IsRUFBRTJCLE9BQU87QUFDcEQ7QUFDQTs7Q0FFQyxHQUNELFNBQVNDLGFBQWE3QixDQUFDLEVBQUVDLENBQUMsRUFBRUMsS0FBSztJQUM3QixJQUFJRixFQUFFOEIsSUFBSSxLQUFLN0IsRUFBRTZCLElBQUksRUFBRTtRQUNuQixPQUFPO0lBQ1g7SUFDQSxJQUFJQyxpQkFBaUIsQ0FBQztJQUN0QixJQUFJQyxZQUFZaEMsRUFBRWlDLE9BQU87SUFDekIsSUFBSVQsUUFBUTtJQUNaLElBQUlVO0lBQ0osSUFBSUM7SUFDSixNQUFRRCxVQUFVRixVQUFVSSxJQUFJLEdBQUs7UUFDakMsSUFBSUYsUUFBUUcsSUFBSSxFQUFFO1lBQ2Q7UUFDSjtRQUNBLElBQUlDLFlBQVlyQyxFQUFFZ0MsT0FBTztRQUN6QixJQUFJTSxXQUFXO1FBQ2YsSUFBSUMsYUFBYTtRQUNqQixNQUFRTCxVQUFVRyxVQUFVRixJQUFJLEdBQUs7WUFDakMsSUFBSUQsUUFBUUUsSUFBSSxFQUFFO2dCQUNkO1lBQ0o7WUFDQSxJQUFJSSxLQUFLUCxRQUFRUSxLQUFLLEVBQUVDLE9BQU9GLEVBQUUsQ0FBQyxFQUFFLEVBQUVHLFNBQVNILEVBQUUsQ0FBQyxFQUFFO1lBQ3BELElBQUlJLEtBQUtWLFFBQVFPLEtBQUssRUFBRUksT0FBT0QsRUFBRSxDQUFDLEVBQUUsRUFBRUUsU0FBU0YsRUFBRSxDQUFDLEVBQUU7WUFDcEQsSUFBSSxDQUFDTixZQUNELENBQUNSLGNBQWMsQ0FBQ1MsV0FBVyxJQUMxQkQsQ0FBQUEsV0FDR3JDLE1BQU13QixNQUFNLENBQUNpQixNQUFNRyxNQUFNdEIsT0FBT2dCLFlBQVl4QyxHQUFHQyxHQUFHQyxVQUM5Q0EsTUFBTXdCLE1BQU0sQ0FBQ2tCLFFBQVFHLFFBQVFKLE1BQU1HLE1BQU05QyxHQUFHQyxHQUFHQyxNQUFLLEdBQUk7Z0JBQ2hFNkIsY0FBYyxDQUFDUyxXQUFXLEdBQUc7WUFDakM7WUFDQUE7UUFDSjtRQUNBLElBQUksQ0FBQ0QsVUFBVTtZQUNYLE9BQU87UUFDWDtRQUNBZjtJQUNKO0lBQ0EsT0FBTztBQUNYO0FBQ0E7O0NBRUMsR0FDRCxTQUFTd0IsZ0JBQWdCaEQsQ0FBQyxFQUFFQyxDQUFDLEVBQUVDLEtBQUs7SUFDaEMsSUFBSStDLGFBQWEzQixLQUFLdEI7SUFDdEIsSUFBSXdCLFFBQVF5QixXQUFXeEIsTUFBTTtJQUM3QixJQUFJSCxLQUFLckIsR0FBR3dCLE1BQU0sS0FBS0QsT0FBTztRQUMxQixPQUFPO0lBQ1g7SUFDQSxJQUFJUDtJQUNKLHlFQUF5RTtJQUN6RSw2RUFBNkU7SUFDN0UsNkVBQTZFO0lBQzdFLCtCQUErQjtJQUMvQixNQUFPTyxVQUFVLEVBQUc7UUFDaEJQLFdBQVdnQyxVQUFVLENBQUN6QixNQUFNO1FBQzVCLElBQUlQLGFBQWFHLFNBQ1pwQixDQUFBQSxFQUFFa0QsUUFBUSxJQUFJakQsRUFBRWlELFFBQVEsS0FDekJsRCxFQUFFa0QsUUFBUSxLQUFLakQsRUFBRWlELFFBQVEsRUFBRTtZQUMzQixPQUFPO1FBQ1g7UUFDQSxJQUFJLENBQUNsQyxPQUFPZixHQUFHZ0IsYUFDWCxDQUFDZixNQUFNd0IsTUFBTSxDQUFDMUIsQ0FBQyxDQUFDaUIsU0FBUyxFQUFFaEIsQ0FBQyxDQUFDZ0IsU0FBUyxFQUFFQSxVQUFVQSxVQUFVakIsR0FBR0MsR0FBR0MsUUFBUTtZQUMxRSxPQUFPO1FBQ1g7SUFDSjtJQUNBLE9BQU87QUFDWDtBQUNBOztDQUVDLEdBQ0QsU0FBU2lELHNCQUFzQm5ELENBQUMsRUFBRUMsQ0FBQyxFQUFFQyxLQUFLO0lBQ3RDLElBQUkrQyxhQUFhcEMsb0JBQW9CYjtJQUNyQyxJQUFJd0IsUUFBUXlCLFdBQVd4QixNQUFNO0lBQzdCLElBQUlaLG9CQUFvQlosR0FBR3dCLE1BQU0sS0FBS0QsT0FBTztRQUN6QyxPQUFPO0lBQ1g7SUFDQSxJQUFJUDtJQUNKLElBQUltQztJQUNKLElBQUlDO0lBQ0oseUVBQXlFO0lBQ3pFLDZFQUE2RTtJQUM3RSw2RUFBNkU7SUFDN0UsK0JBQStCO0lBQy9CLE1BQU83QixVQUFVLEVBQUc7UUFDaEJQLFdBQVdnQyxVQUFVLENBQUN6QixNQUFNO1FBQzVCLElBQUlQLGFBQWFHLFNBQ1pwQixDQUFBQSxFQUFFa0QsUUFBUSxJQUFJakQsRUFBRWlELFFBQVEsS0FDekJsRCxFQUFFa0QsUUFBUSxLQUFLakQsRUFBRWlELFFBQVEsRUFBRTtZQUMzQixPQUFPO1FBQ1g7UUFDQSxJQUFJLENBQUNsQyxPQUFPZixHQUFHZ0IsV0FBVztZQUN0QixPQUFPO1FBQ1g7UUFDQSxJQUFJLENBQUNmLE1BQU13QixNQUFNLENBQUMxQixDQUFDLENBQUNpQixTQUFTLEVBQUVoQixDQUFDLENBQUNnQixTQUFTLEVBQUVBLFVBQVVBLFVBQVVqQixHQUFHQyxHQUFHQyxRQUFRO1lBQzFFLE9BQU87UUFDWDtRQUNBa0QsY0FBYy9CLHlCQUF5QnJCLEdBQUdpQjtRQUMxQ29DLGNBQWNoQyx5QkFBeUJwQixHQUFHZ0I7UUFDMUMsSUFBSSxDQUFDbUMsZUFBZUMsV0FBVSxLQUN6QixFQUFDRCxlQUNFLENBQUNDLGVBQ0RELFlBQVlFLFlBQVksS0FBS0QsWUFBWUMsWUFBWSxJQUNyREYsWUFBWUcsVUFBVSxLQUFLRixZQUFZRSxVQUFVLElBQ2pESCxZQUFZSSxRQUFRLEtBQUtILFlBQVlHLFFBQVEsR0FBRztZQUNwRCxPQUFPO1FBQ1g7SUFDSjtJQUNBLE9BQU87QUFDWDtBQUNBOztDQUVDLEdBQ0QsU0FBU0MsMEJBQTBCekQsQ0FBQyxFQUFFQyxDQUFDO0lBQ25DLE9BQU9rQixtQkFBbUJuQixFQUFFMEQsT0FBTyxJQUFJekQsRUFBRXlELE9BQU87QUFDcEQ7QUFDQTs7Q0FFQyxHQUNELFNBQVNDLGdCQUFnQjNELENBQUMsRUFBRUMsQ0FBQztJQUN6QixPQUFPRCxFQUFFNEQsTUFBTSxLQUFLM0QsRUFBRTJELE1BQU0sSUFBSTVELEVBQUU2RCxLQUFLLEtBQUs1RCxFQUFFNEQsS0FBSztBQUN2RDtBQUNBOztDQUVDLEdBQ0QsU0FBU0MsYUFBYTlELENBQUMsRUFBRUMsQ0FBQyxFQUFFQyxLQUFLO0lBQzdCLElBQUlGLEVBQUU4QixJQUFJLEtBQUs3QixFQUFFNkIsSUFBSSxFQUFFO1FBQ25CLE9BQU87SUFDWDtJQUNBLElBQUlDLGlCQUFpQixDQUFDO0lBQ3RCLElBQUlDLFlBQVloQyxFQUFFK0QsTUFBTTtJQUN4QixJQUFJN0I7SUFDSixJQUFJQztJQUNKLE1BQVFELFVBQVVGLFVBQVVJLElBQUksR0FBSztRQUNqQyxJQUFJRixRQUFRRyxJQUFJLEVBQUU7WUFDZDtRQUNKO1FBQ0EsSUFBSUMsWUFBWXJDLEVBQUU4RCxNQUFNO1FBQ3hCLElBQUl4QixXQUFXO1FBQ2YsSUFBSUMsYUFBYTtRQUNqQixNQUFRTCxVQUFVRyxVQUFVRixJQUFJLEdBQUs7WUFDakMsSUFBSUQsUUFBUUUsSUFBSSxFQUFFO2dCQUNkO1lBQ0o7WUFDQSxJQUFJLENBQUNFLFlBQ0QsQ0FBQ1IsY0FBYyxDQUFDUyxXQUFXLElBQzFCRCxDQUFBQSxXQUFXckMsTUFBTXdCLE1BQU0sQ0FBQ1EsUUFBUVEsS0FBSyxFQUFFUCxRQUFRTyxLQUFLLEVBQUVSLFFBQVFRLEtBQUssRUFBRVAsUUFBUU8sS0FBSyxFQUFFMUMsR0FBR0MsR0FBR0MsTUFBSyxHQUFJO2dCQUNwRzZCLGNBQWMsQ0FBQ1MsV0FBVyxHQUFHO1lBQ2pDO1lBQ0FBO1FBQ0o7UUFDQSxJQUFJLENBQUNELFVBQVU7WUFDWCxPQUFPO1FBQ1g7SUFDSjtJQUNBLE9BQU87QUFDWDtBQUNBOztDQUVDLEdBQ0QsU0FBU3lCLG9CQUFvQmhFLENBQUMsRUFBRUMsQ0FBQztJQUM3QixJQUFJdUIsUUFBUXhCLEVBQUV5QixNQUFNO0lBQ3BCLElBQUl4QixFQUFFd0IsTUFBTSxLQUFLRCxPQUFPO1FBQ3BCLE9BQU87SUFDWDtJQUNBLE1BQU9BLFVBQVUsRUFBRztRQUNoQixJQUFJeEIsQ0FBQyxDQUFDd0IsTUFBTSxLQUFLdkIsQ0FBQyxDQUFDdUIsTUFBTSxFQUFFO1lBQ3ZCLE9BQU87UUFDWDtJQUNKO0lBQ0EsT0FBTztBQUNYO0FBRUEsSUFBSXlDLGdCQUFnQjtBQUNwQixJQUFJQyxjQUFjO0FBQ2xCLElBQUlDLFdBQVc7QUFDZixJQUFJQyxVQUFVO0FBQ2QsSUFBSUMsYUFBYTtBQUNqQixJQUFJQyxhQUFhO0FBQ2pCLElBQUlDLGNBQWM7QUFDbEIsSUFBSUMsVUFBVTtBQUNkLElBQUlDLGFBQWE7QUFDakIsSUFBSUMsVUFBVUMsTUFBTUQsT0FBTztBQUMzQixJQUFJRSxlQUFlLE9BQU9DLGdCQUFnQixjQUFjQSxZQUFZQyxNQUFNLEdBQ3BFRCxZQUFZQyxNQUFNLEdBQ2xCO0FBQ04sSUFBSUMsU0FBU3ZGLE9BQU91RixNQUFNO0FBQzFCLElBQUlDLFNBQVN4RixPQUFPRyxTQUFTLENBQUNzRixRQUFRLENBQUMvRCxJQUFJLENBQUNnRSxJQUFJLENBQUMxRixPQUFPRyxTQUFTLENBQUNzRixRQUFRO0FBQzFFOztDQUVDLEdBQ0QsU0FBU0UseUJBQXlCMUMsRUFBRTtJQUNoQyxJQUFJbEIsaUJBQWlCa0IsR0FBR2xCLGNBQWMsRUFBRUksZ0JBQWdCYyxHQUFHZCxhQUFhLEVBQUVFLGVBQWVZLEdBQUdaLFlBQVksRUFBRW1CLGtCQUFrQlAsR0FBR08sZUFBZSxFQUFFUyw0QkFBNEJoQixHQUFHZ0IseUJBQXlCLEVBQUVFLGtCQUFrQmxCLEdBQUdrQixlQUFlLEVBQUVHLGVBQWVyQixHQUFHcUIsWUFBWSxFQUFFRSxzQkFBc0J2QixHQUFHdUIsbUJBQW1CO0lBQzVUOztLQUVDLEdBQ0QsT0FBTyxTQUFTb0IsV0FBV3BGLENBQUMsRUFBRUMsQ0FBQyxFQUFFQyxLQUFLO1FBQ2xDLHFFQUFxRTtRQUNyRSxJQUFJRixNQUFNQyxHQUFHO1lBQ1QsT0FBTztRQUNYO1FBQ0Esc0VBQXNFO1FBQ3RFLHdFQUF3RTtRQUN4RSx1RUFBdUU7UUFDdkUsZ0RBQWdEO1FBQ2hELElBQUlELEtBQUssUUFDTEMsS0FBSyxRQUNMLE9BQU9ELE1BQU0sWUFDYixPQUFPQyxNQUFNLFVBQVU7WUFDdkIsT0FBT0QsTUFBTUEsS0FBS0MsTUFBTUE7UUFDNUI7UUFDQSxJQUFJb0YsY0FBY3JGLEVBQUVxRixXQUFXO1FBQy9CLHlEQUF5RDtRQUN6RCx5REFBeUQ7UUFDekQseUNBQXlDO1FBQ3pDLG1EQUFtRDtRQUNuRCw2REFBNkQ7UUFDN0QsNkRBQTZEO1FBQzdELDZEQUE2RDtRQUM3RCxzQ0FBc0M7UUFDdEMsOEVBQThFO1FBQzlFLHdEQUF3RDtRQUN4RCxJQUFJQSxnQkFBZ0JwRixFQUFFb0YsV0FBVyxFQUFFO1lBQy9CLE9BQU87UUFDWDtRQUNBLDBFQUEwRTtRQUMxRSx5RUFBeUU7UUFDekUseUNBQXlDO1FBQ3pDLElBQUlBLGdCQUFnQjdGLFFBQVE7WUFDeEIsT0FBT3dELGdCQUFnQmhELEdBQUdDLEdBQUdDO1FBQ2pDO1FBQ0EsZ0ZBQWdGO1FBQ2hGLGlEQUFpRDtRQUNqRCxJQUFJd0UsUUFBUTFFLElBQUk7WUFDWixPQUFPdUIsZUFBZXZCLEdBQUdDLEdBQUdDO1FBQ2hDO1FBQ0EsNkVBQTZFO1FBQzdFLDJFQUEyRTtRQUMzRSxJQUFJMEUsZ0JBQWdCLFFBQVFBLGFBQWE1RSxJQUFJO1lBQ3pDLE9BQU9nRSxvQkFBb0JoRSxHQUFHQyxHQUFHQztRQUNyQztRQUNBLHlFQUF5RTtRQUN6RSx3RUFBd0U7UUFDeEUsdUVBQXVFO1FBQ3ZFLHlFQUF5RTtRQUN6RSxrQ0FBa0M7UUFDbEMsSUFBSW1GLGdCQUFnQkMsTUFBTTtZQUN0QixPQUFPM0QsY0FBYzNCLEdBQUdDLEdBQUdDO1FBQy9CO1FBQ0EsSUFBSW1GLGdCQUFnQkUsUUFBUTtZQUN4QixPQUFPNUIsZ0JBQWdCM0QsR0FBR0MsR0FBR0M7UUFDakM7UUFDQSxJQUFJbUYsZ0JBQWdCRyxLQUFLO1lBQ3JCLE9BQU8zRCxhQUFhN0IsR0FBR0MsR0FBR0M7UUFDOUI7UUFDQSxJQUFJbUYsZ0JBQWdCSSxLQUFLO1lBQ3JCLE9BQU8zQixhQUFhOUQsR0FBR0MsR0FBR0M7UUFDOUI7UUFDQSwrRUFBK0U7UUFDL0UsaUZBQWlGO1FBQ2pGLElBQUl3RixNQUFNVixPQUFPaEY7UUFDakIsSUFBSTBGLFFBQVF2QixVQUFVO1lBQ2xCLE9BQU94QyxjQUFjM0IsR0FBR0MsR0FBR0M7UUFDL0I7UUFDQSxJQUFJd0YsUUFBUW5CLGFBQWE7WUFDckIsT0FBT1osZ0JBQWdCM0QsR0FBR0MsR0FBR0M7UUFDakM7UUFDQSxJQUFJd0YsUUFBUXRCLFNBQVM7WUFDakIsT0FBT3ZDLGFBQWE3QixHQUFHQyxHQUFHQztRQUM5QjtRQUNBLElBQUl3RixRQUFRbEIsU0FBUztZQUNqQixPQUFPVixhQUFhOUQsR0FBR0MsR0FBR0M7UUFDOUI7UUFDQSxJQUFJd0YsUUFBUXBCLFlBQVk7WUFDcEIsNEZBQTRGO1lBQzVGLHlGQUF5RjtZQUN6RixpRkFBaUY7WUFDakYsT0FBUSxPQUFPdEUsRUFBRTJGLElBQUksS0FBSyxjQUN0QixPQUFPMUYsRUFBRTBGLElBQUksS0FBSyxjQUNsQjNDLGdCQUFnQmhELEdBQUdDLEdBQUdDO1FBQzlCO1FBQ0Esa0VBQWtFO1FBQ2xFLElBQUl3RixRQUFRekIsZUFBZTtZQUN2QixPQUFPakIsZ0JBQWdCaEQsR0FBR0MsR0FBR0M7UUFDakM7UUFDQSx1RkFBdUY7UUFDdkYsMkZBQTJGO1FBQzNGLFNBQVM7UUFDVCxJQUFJd0YsUUFBUXhCLGVBQWV3QixRQUFRckIsY0FBY3FCLFFBQVFqQixZQUFZO1lBQ2pFLE9BQU9oQiwwQkFBMEJ6RCxHQUFHQyxHQUFHQztRQUMzQztRQUNBLHVHQUF1RztRQUN2RywyR0FBMkc7UUFDM0cscUdBQXFHO1FBQ3JHLG1DQUFtQztRQUNuQyxzRkFBc0Y7UUFDdEYsc0ZBQXNGO1FBQ3RGLDRFQUE0RTtRQUM1RSx5RkFBeUY7UUFDekYsdUdBQXVHO1FBQ3ZHLDJGQUEyRjtRQUMzRixnQ0FBZ0M7UUFDaEMsT0FBTztJQUNYO0FBQ0o7QUFDQTs7Q0FFQyxHQUNELFNBQVMwRiwrQkFBK0JuRCxFQUFFO0lBQ3RDLElBQUlvRCxXQUFXcEQsR0FBR29ELFFBQVEsRUFBRUMscUJBQXFCckQsR0FBR3FELGtCQUFrQixFQUFFQyxTQUFTdEQsR0FBR3NELE1BQU07SUFDMUYsSUFBSUMsU0FBUztRQUNUekUsZ0JBQWdCd0UsU0FDVjVDLHdCQUNBNUI7UUFDTkksZUFBZUE7UUFDZkUsY0FBY2tFLFNBQ1JuRyxtQkFBbUJpQyxjQUFjc0IseUJBQ2pDdEI7UUFDTm1CLGlCQUFpQitDLFNBQ1g1Qyx3QkFDQUg7UUFDTlMsMkJBQTJCQTtRQUMzQkUsaUJBQWlCQTtRQUNqQkcsY0FBY2lDLFNBQ1JuRyxtQkFBbUJrRSxjQUFjWCx5QkFDakNXO1FBQ05FLHFCQUFxQitCLFNBQ2Y1Qyx3QkFDQWE7SUFDVjtJQUNBLElBQUk4QixvQkFBb0I7UUFDcEJFLFNBQVNqQixPQUFPLENBQUMsR0FBR2lCLFFBQVFGLG1CQUFtQkU7SUFDbkQ7SUFDQSxJQUFJSCxVQUFVO1FBQ1YsSUFBSUksbUJBQW1COUYsaUJBQWlCNkYsT0FBT3pFLGNBQWM7UUFDN0QsSUFBSTJFLGlCQUFpQi9GLGlCQUFpQjZGLE9BQU9uRSxZQUFZO1FBQ3pELElBQUlzRSxvQkFBb0JoRyxpQkFBaUI2RixPQUFPaEQsZUFBZTtRQUMvRCxJQUFJb0QsaUJBQWlCakcsaUJBQWlCNkYsT0FBT2xDLFlBQVk7UUFDekRrQyxTQUFTakIsT0FBTyxDQUFDLEdBQUdpQixRQUFRO1lBQ3hCekUsZ0JBQWdCMEU7WUFDaEJwRSxjQUFjcUU7WUFDZGxELGlCQUFpQm1EO1lBQ2pCckMsY0FBY3NDO1FBQ2xCO0lBQ0o7SUFDQSxPQUFPSjtBQUNYO0FBQ0E7OztDQUdDLEdBQ0QsU0FBU0ssaUNBQWlDQyxPQUFPO0lBQzdDLE9BQU8sU0FBVXRHLENBQUMsRUFBRUMsQ0FBQyxFQUFFc0csWUFBWSxFQUFFQyxZQUFZLEVBQUVDLFFBQVEsRUFBRUMsUUFBUSxFQUFFeEcsS0FBSztRQUN4RSxPQUFPb0csUUFBUXRHLEdBQUdDLEdBQUdDO0lBQ3pCO0FBQ0o7QUFDQTs7Q0FFQyxHQUNELFNBQVN5RyxjQUFjbEUsRUFBRTtJQUNyQixJQUFJb0QsV0FBV3BELEdBQUdvRCxRQUFRLEVBQUVULGFBQWEzQyxHQUFHMkMsVUFBVSxFQUFFd0IsY0FBY25FLEdBQUdtRSxXQUFXLEVBQUVsRixTQUFTZSxHQUFHZixNQUFNLEVBQUVxRSxTQUFTdEQsR0FBR3NELE1BQU07SUFDNUgsSUFBSWEsYUFBYTtRQUNiLE9BQU8sU0FBUzdHLFFBQVFDLENBQUMsRUFBRUMsQ0FBQztZQUN4QixJQUFJd0MsS0FBS21FLGVBQWUvRCxLQUFLSixHQUFHbkMsS0FBSyxFQUFFQSxRQUFRdUMsT0FBTyxLQUFLLElBQUlnRCxXQUFXLElBQUlnQixZQUFZQyxZQUFZakUsSUFBSWtFLE9BQU90RSxHQUFHc0UsSUFBSTtZQUN4SCxPQUFPM0IsV0FBV3BGLEdBQUdDLEdBQUc7Z0JBQ3BCSyxPQUFPQTtnQkFDUG9CLFFBQVFBO2dCQUNScUYsTUFBTUE7Z0JBQ05oQixRQUFRQTtZQUNaO1FBQ0o7SUFDSjtJQUNBLElBQUlGLFVBQVU7UUFDVixPQUFPLFNBQVM5RixRQUFRQyxDQUFDLEVBQUVDLENBQUM7WUFDeEIsT0FBT21GLFdBQVdwRixHQUFHQyxHQUFHO2dCQUNwQkssT0FBTyxJQUFJdUc7Z0JBQ1huRixRQUFRQTtnQkFDUnFGLE1BQU1EO2dCQUNOZixRQUFRQTtZQUNaO1FBQ0o7SUFDSjtJQUNBLElBQUk3RixRQUFRO1FBQ1JJLE9BQU93RztRQUNQcEYsUUFBUUE7UUFDUnFGLE1BQU1EO1FBQ05mLFFBQVFBO0lBQ1o7SUFDQSxPQUFPLFNBQVNoRyxRQUFRQyxDQUFDLEVBQUVDLENBQUM7UUFDeEIsT0FBT21GLFdBQVdwRixHQUFHQyxHQUFHQztJQUM1QjtBQUNKO0FBRUE7O0NBRUMsR0FDRCxJQUFJOEcsWUFBWUM7QUFDaEI7O0NBRUMsR0FDRCxJQUFJQyxrQkFBa0JELGtCQUFrQjtJQUFFbEIsUUFBUTtBQUFLO0FBQ3ZEOztDQUVDLEdBQ0QsSUFBSW9CLG9CQUFvQkYsa0JBQWtCO0lBQUVwQixVQUFVO0FBQUs7QUFDM0Q7OztDQUdDLEdBQ0QsSUFBSXVCLDBCQUEwQkgsa0JBQWtCO0lBQzVDcEIsVUFBVTtJQUNWRSxRQUFRO0FBQ1o7QUFDQTs7Q0FFQyxHQUNELElBQUlzQixlQUFlSixrQkFBa0I7SUFDakNLLDBCQUEwQjtRQUFjLE9BQU9uRztJQUFvQjtBQUN2RTtBQUNBOztDQUVDLEdBQ0QsSUFBSW9HLHFCQUFxQk4sa0JBQWtCO0lBQ3ZDbEIsUUFBUTtJQUNSdUIsMEJBQTBCO1FBQWMsT0FBT25HO0lBQW9CO0FBQ3ZFO0FBQ0E7O0NBRUMsR0FDRCxJQUFJcUcsdUJBQXVCUCxrQkFBa0I7SUFDekNwQixVQUFVO0lBQ1Z5QiwwQkFBMEI7UUFBYyxPQUFPbkc7SUFBb0I7QUFDdkU7QUFDQTs7O0NBR0MsR0FDRCxJQUFJc0csNkJBQTZCUixrQkFBa0I7SUFDL0NwQixVQUFVO0lBQ1Z5QiwwQkFBMEI7UUFBYyxPQUFPbkc7SUFBb0I7SUFDbkU0RSxRQUFRO0FBQ1o7QUFDQTs7Ozs7OztDQU9DLEdBQ0QsU0FBU2tCLGtCQUFrQlMsT0FBTztJQUM5QixJQUFJQSxZQUFZLEtBQUssR0FBRztRQUFFQSxVQUFVLENBQUM7SUFBRztJQUN4QyxJQUFJakYsS0FBS2lGLFFBQVE3QixRQUFRLEVBQUVBLFdBQVdwRCxPQUFPLEtBQUssSUFBSSxRQUFRQSxJQUFJa0YsaUNBQWlDRCxRQUFRSix3QkFBd0IsRUFBRVYsY0FBY2MsUUFBUWQsV0FBVyxFQUFFL0QsS0FBSzZFLFFBQVEzQixNQUFNLEVBQUVBLFNBQVNsRCxPQUFPLEtBQUssSUFBSSxRQUFRQTtJQUM5TixJQUFJbUQsU0FBU0osK0JBQStCOEI7SUFDNUMsSUFBSXRDLGFBQWFELHlCQUF5QmE7SUFDMUMsSUFBSXRFLFNBQVNpRyxpQ0FDUEEsK0JBQStCdkMsY0FDL0JpQixpQ0FBaUNqQjtJQUN2QyxPQUFPdUIsY0FBYztRQUFFZCxVQUFVQTtRQUFVVCxZQUFZQTtRQUFZd0IsYUFBYUE7UUFBYWxGLFFBQVFBO1FBQVFxRSxRQUFRQTtJQUFPO0FBQ2hJO0FBRTZNLENBQzdNLGtDQUFrQyIsInNvdXJjZXMiOlsid2VicGFjazovL2xhbmRpbmcvLi9ub2RlX21vZHVsZXMvZmFzdC1lcXVhbHMvZGlzdC9lc20vaW5kZXgubWpzPzEwZDciXSwic291cmNlc0NvbnRlbnQiOlsidmFyIGdldE93blByb3BlcnR5TmFtZXMgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcywgZ2V0T3duUHJvcGVydHlTeW1ib2xzID0gT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scztcbnZhciBoYXNPd25Qcm9wZXJ0eSA9IE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHk7XG4vKipcbiAqIENvbWJpbmUgdHdvIGNvbXBhcmF0b3JzIGludG8gYSBzaW5nbGUgY29tcGFyYXRvcnMuXG4gKi9cbmZ1bmN0aW9uIGNvbWJpbmVDb21wYXJhdG9ycyhjb21wYXJhdG9yQSwgY29tcGFyYXRvckIpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24gaXNFcXVhbChhLCBiLCBzdGF0ZSkge1xuICAgICAgICByZXR1cm4gY29tcGFyYXRvckEoYSwgYiwgc3RhdGUpICYmIGNvbXBhcmF0b3JCKGEsIGIsIHN0YXRlKTtcbiAgICB9O1xufVxuLyoqXG4gKiBXcmFwIHRoZSBwcm92aWRlZCBgYXJlSXRlbXNFcXVhbGAgbWV0aG9kIHRvIG1hbmFnZSB0aGUgY2lyY3VsYXIgc3RhdGUsIGFsbG93aW5nXG4gKiBmb3IgY2lyY3VsYXIgcmVmZXJlbmNlcyB0byBiZSBzYWZlbHkgaW5jbHVkZWQgaW4gdGhlIGNvbXBhcmlzb24gd2l0aG91dCBjcmVhdGluZ1xuICogc3RhY2sgb3ZlcmZsb3dzLlxuICovXG5mdW5jdGlvbiBjcmVhdGVJc0NpcmN1bGFyKGFyZUl0ZW1zRXF1YWwpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24gaXNDaXJjdWxhcihhLCBiLCBzdGF0ZSkge1xuICAgICAgICBpZiAoIWEgfHwgIWIgfHwgdHlwZW9mIGEgIT09ICdvYmplY3QnIHx8IHR5cGVvZiBiICE9PSAnb2JqZWN0Jykge1xuICAgICAgICAgICAgcmV0dXJuIGFyZUl0ZW1zRXF1YWwoYSwgYiwgc3RhdGUpO1xuICAgICAgICB9XG4gICAgICAgIHZhciBjYWNoZSA9IHN0YXRlLmNhY2hlO1xuICAgICAgICB2YXIgY2FjaGVkQSA9IGNhY2hlLmdldChhKTtcbiAgICAgICAgdmFyIGNhY2hlZEIgPSBjYWNoZS5nZXQoYik7XG4gICAgICAgIGlmIChjYWNoZWRBICYmIGNhY2hlZEIpIHtcbiAgICAgICAgICAgIHJldHVybiBjYWNoZWRBID09PSBiICYmIGNhY2hlZEIgPT09IGE7XG4gICAgICAgIH1cbiAgICAgICAgY2FjaGUuc2V0KGEsIGIpO1xuICAgICAgICBjYWNoZS5zZXQoYiwgYSk7XG4gICAgICAgIHZhciByZXN1bHQgPSBhcmVJdGVtc0VxdWFsKGEsIGIsIHN0YXRlKTtcbiAgICAgICAgY2FjaGUuZGVsZXRlKGEpO1xuICAgICAgICBjYWNoZS5kZWxldGUoYik7XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfTtcbn1cbi8qKlxuICogR2V0IHRoZSBwcm9wZXJ0aWVzIHRvIHN0cmljdGx5IGV4YW1pbmUsIHdoaWNoIGluY2x1ZGUgYm90aCBvd24gcHJvcGVydGllcyB0aGF0IGFyZVxuICogbm90IGVudW1lcmFibGUgYW5kIHN5bWJvbCBwcm9wZXJ0aWVzLlxuICovXG5mdW5jdGlvbiBnZXRTdHJpY3RQcm9wZXJ0aWVzKG9iamVjdCkge1xuICAgIHJldHVybiBnZXRPd25Qcm9wZXJ0eU5hbWVzKG9iamVjdCkuY29uY2F0KGdldE93blByb3BlcnR5U3ltYm9scyhvYmplY3QpKTtcbn1cbi8qKlxuICogV2hldGhlciB0aGUgb2JqZWN0IGNvbnRhaW5zIHRoZSBwcm9wZXJ0eSBwYXNzZWQgYXMgYW4gb3duIHByb3BlcnR5LlxuICovXG52YXIgaGFzT3duID0gT2JqZWN0Lmhhc093biB8fFxuICAgIChmdW5jdGlvbiAob2JqZWN0LCBwcm9wZXJ0eSkge1xuICAgICAgICByZXR1cm4gaGFzT3duUHJvcGVydHkuY2FsbChvYmplY3QsIHByb3BlcnR5KTtcbiAgICB9KTtcbi8qKlxuICogV2hldGhlciB0aGUgdmFsdWVzIHBhc3NlZCBhcmUgc3RyaWN0bHkgZXF1YWwgb3IgYm90aCBOYU4uXG4gKi9cbmZ1bmN0aW9uIHNhbWVWYWx1ZVplcm9FcXVhbChhLCBiKSB7XG4gICAgcmV0dXJuIGEgfHwgYiA/IGEgPT09IGIgOiBhID09PSBiIHx8IChhICE9PSBhICYmIGIgIT09IGIpO1xufVxuXG52YXIgT1dORVIgPSAnX293bmVyJztcbnZhciBnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yLCBrZXlzID0gT2JqZWN0LmtleXM7XG4vKipcbiAqIFdoZXRoZXIgdGhlIGFycmF5cyBhcmUgZXF1YWwgaW4gdmFsdWUuXG4gKi9cbmZ1bmN0aW9uIGFyZUFycmF5c0VxdWFsKGEsIGIsIHN0YXRlKSB7XG4gICAgdmFyIGluZGV4ID0gYS5sZW5ndGg7XG4gICAgaWYgKGIubGVuZ3RoICE9PSBpbmRleCkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIHdoaWxlIChpbmRleC0tID4gMCkge1xuICAgICAgICBpZiAoIXN0YXRlLmVxdWFscyhhW2luZGV4XSwgYltpbmRleF0sIGluZGV4LCBpbmRleCwgYSwgYiwgc3RhdGUpKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHRydWU7XG59XG4vKipcbiAqIFdoZXRoZXIgdGhlIGRhdGVzIHBhc3NlZCBhcmUgZXF1YWwgaW4gdmFsdWUuXG4gKi9cbmZ1bmN0aW9uIGFyZURhdGVzRXF1YWwoYSwgYikge1xuICAgIHJldHVybiBzYW1lVmFsdWVaZXJvRXF1YWwoYS5nZXRUaW1lKCksIGIuZ2V0VGltZSgpKTtcbn1cbi8qKlxuICogV2hldGhlciB0aGUgYE1hcGBzIGFyZSBlcXVhbCBpbiB2YWx1ZS5cbiAqL1xuZnVuY3Rpb24gYXJlTWFwc0VxdWFsKGEsIGIsIHN0YXRlKSB7XG4gICAgaWYgKGEuc2l6ZSAhPT0gYi5zaXplKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgdmFyIG1hdGNoZWRJbmRpY2VzID0ge307XG4gICAgdmFyIGFJdGVyYWJsZSA9IGEuZW50cmllcygpO1xuICAgIHZhciBpbmRleCA9IDA7XG4gICAgdmFyIGFSZXN1bHQ7XG4gICAgdmFyIGJSZXN1bHQ7XG4gICAgd2hpbGUgKChhUmVzdWx0ID0gYUl0ZXJhYmxlLm5leHQoKSkpIHtcbiAgICAgICAgaWYgKGFSZXN1bHQuZG9uZSkge1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGJJdGVyYWJsZSA9IGIuZW50cmllcygpO1xuICAgICAgICB2YXIgaGFzTWF0Y2ggPSBmYWxzZTtcbiAgICAgICAgdmFyIG1hdGNoSW5kZXggPSAwO1xuICAgICAgICB3aGlsZSAoKGJSZXN1bHQgPSBiSXRlcmFibGUubmV4dCgpKSkge1xuICAgICAgICAgICAgaWYgKGJSZXN1bHQuZG9uZSkge1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIF9hID0gYVJlc3VsdC52YWx1ZSwgYUtleSA9IF9hWzBdLCBhVmFsdWUgPSBfYVsxXTtcbiAgICAgICAgICAgIHZhciBfYiA9IGJSZXN1bHQudmFsdWUsIGJLZXkgPSBfYlswXSwgYlZhbHVlID0gX2JbMV07XG4gICAgICAgICAgICBpZiAoIWhhc01hdGNoICYmXG4gICAgICAgICAgICAgICAgIW1hdGNoZWRJbmRpY2VzW21hdGNoSW5kZXhdICYmXG4gICAgICAgICAgICAgICAgKGhhc01hdGNoID1cbiAgICAgICAgICAgICAgICAgICAgc3RhdGUuZXF1YWxzKGFLZXksIGJLZXksIGluZGV4LCBtYXRjaEluZGV4LCBhLCBiLCBzdGF0ZSkgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0YXRlLmVxdWFscyhhVmFsdWUsIGJWYWx1ZSwgYUtleSwgYktleSwgYSwgYiwgc3RhdGUpKSkge1xuICAgICAgICAgICAgICAgIG1hdGNoZWRJbmRpY2VzW21hdGNoSW5kZXhdID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIG1hdGNoSW5kZXgrKztcbiAgICAgICAgfVxuICAgICAgICBpZiAoIWhhc01hdGNoKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgaW5kZXgrKztcbiAgICB9XG4gICAgcmV0dXJuIHRydWU7XG59XG4vKipcbiAqIFdoZXRoZXIgdGhlIG9iamVjdHMgYXJlIGVxdWFsIGluIHZhbHVlLlxuICovXG5mdW5jdGlvbiBhcmVPYmplY3RzRXF1YWwoYSwgYiwgc3RhdGUpIHtcbiAgICB2YXIgcHJvcGVydGllcyA9IGtleXMoYSk7XG4gICAgdmFyIGluZGV4ID0gcHJvcGVydGllcy5sZW5ndGg7XG4gICAgaWYgKGtleXMoYikubGVuZ3RoICE9PSBpbmRleCkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIHZhciBwcm9wZXJ0eTtcbiAgICAvLyBEZWNyZW1lbnRpbmcgYHdoaWxlYCBzaG93ZWQgZmFzdGVyIHJlc3VsdHMgdGhhbiBlaXRoZXIgaW5jcmVtZW50aW5nIG9yXG4gICAgLy8gZGVjcmVtZW50aW5nIGBmb3JgIGxvb3AgYW5kIHRoYW4gYW4gaW5jcmVtZW50aW5nIGB3aGlsZWAgbG9vcC4gRGVjbGFyYXRpdmVcbiAgICAvLyBtZXRob2RzIGxpa2UgYHNvbWVgIC8gYGV2ZXJ5YCB3ZXJlIG5vdCB1c2VkIHRvIGF2b2lkIGluY3VycmluZyB0aGUgZ2FyYmFnZVxuICAgIC8vIGNvc3Qgb2YgYW5vbnltb3VzIGNhbGxiYWNrcy5cbiAgICB3aGlsZSAoaW5kZXgtLSA+IDApIHtcbiAgICAgICAgcHJvcGVydHkgPSBwcm9wZXJ0aWVzW2luZGV4XTtcbiAgICAgICAgaWYgKHByb3BlcnR5ID09PSBPV05FUiAmJlxuICAgICAgICAgICAgKGEuJCR0eXBlb2YgfHwgYi4kJHR5cGVvZikgJiZcbiAgICAgICAgICAgIGEuJCR0eXBlb2YgIT09IGIuJCR0eXBlb2YpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIWhhc093bihiLCBwcm9wZXJ0eSkgfHxcbiAgICAgICAgICAgICFzdGF0ZS5lcXVhbHMoYVtwcm9wZXJ0eV0sIGJbcHJvcGVydHldLCBwcm9wZXJ0eSwgcHJvcGVydHksIGEsIGIsIHN0YXRlKSkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiB0cnVlO1xufVxuLyoqXG4gKiBXaGV0aGVyIHRoZSBvYmplY3RzIGFyZSBlcXVhbCBpbiB2YWx1ZSB3aXRoIHN0cmljdCBwcm9wZXJ0eSBjaGVja2luZy5cbiAqL1xuZnVuY3Rpb24gYXJlT2JqZWN0c0VxdWFsU3RyaWN0KGEsIGIsIHN0YXRlKSB7XG4gICAgdmFyIHByb3BlcnRpZXMgPSBnZXRTdHJpY3RQcm9wZXJ0aWVzKGEpO1xuICAgIHZhciBpbmRleCA9IHByb3BlcnRpZXMubGVuZ3RoO1xuICAgIGlmIChnZXRTdHJpY3RQcm9wZXJ0aWVzKGIpLmxlbmd0aCAhPT0gaW5kZXgpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICB2YXIgcHJvcGVydHk7XG4gICAgdmFyIGRlc2NyaXB0b3JBO1xuICAgIHZhciBkZXNjcmlwdG9yQjtcbiAgICAvLyBEZWNyZW1lbnRpbmcgYHdoaWxlYCBzaG93ZWQgZmFzdGVyIHJlc3VsdHMgdGhhbiBlaXRoZXIgaW5jcmVtZW50aW5nIG9yXG4gICAgLy8gZGVjcmVtZW50aW5nIGBmb3JgIGxvb3AgYW5kIHRoYW4gYW4gaW5jcmVtZW50aW5nIGB3aGlsZWAgbG9vcC4gRGVjbGFyYXRpdmVcbiAgICAvLyBtZXRob2RzIGxpa2UgYHNvbWVgIC8gYGV2ZXJ5YCB3ZXJlIG5vdCB1c2VkIHRvIGF2b2lkIGluY3VycmluZyB0aGUgZ2FyYmFnZVxuICAgIC8vIGNvc3Qgb2YgYW5vbnltb3VzIGNhbGxiYWNrcy5cbiAgICB3aGlsZSAoaW5kZXgtLSA+IDApIHtcbiAgICAgICAgcHJvcGVydHkgPSBwcm9wZXJ0aWVzW2luZGV4XTtcbiAgICAgICAgaWYgKHByb3BlcnR5ID09PSBPV05FUiAmJlxuICAgICAgICAgICAgKGEuJCR0eXBlb2YgfHwgYi4kJHR5cGVvZikgJiZcbiAgICAgICAgICAgIGEuJCR0eXBlb2YgIT09IGIuJCR0eXBlb2YpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIWhhc093bihiLCBwcm9wZXJ0eSkpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIXN0YXRlLmVxdWFscyhhW3Byb3BlcnR5XSwgYltwcm9wZXJ0eV0sIHByb3BlcnR5LCBwcm9wZXJ0eSwgYSwgYiwgc3RhdGUpKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgZGVzY3JpcHRvckEgPSBnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoYSwgcHJvcGVydHkpO1xuICAgICAgICBkZXNjcmlwdG9yQiA9IGdldE93blByb3BlcnR5RGVzY3JpcHRvcihiLCBwcm9wZXJ0eSk7XG4gICAgICAgIGlmICgoZGVzY3JpcHRvckEgfHwgZGVzY3JpcHRvckIpICYmXG4gICAgICAgICAgICAoIWRlc2NyaXB0b3JBIHx8XG4gICAgICAgICAgICAgICAgIWRlc2NyaXB0b3JCIHx8XG4gICAgICAgICAgICAgICAgZGVzY3JpcHRvckEuY29uZmlndXJhYmxlICE9PSBkZXNjcmlwdG9yQi5jb25maWd1cmFibGUgfHxcbiAgICAgICAgICAgICAgICBkZXNjcmlwdG9yQS5lbnVtZXJhYmxlICE9PSBkZXNjcmlwdG9yQi5lbnVtZXJhYmxlIHx8XG4gICAgICAgICAgICAgICAgZGVzY3JpcHRvckEud3JpdGFibGUgIT09IGRlc2NyaXB0b3JCLndyaXRhYmxlKSkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiB0cnVlO1xufVxuLyoqXG4gKiBXaGV0aGVyIHRoZSBwcmltaXRpdmUgd3JhcHBlcnMgcGFzc2VkIGFyZSBlcXVhbCBpbiB2YWx1ZS5cbiAqL1xuZnVuY3Rpb24gYXJlUHJpbWl0aXZlV3JhcHBlcnNFcXVhbChhLCBiKSB7XG4gICAgcmV0dXJuIHNhbWVWYWx1ZVplcm9FcXVhbChhLnZhbHVlT2YoKSwgYi52YWx1ZU9mKCkpO1xufVxuLyoqXG4gKiBXaGV0aGVyIHRoZSByZWdleHBzIHBhc3NlZCBhcmUgZXF1YWwgaW4gdmFsdWUuXG4gKi9cbmZ1bmN0aW9uIGFyZVJlZ0V4cHNFcXVhbChhLCBiKSB7XG4gICAgcmV0dXJuIGEuc291cmNlID09PSBiLnNvdXJjZSAmJiBhLmZsYWdzID09PSBiLmZsYWdzO1xufVxuLyoqXG4gKiBXaGV0aGVyIHRoZSBgU2V0YHMgYXJlIGVxdWFsIGluIHZhbHVlLlxuICovXG5mdW5jdGlvbiBhcmVTZXRzRXF1YWwoYSwgYiwgc3RhdGUpIHtcbiAgICBpZiAoYS5zaXplICE9PSBiLnNpemUpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICB2YXIgbWF0Y2hlZEluZGljZXMgPSB7fTtcbiAgICB2YXIgYUl0ZXJhYmxlID0gYS52YWx1ZXMoKTtcbiAgICB2YXIgYVJlc3VsdDtcbiAgICB2YXIgYlJlc3VsdDtcbiAgICB3aGlsZSAoKGFSZXN1bHQgPSBhSXRlcmFibGUubmV4dCgpKSkge1xuICAgICAgICBpZiAoYVJlc3VsdC5kb25lKSB7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICB2YXIgYkl0ZXJhYmxlID0gYi52YWx1ZXMoKTtcbiAgICAgICAgdmFyIGhhc01hdGNoID0gZmFsc2U7XG4gICAgICAgIHZhciBtYXRjaEluZGV4ID0gMDtcbiAgICAgICAgd2hpbGUgKChiUmVzdWx0ID0gYkl0ZXJhYmxlLm5leHQoKSkpIHtcbiAgICAgICAgICAgIGlmIChiUmVzdWx0LmRvbmUpIHtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghaGFzTWF0Y2ggJiZcbiAgICAgICAgICAgICAgICAhbWF0Y2hlZEluZGljZXNbbWF0Y2hJbmRleF0gJiZcbiAgICAgICAgICAgICAgICAoaGFzTWF0Y2ggPSBzdGF0ZS5lcXVhbHMoYVJlc3VsdC52YWx1ZSwgYlJlc3VsdC52YWx1ZSwgYVJlc3VsdC52YWx1ZSwgYlJlc3VsdC52YWx1ZSwgYSwgYiwgc3RhdGUpKSkge1xuICAgICAgICAgICAgICAgIG1hdGNoZWRJbmRpY2VzW21hdGNoSW5kZXhdID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIG1hdGNoSW5kZXgrKztcbiAgICAgICAgfVxuICAgICAgICBpZiAoIWhhc01hdGNoKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHRydWU7XG59XG4vKipcbiAqIFdoZXRoZXIgdGhlIFR5cGVkQXJyYXkgaW5zdGFuY2VzIGFyZSBlcXVhbCBpbiB2YWx1ZS5cbiAqL1xuZnVuY3Rpb24gYXJlVHlwZWRBcnJheXNFcXVhbChhLCBiKSB7XG4gICAgdmFyIGluZGV4ID0gYS5sZW5ndGg7XG4gICAgaWYgKGIubGVuZ3RoICE9PSBpbmRleCkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIHdoaWxlIChpbmRleC0tID4gMCkge1xuICAgICAgICBpZiAoYVtpbmRleF0gIT09IGJbaW5kZXhdKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHRydWU7XG59XG5cbnZhciBBUkdVTUVOVFNfVEFHID0gJ1tvYmplY3QgQXJndW1lbnRzXSc7XG52YXIgQk9PTEVBTl9UQUcgPSAnW29iamVjdCBCb29sZWFuXSc7XG52YXIgREFURV9UQUcgPSAnW29iamVjdCBEYXRlXSc7XG52YXIgTUFQX1RBRyA9ICdbb2JqZWN0IE1hcF0nO1xudmFyIE5VTUJFUl9UQUcgPSAnW29iamVjdCBOdW1iZXJdJztcbnZhciBPQkpFQ1RfVEFHID0gJ1tvYmplY3QgT2JqZWN0XSc7XG52YXIgUkVHX0VYUF9UQUcgPSAnW29iamVjdCBSZWdFeHBdJztcbnZhciBTRVRfVEFHID0gJ1tvYmplY3QgU2V0XSc7XG52YXIgU1RSSU5HX1RBRyA9ICdbb2JqZWN0IFN0cmluZ10nO1xudmFyIGlzQXJyYXkgPSBBcnJheS5pc0FycmF5O1xudmFyIGlzVHlwZWRBcnJheSA9IHR5cGVvZiBBcnJheUJ1ZmZlciA9PT0gJ2Z1bmN0aW9uJyAmJiBBcnJheUJ1ZmZlci5pc1ZpZXdcbiAgICA/IEFycmF5QnVmZmVyLmlzVmlld1xuICAgIDogbnVsbDtcbnZhciBhc3NpZ24gPSBPYmplY3QuYXNzaWduO1xudmFyIGdldFRhZyA9IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbC5iaW5kKE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcpO1xuLyoqXG4gKiBDcmVhdGUgYSBjb21wYXJhdG9yIG1ldGhvZCBiYXNlZCBvbiB0aGUgdHlwZS1zcGVjaWZpYyBlcXVhbGl0eSBjb21wYXJhdG9ycyBwYXNzZWQuXG4gKi9cbmZ1bmN0aW9uIGNyZWF0ZUVxdWFsaXR5Q29tcGFyYXRvcihfYSkge1xuICAgIHZhciBhcmVBcnJheXNFcXVhbCA9IF9hLmFyZUFycmF5c0VxdWFsLCBhcmVEYXRlc0VxdWFsID0gX2EuYXJlRGF0ZXNFcXVhbCwgYXJlTWFwc0VxdWFsID0gX2EuYXJlTWFwc0VxdWFsLCBhcmVPYmplY3RzRXF1YWwgPSBfYS5hcmVPYmplY3RzRXF1YWwsIGFyZVByaW1pdGl2ZVdyYXBwZXJzRXF1YWwgPSBfYS5hcmVQcmltaXRpdmVXcmFwcGVyc0VxdWFsLCBhcmVSZWdFeHBzRXF1YWwgPSBfYS5hcmVSZWdFeHBzRXF1YWwsIGFyZVNldHNFcXVhbCA9IF9hLmFyZVNldHNFcXVhbCwgYXJlVHlwZWRBcnJheXNFcXVhbCA9IF9hLmFyZVR5cGVkQXJyYXlzRXF1YWw7XG4gICAgLyoqXG4gICAgICogY29tcGFyZSB0aGUgdmFsdWUgb2YgdGhlIHR3byBvYmplY3RzIGFuZCByZXR1cm4gdHJ1ZSBpZiB0aGV5IGFyZSBlcXVpdmFsZW50IGluIHZhbHVlc1xuICAgICAqL1xuICAgIHJldHVybiBmdW5jdGlvbiBjb21wYXJhdG9yKGEsIGIsIHN0YXRlKSB7XG4gICAgICAgIC8vIElmIHRoZSBpdGVtcyBhcmUgc3RyaWN0bHkgZXF1YWwsIG5vIG5lZWQgdG8gZG8gYSB2YWx1ZSBjb21wYXJpc29uLlxuICAgICAgICBpZiAoYSA9PT0gYikge1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgLy8gSWYgdGhlIGl0ZW1zIGFyZSBub3Qgbm9uLW51bGxpc2ggb2JqZWN0cywgdGhlbiB0aGUgb25seSBwb3NzaWJpbGl0eVxuICAgICAgICAvLyBvZiB0aGVtIGJlaW5nIGVxdWFsIGJ1dCBub3Qgc3RyaWN0bHkgaXMgaWYgdGhleSBhcmUgYm90aCBgTmFOYC4gU2luY2VcbiAgICAgICAgLy8gYE5hTmAgaXMgdW5pcXVlbHkgbm90IGVxdWFsIHRvIGl0c2VsZiwgd2UgY2FuIHVzZSBzZWxmLWNvbXBhcmlzb24gb2ZcbiAgICAgICAgLy8gYm90aCBvYmplY3RzLCB3aGljaCBpcyBmYXN0ZXIgdGhhbiBgaXNOYU4oKWAuXG4gICAgICAgIGlmIChhID09IG51bGwgfHxcbiAgICAgICAgICAgIGIgPT0gbnVsbCB8fFxuICAgICAgICAgICAgdHlwZW9mIGEgIT09ICdvYmplY3QnIHx8XG4gICAgICAgICAgICB0eXBlb2YgYiAhPT0gJ29iamVjdCcpIHtcbiAgICAgICAgICAgIHJldHVybiBhICE9PSBhICYmIGIgIT09IGI7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGNvbnN0cnVjdG9yID0gYS5jb25zdHJ1Y3RvcjtcbiAgICAgICAgLy8gQ2hlY2tzIGFyZSBsaXN0ZWQgaW4gb3JkZXIgb2YgY29tbW9uYWxpdHkgb2YgdXNlLWNhc2U6XG4gICAgICAgIC8vICAgMS4gQ29tbW9uIGNvbXBsZXggb2JqZWN0IHR5cGVzIChwbGFpbiBvYmplY3QsIGFycmF5KVxuICAgICAgICAvLyAgIDIuIENvbW1vbiBkYXRhIHZhbHVlcyAoZGF0ZSwgcmVnZXhwKVxuICAgICAgICAvLyAgIDMuIExlc3MtY29tbW9uIGNvbXBsZXggb2JqZWN0IHR5cGVzIChtYXAsIHNldClcbiAgICAgICAgLy8gICA0LiBMZXNzLWNvbW1vbiBkYXRhIHZhbHVlcyAocHJvbWlzZSwgcHJpbWl0aXZlIHdyYXBwZXJzKVxuICAgICAgICAvLyBJbmhlcmVudGx5IHRoaXMgaXMgYm90aCBzdWJqZWN0aXZlIGFuZCBhc3N1bXB0aXZlLCBob3dldmVyXG4gICAgICAgIC8vIHdoZW4gcmV2aWV3aW5nIGNvbXBhcmFibGUgbGlicmFyaWVzIGluIHRoZSB3aWxkIHRoaXMgb3JkZXJcbiAgICAgICAgLy8gYXBwZWFycyB0byBiZSBnZW5lcmFsbHkgY29uc2lzdGVudC5cbiAgICAgICAgLy8gQ29uc3RydWN0b3JzIHNob3VsZCBtYXRjaCwgb3RoZXJ3aXNlIHRoZXJlIGlzIHBvdGVudGlhbCBmb3IgZmFsc2UgcG9zaXRpdmVzXG4gICAgICAgIC8vIGJldHdlZW4gY2xhc3MgYW5kIHN1YmNsYXNzIG9yIGN1c3RvbSBvYmplY3QgYW5kIFBPSk8uXG4gICAgICAgIGlmIChjb25zdHJ1Y3RvciAhPT0gYi5jb25zdHJ1Y3Rvcikge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIC8vIGBpc1BsYWluT2JqZWN0YCBvbmx5IGNoZWNrcyBhZ2FpbnN0IHRoZSBvYmplY3QncyBvd24gcmVhbG0uIENyb3NzLXJlYWxtXG4gICAgICAgIC8vIGNvbXBhcmlzb25zIGFyZSByYXJlLCBhbmQgd2lsbCBiZSBoYW5kbGVkIGluIHRoZSB1bHRpbWF0ZSBmYWxsYmFjaywgc29cbiAgICAgICAgLy8gd2UgY2FuIGF2b2lkIGNhcHR1cmluZyB0aGUgc3RyaW5nIHRhZy5cbiAgICAgICAgaWYgKGNvbnN0cnVjdG9yID09PSBPYmplY3QpIHtcbiAgICAgICAgICAgIHJldHVybiBhcmVPYmplY3RzRXF1YWwoYSwgYiwgc3RhdGUpO1xuICAgICAgICB9XG4gICAgICAgIC8vIGBpc0FycmF5KClgIHdvcmtzIG9uIHN1YmNsYXNzZXMgYW5kIGlzIGNyb3NzLXJlYWxtLCBzbyB3ZSBjYW4gYXZvaWQgY2FwdHVyaW5nXG4gICAgICAgIC8vIHRoZSBzdHJpbmcgdGFnIG9yIGRvaW5nIGFuIGBpbnN0YW5jZW9mYCBjaGVjay5cbiAgICAgICAgaWYgKGlzQXJyYXkoYSkpIHtcbiAgICAgICAgICAgIHJldHVybiBhcmVBcnJheXNFcXVhbChhLCBiLCBzdGF0ZSk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gYGlzVHlwZWRBcnJheSgpYCB3b3JrcyBvbiBhbGwgcG9zc2libGUgVHlwZWRBcnJheSBjbGFzc2VzLCBzbyB3ZSBjYW4gYXZvaWRcbiAgICAgICAgLy8gY2FwdHVyaW5nIHRoZSBzdHJpbmcgdGFnIG9yIGNvbXBhcmluZyBhZ2FpbnN0IGFsbCBwb3NzaWJsZSBjb25zdHJ1Y3RvcnMuXG4gICAgICAgIGlmIChpc1R5cGVkQXJyYXkgIT0gbnVsbCAmJiBpc1R5cGVkQXJyYXkoYSkpIHtcbiAgICAgICAgICAgIHJldHVybiBhcmVUeXBlZEFycmF5c0VxdWFsKGEsIGIsIHN0YXRlKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBUcnkgdG8gZmFzdC1wYXRoIGVxdWFsaXR5IGNoZWNrcyBmb3Igb3RoZXIgY29tcGxleCBvYmplY3QgdHlwZXMgaW4gdGhlXG4gICAgICAgIC8vIHNhbWUgcmVhbG0gdG8gYXZvaWQgY2FwdHVyaW5nIHRoZSBzdHJpbmcgdGFnLiBTdHJpY3QgZXF1YWxpdHkgaXMgdXNlZFxuICAgICAgICAvLyBpbnN0ZWFkIG9mIGBpbnN0YW5jZW9mYCBiZWNhdXNlIGl0IGlzIG1vcmUgcGVyZm9ybWFudCBmb3IgdGhlIGNvbW1vblxuICAgICAgICAvLyB1c2UtY2FzZS4gSWYgc29tZW9uZSBpcyBzdWJjbGFzc2luZyBhIG5hdGl2ZSBjbGFzcywgaXQgd2lsbCBiZSBoYW5kbGVkXG4gICAgICAgIC8vIHdpdGggdGhlIHN0cmluZyB0YWcgY29tcGFyaXNvbi5cbiAgICAgICAgaWYgKGNvbnN0cnVjdG9yID09PSBEYXRlKSB7XG4gICAgICAgICAgICByZXR1cm4gYXJlRGF0ZXNFcXVhbChhLCBiLCBzdGF0ZSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGNvbnN0cnVjdG9yID09PSBSZWdFeHApIHtcbiAgICAgICAgICAgIHJldHVybiBhcmVSZWdFeHBzRXF1YWwoYSwgYiwgc3RhdGUpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChjb25zdHJ1Y3RvciA9PT0gTWFwKSB7XG4gICAgICAgICAgICByZXR1cm4gYXJlTWFwc0VxdWFsKGEsIGIsIHN0YXRlKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoY29uc3RydWN0b3IgPT09IFNldCkge1xuICAgICAgICAgICAgcmV0dXJuIGFyZVNldHNFcXVhbChhLCBiLCBzdGF0ZSk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gU2luY2UgdGhpcyBpcyBhIGN1c3RvbSBvYmplY3QsIGNhcHR1cmUgdGhlIHN0cmluZyB0YWcgdG8gZGV0ZXJtaW5nIGl0cyB0eXBlLlxuICAgICAgICAvLyBUaGlzIGlzIHJlYXNvbmFibHkgcGVyZm9ybWFudCBpbiBtb2Rlcm4gZW52aXJvbm1lbnRzIGxpa2UgdjggYW5kIFNwaWRlck1vbmtleS5cbiAgICAgICAgdmFyIHRhZyA9IGdldFRhZyhhKTtcbiAgICAgICAgaWYgKHRhZyA9PT0gREFURV9UQUcpIHtcbiAgICAgICAgICAgIHJldHVybiBhcmVEYXRlc0VxdWFsKGEsIGIsIHN0YXRlKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGFnID09PSBSRUdfRVhQX1RBRykge1xuICAgICAgICAgICAgcmV0dXJuIGFyZVJlZ0V4cHNFcXVhbChhLCBiLCBzdGF0ZSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRhZyA9PT0gTUFQX1RBRykge1xuICAgICAgICAgICAgcmV0dXJuIGFyZU1hcHNFcXVhbChhLCBiLCBzdGF0ZSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRhZyA9PT0gU0VUX1RBRykge1xuICAgICAgICAgICAgcmV0dXJuIGFyZVNldHNFcXVhbChhLCBiLCBzdGF0ZSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRhZyA9PT0gT0JKRUNUX1RBRykge1xuICAgICAgICAgICAgLy8gVGhlIGV4Y2VwdGlvbiBmb3IgdmFsdWUgY29tcGFyaXNvbiBpcyBjdXN0b20gYFByb21pc2VgLWxpa2UgY2xhc3MgaW5zdGFuY2VzLiBUaGVzZSBzaG91bGRcbiAgICAgICAgICAgIC8vIGJlIHRyZWF0ZWQgdGhlIHNhbWUgYXMgc3RhbmRhcmQgYFByb21pc2VgIG9iamVjdHMsIHdoaWNoIG1lYW5zIHN0cmljdCBlcXVhbGl0eSwgYW5kIGlmXG4gICAgICAgICAgICAvLyBpdCByZWFjaGVzIHRoaXMgcG9pbnQgdGhlbiB0aGF0IHN0cmljdCBlcXVhbGl0eSBjb21wYXJpc29uIGhhcyBhbHJlYWR5IGZhaWxlZC5cbiAgICAgICAgICAgIHJldHVybiAodHlwZW9mIGEudGhlbiAhPT0gJ2Z1bmN0aW9uJyAmJlxuICAgICAgICAgICAgICAgIHR5cGVvZiBiLnRoZW4gIT09ICdmdW5jdGlvbicgJiZcbiAgICAgICAgICAgICAgICBhcmVPYmplY3RzRXF1YWwoYSwgYiwgc3RhdGUpKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBJZiBhbiBhcmd1bWVudHMgdGFnLCBpdCBzaG91bGQgYmUgdHJlYXRlZCBhcyBhIHN0YW5kYXJkIG9iamVjdC5cbiAgICAgICAgaWYgKHRhZyA9PT0gQVJHVU1FTlRTX1RBRykge1xuICAgICAgICAgICAgcmV0dXJuIGFyZU9iamVjdHNFcXVhbChhLCBiLCBzdGF0ZSk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gQXMgdGhlIHBlbnVsdGltYXRlIGZhbGxiYWNrLCBjaGVjayBpZiB0aGUgdmFsdWVzIHBhc3NlZCBhcmUgcHJpbWl0aXZlIHdyYXBwZXJzLiBUaGlzXG4gICAgICAgIC8vIGlzIHZlcnkgcmFyZSBpbiBtb2Rlcm4gSlMsIHdoaWNoIGlzIHdoeSBpdCBpcyBkZXByaW9yaXRpemVkIGNvbXBhcmVkIHRvIGFsbCBvdGhlciBvYmplY3RcbiAgICAgICAgLy8gdHlwZXMuXG4gICAgICAgIGlmICh0YWcgPT09IEJPT0xFQU5fVEFHIHx8IHRhZyA9PT0gTlVNQkVSX1RBRyB8fCB0YWcgPT09IFNUUklOR19UQUcpIHtcbiAgICAgICAgICAgIHJldHVybiBhcmVQcmltaXRpdmVXcmFwcGVyc0VxdWFsKGEsIGIsIHN0YXRlKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBJZiBub3QgbWF0Y2hpbmcgYW55IHRhZ3MgdGhhdCByZXF1aXJlIGEgc3BlY2lmaWMgdHlwZSBvZiBjb21wYXJpc29uLCB0aGVuIHdlIGhhcmQtY29kZSBmYWxzZSBiZWNhdXNlXG4gICAgICAgIC8vIHRoZSBvbmx5IHRoaW5nIHJlbWFpbmluZyBpcyBzdHJpY3QgZXF1YWxpdHksIHdoaWNoIGhhcyBhbHJlYWR5IGJlZW4gY29tcGFyZWQuIFRoaXMgaXMgZm9yIGEgZmV3IHJlYXNvbnM6XG4gICAgICAgIC8vICAgLSBDZXJ0YWluIHR5cGVzIHRoYXQgY2Fubm90IGJlIGludHJvc3BlY3RlZCAoZS5nLiwgYFdlYWtNYXBgKS4gRm9yIHRoZXNlIHR5cGVzLCB0aGlzIGlzIHRoZSBvbmx5XG4gICAgICAgIC8vICAgICBjb21wYXJpc29uIHRoYXQgY2FuIGJlIG1hZGUuXG4gICAgICAgIC8vICAgLSBGb3IgdHlwZXMgdGhhdCBjYW4gYmUgaW50cm9zcGVjdGVkLCBidXQgcmFyZWx5IGhhdmUgcmVxdWlyZW1lbnRzIHRvIGJlIGNvbXBhcmVkXG4gICAgICAgIC8vICAgICAoYEFycmF5QnVmZmVyYCwgYERhdGFWaWV3YCwgZXRjLiksIHRoZSBjb3N0IGlzIGF2b2lkZWQgdG8gcHJpb3JpdGl6ZSB0aGUgY29tbW9uXG4gICAgICAgIC8vICAgICB1c2UtY2FzZXMgKG1heSBiZSBpbmNsdWRlZCBpbiBhIGZ1dHVyZSByZWxlYXNlLCBpZiByZXF1ZXN0ZWQgZW5vdWdoKS5cbiAgICAgICAgLy8gICAtIEZvciB0eXBlcyB0aGF0IGNhbiBiZSBpbnRyb3NwZWN0ZWQgYnV0IGRvIG5vdCBoYXZlIGFuIG9iamVjdGl2ZSBkZWZpbml0aW9uIG9mIHdoYXRcbiAgICAgICAgLy8gICAgIGVxdWFsaXR5IGlzIChgRXJyb3JgLCBldGMuKSwgdGhlIHN1YmplY3RpdmUgZGVjaXNpb24gaXMgdG8gYmUgY29uc2VydmF0aXZlIGFuZCBzdHJpY3RseSBjb21wYXJlLlxuICAgICAgICAvLyBJbiBhbGwgY2FzZXMsIHRoZXNlIGRlY2lzaW9ucyBzaG91bGQgYmUgcmVldmFsdWF0ZWQgYmFzZWQgb24gY2hhbmdlcyB0byB0aGUgbGFuZ3VhZ2UgYW5kXG4gICAgICAgIC8vIGNvbW1vbiBkZXZlbG9wbWVudCBwcmFjdGljZXMuXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9O1xufVxuLyoqXG4gKiBDcmVhdGUgdGhlIGNvbmZpZ3VyYXRpb24gb2JqZWN0IHVzZWQgZm9yIGJ1aWxkaW5nIGNvbXBhcmF0b3JzLlxuICovXG5mdW5jdGlvbiBjcmVhdGVFcXVhbGl0eUNvbXBhcmF0b3JDb25maWcoX2EpIHtcbiAgICB2YXIgY2lyY3VsYXIgPSBfYS5jaXJjdWxhciwgY3JlYXRlQ3VzdG9tQ29uZmlnID0gX2EuY3JlYXRlQ3VzdG9tQ29uZmlnLCBzdHJpY3QgPSBfYS5zdHJpY3Q7XG4gICAgdmFyIGNvbmZpZyA9IHtcbiAgICAgICAgYXJlQXJyYXlzRXF1YWw6IHN0cmljdFxuICAgICAgICAgICAgPyBhcmVPYmplY3RzRXF1YWxTdHJpY3RcbiAgICAgICAgICAgIDogYXJlQXJyYXlzRXF1YWwsXG4gICAgICAgIGFyZURhdGVzRXF1YWw6IGFyZURhdGVzRXF1YWwsXG4gICAgICAgIGFyZU1hcHNFcXVhbDogc3RyaWN0XG4gICAgICAgICAgICA/IGNvbWJpbmVDb21wYXJhdG9ycyhhcmVNYXBzRXF1YWwsIGFyZU9iamVjdHNFcXVhbFN0cmljdClcbiAgICAgICAgICAgIDogYXJlTWFwc0VxdWFsLFxuICAgICAgICBhcmVPYmplY3RzRXF1YWw6IHN0cmljdFxuICAgICAgICAgICAgPyBhcmVPYmplY3RzRXF1YWxTdHJpY3RcbiAgICAgICAgICAgIDogYXJlT2JqZWN0c0VxdWFsLFxuICAgICAgICBhcmVQcmltaXRpdmVXcmFwcGVyc0VxdWFsOiBhcmVQcmltaXRpdmVXcmFwcGVyc0VxdWFsLFxuICAgICAgICBhcmVSZWdFeHBzRXF1YWw6IGFyZVJlZ0V4cHNFcXVhbCxcbiAgICAgICAgYXJlU2V0c0VxdWFsOiBzdHJpY3RcbiAgICAgICAgICAgID8gY29tYmluZUNvbXBhcmF0b3JzKGFyZVNldHNFcXVhbCwgYXJlT2JqZWN0c0VxdWFsU3RyaWN0KVxuICAgICAgICAgICAgOiBhcmVTZXRzRXF1YWwsXG4gICAgICAgIGFyZVR5cGVkQXJyYXlzRXF1YWw6IHN0cmljdFxuICAgICAgICAgICAgPyBhcmVPYmplY3RzRXF1YWxTdHJpY3RcbiAgICAgICAgICAgIDogYXJlVHlwZWRBcnJheXNFcXVhbCxcbiAgICB9O1xuICAgIGlmIChjcmVhdGVDdXN0b21Db25maWcpIHtcbiAgICAgICAgY29uZmlnID0gYXNzaWduKHt9LCBjb25maWcsIGNyZWF0ZUN1c3RvbUNvbmZpZyhjb25maWcpKTtcbiAgICB9XG4gICAgaWYgKGNpcmN1bGFyKSB7XG4gICAgICAgIHZhciBhcmVBcnJheXNFcXVhbCQxID0gY3JlYXRlSXNDaXJjdWxhcihjb25maWcuYXJlQXJyYXlzRXF1YWwpO1xuICAgICAgICB2YXIgYXJlTWFwc0VxdWFsJDEgPSBjcmVhdGVJc0NpcmN1bGFyKGNvbmZpZy5hcmVNYXBzRXF1YWwpO1xuICAgICAgICB2YXIgYXJlT2JqZWN0c0VxdWFsJDEgPSBjcmVhdGVJc0NpcmN1bGFyKGNvbmZpZy5hcmVPYmplY3RzRXF1YWwpO1xuICAgICAgICB2YXIgYXJlU2V0c0VxdWFsJDEgPSBjcmVhdGVJc0NpcmN1bGFyKGNvbmZpZy5hcmVTZXRzRXF1YWwpO1xuICAgICAgICBjb25maWcgPSBhc3NpZ24oe30sIGNvbmZpZywge1xuICAgICAgICAgICAgYXJlQXJyYXlzRXF1YWw6IGFyZUFycmF5c0VxdWFsJDEsXG4gICAgICAgICAgICBhcmVNYXBzRXF1YWw6IGFyZU1hcHNFcXVhbCQxLFxuICAgICAgICAgICAgYXJlT2JqZWN0c0VxdWFsOiBhcmVPYmplY3RzRXF1YWwkMSxcbiAgICAgICAgICAgIGFyZVNldHNFcXVhbDogYXJlU2V0c0VxdWFsJDEsXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICByZXR1cm4gY29uZmlnO1xufVxuLyoqXG4gKiBEZWZhdWx0IGVxdWFsaXR5IGNvbXBhcmF0b3IgcGFzcy10aHJvdWdoLCB1c2VkIGFzIHRoZSBzdGFuZGFyZCBgaXNFcXVhbGAgY3JlYXRvciBmb3JcbiAqIHVzZSBpbnNpZGUgdGhlIGJ1aWx0IGNvbXBhcmF0b3IuXG4gKi9cbmZ1bmN0aW9uIGNyZWF0ZUludGVybmFsRXF1YWxpdHlDb21wYXJhdG9yKGNvbXBhcmUpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24gKGEsIGIsIF9pbmRleE9yS2V5QSwgX2luZGV4T3JLZXlCLCBfcGFyZW50QSwgX3BhcmVudEIsIHN0YXRlKSB7XG4gICAgICAgIHJldHVybiBjb21wYXJlKGEsIGIsIHN0YXRlKTtcbiAgICB9O1xufVxuLyoqXG4gKiBDcmVhdGUgdGhlIGBpc0VxdWFsYCBmdW5jdGlvbiB1c2VkIGJ5IHRoZSBjb25zdW1pbmcgYXBwbGljYXRpb24uXG4gKi9cbmZ1bmN0aW9uIGNyZWF0ZUlzRXF1YWwoX2EpIHtcbiAgICB2YXIgY2lyY3VsYXIgPSBfYS5jaXJjdWxhciwgY29tcGFyYXRvciA9IF9hLmNvbXBhcmF0b3IsIGNyZWF0ZVN0YXRlID0gX2EuY3JlYXRlU3RhdGUsIGVxdWFscyA9IF9hLmVxdWFscywgc3RyaWN0ID0gX2Euc3RyaWN0O1xuICAgIGlmIChjcmVhdGVTdGF0ZSkge1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24gaXNFcXVhbChhLCBiKSB7XG4gICAgICAgICAgICB2YXIgX2EgPSBjcmVhdGVTdGF0ZSgpLCBfYiA9IF9hLmNhY2hlLCBjYWNoZSA9IF9iID09PSB2b2lkIDAgPyBjaXJjdWxhciA/IG5ldyBXZWFrTWFwKCkgOiB1bmRlZmluZWQgOiBfYiwgbWV0YSA9IF9hLm1ldGE7XG4gICAgICAgICAgICByZXR1cm4gY29tcGFyYXRvcihhLCBiLCB7XG4gICAgICAgICAgICAgICAgY2FjaGU6IGNhY2hlLFxuICAgICAgICAgICAgICAgIGVxdWFsczogZXF1YWxzLFxuICAgICAgICAgICAgICAgIG1ldGE6IG1ldGEsXG4gICAgICAgICAgICAgICAgc3RyaWN0OiBzdHJpY3QsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfTtcbiAgICB9XG4gICAgaWYgKGNpcmN1bGFyKSB7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbiBpc0VxdWFsKGEsIGIpIHtcbiAgICAgICAgICAgIHJldHVybiBjb21wYXJhdG9yKGEsIGIsIHtcbiAgICAgICAgICAgICAgICBjYWNoZTogbmV3IFdlYWtNYXAoKSxcbiAgICAgICAgICAgICAgICBlcXVhbHM6IGVxdWFscyxcbiAgICAgICAgICAgICAgICBtZXRhOiB1bmRlZmluZWQsXG4gICAgICAgICAgICAgICAgc3RyaWN0OiBzdHJpY3QsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfTtcbiAgICB9XG4gICAgdmFyIHN0YXRlID0ge1xuICAgICAgICBjYWNoZTogdW5kZWZpbmVkLFxuICAgICAgICBlcXVhbHM6IGVxdWFscyxcbiAgICAgICAgbWV0YTogdW5kZWZpbmVkLFxuICAgICAgICBzdHJpY3Q6IHN0cmljdCxcbiAgICB9O1xuICAgIHJldHVybiBmdW5jdGlvbiBpc0VxdWFsKGEsIGIpIHtcbiAgICAgICAgcmV0dXJuIGNvbXBhcmF0b3IoYSwgYiwgc3RhdGUpO1xuICAgIH07XG59XG5cbi8qKlxuICogV2hldGhlciB0aGUgaXRlbXMgcGFzc2VkIGFyZSBkZWVwbHktZXF1YWwgaW4gdmFsdWUuXG4gKi9cbnZhciBkZWVwRXF1YWwgPSBjcmVhdGVDdXN0b21FcXVhbCgpO1xuLyoqXG4gKiBXaGV0aGVyIHRoZSBpdGVtcyBwYXNzZWQgYXJlIGRlZXBseS1lcXVhbCBpbiB2YWx1ZSBiYXNlZCBvbiBzdHJpY3QgY29tcGFyaXNvbi5cbiAqL1xudmFyIHN0cmljdERlZXBFcXVhbCA9IGNyZWF0ZUN1c3RvbUVxdWFsKHsgc3RyaWN0OiB0cnVlIH0pO1xuLyoqXG4gKiBXaGV0aGVyIHRoZSBpdGVtcyBwYXNzZWQgYXJlIGRlZXBseS1lcXVhbCBpbiB2YWx1ZSwgaW5jbHVkaW5nIGNpcmN1bGFyIHJlZmVyZW5jZXMuXG4gKi9cbnZhciBjaXJjdWxhckRlZXBFcXVhbCA9IGNyZWF0ZUN1c3RvbUVxdWFsKHsgY2lyY3VsYXI6IHRydWUgfSk7XG4vKipcbiAqIFdoZXRoZXIgdGhlIGl0ZW1zIHBhc3NlZCBhcmUgZGVlcGx5LWVxdWFsIGluIHZhbHVlLCBpbmNsdWRpbmcgY2lyY3VsYXIgcmVmZXJlbmNlcyxcbiAqIGJhc2VkIG9uIHN0cmljdCBjb21wYXJpc29uLlxuICovXG52YXIgc3RyaWN0Q2lyY3VsYXJEZWVwRXF1YWwgPSBjcmVhdGVDdXN0b21FcXVhbCh7XG4gICAgY2lyY3VsYXI6IHRydWUsXG4gICAgc3RyaWN0OiB0cnVlLFxufSk7XG4vKipcbiAqIFdoZXRoZXIgdGhlIGl0ZW1zIHBhc3NlZCBhcmUgc2hhbGxvd2x5LWVxdWFsIGluIHZhbHVlLlxuICovXG52YXIgc2hhbGxvd0VxdWFsID0gY3JlYXRlQ3VzdG9tRXF1YWwoe1xuICAgIGNyZWF0ZUludGVybmFsQ29tcGFyYXRvcjogZnVuY3Rpb24gKCkgeyByZXR1cm4gc2FtZVZhbHVlWmVyb0VxdWFsOyB9LFxufSk7XG4vKipcbiAqIFdoZXRoZXIgdGhlIGl0ZW1zIHBhc3NlZCBhcmUgc2hhbGxvd2x5LWVxdWFsIGluIHZhbHVlIGJhc2VkIG9uIHN0cmljdCBjb21wYXJpc29uXG4gKi9cbnZhciBzdHJpY3RTaGFsbG93RXF1YWwgPSBjcmVhdGVDdXN0b21FcXVhbCh7XG4gICAgc3RyaWN0OiB0cnVlLFxuICAgIGNyZWF0ZUludGVybmFsQ29tcGFyYXRvcjogZnVuY3Rpb24gKCkgeyByZXR1cm4gc2FtZVZhbHVlWmVyb0VxdWFsOyB9LFxufSk7XG4vKipcbiAqIFdoZXRoZXIgdGhlIGl0ZW1zIHBhc3NlZCBhcmUgc2hhbGxvd2x5LWVxdWFsIGluIHZhbHVlLCBpbmNsdWRpbmcgY2lyY3VsYXIgcmVmZXJlbmNlcy5cbiAqL1xudmFyIGNpcmN1bGFyU2hhbGxvd0VxdWFsID0gY3JlYXRlQ3VzdG9tRXF1YWwoe1xuICAgIGNpcmN1bGFyOiB0cnVlLFxuICAgIGNyZWF0ZUludGVybmFsQ29tcGFyYXRvcjogZnVuY3Rpb24gKCkgeyByZXR1cm4gc2FtZVZhbHVlWmVyb0VxdWFsOyB9LFxufSk7XG4vKipcbiAqIFdoZXRoZXIgdGhlIGl0ZW1zIHBhc3NlZCBhcmUgc2hhbGxvd2x5LWVxdWFsIGluIHZhbHVlLCBpbmNsdWRpbmcgY2lyY3VsYXIgcmVmZXJlbmNlcyxcbiAqIGJhc2VkIG9uIHN0cmljdCBjb21wYXJpc29uLlxuICovXG52YXIgc3RyaWN0Q2lyY3VsYXJTaGFsbG93RXF1YWwgPSBjcmVhdGVDdXN0b21FcXVhbCh7XG4gICAgY2lyY3VsYXI6IHRydWUsXG4gICAgY3JlYXRlSW50ZXJuYWxDb21wYXJhdG9yOiBmdW5jdGlvbiAoKSB7IHJldHVybiBzYW1lVmFsdWVaZXJvRXF1YWw7IH0sXG4gICAgc3RyaWN0OiB0cnVlLFxufSk7XG4vKipcbiAqIENyZWF0ZSBhIGN1c3RvbSBlcXVhbGl0eSBjb21wYXJpc29uIG1ldGhvZC5cbiAqXG4gKiBUaGlzIGNhbiBiZSBkb25lIHRvIGNyZWF0ZSB2ZXJ5IHRhcmdldGVkIGNvbXBhcmlzb25zIGluIGV4dHJlbWUgaG90LXBhdGggc2NlbmFyaW9zXG4gKiB3aGVyZSB0aGUgc3RhbmRhcmQgbWV0aG9kcyBhcmUgbm90IHBlcmZvcm1hbnQgZW5vdWdoLCBidXQgY2FuIGFsc28gYmUgdXNlZCB0byBwcm92aWRlXG4gKiBzdXBwb3J0IGZvciBsZWdhY3kgZW52aXJvbm1lbnRzIHRoYXQgZG8gbm90IHN1cHBvcnQgZXhwZWN0ZWQgZmVhdHVyZXMgbGlrZVxuICogYFJlZ0V4cC5wcm90b3R5cGUuZmxhZ3NgIG91dCBvZiB0aGUgYm94LlxuICovXG5mdW5jdGlvbiBjcmVhdGVDdXN0b21FcXVhbChvcHRpb25zKSB7XG4gICAgaWYgKG9wdGlvbnMgPT09IHZvaWQgMCkgeyBvcHRpb25zID0ge307IH1cbiAgICB2YXIgX2EgPSBvcHRpb25zLmNpcmN1bGFyLCBjaXJjdWxhciA9IF9hID09PSB2b2lkIDAgPyBmYWxzZSA6IF9hLCBjcmVhdGVDdXN0b21JbnRlcm5hbENvbXBhcmF0b3IgPSBvcHRpb25zLmNyZWF0ZUludGVybmFsQ29tcGFyYXRvciwgY3JlYXRlU3RhdGUgPSBvcHRpb25zLmNyZWF0ZVN0YXRlLCBfYiA9IG9wdGlvbnMuc3RyaWN0LCBzdHJpY3QgPSBfYiA9PT0gdm9pZCAwID8gZmFsc2UgOiBfYjtcbiAgICB2YXIgY29uZmlnID0gY3JlYXRlRXF1YWxpdHlDb21wYXJhdG9yQ29uZmlnKG9wdGlvbnMpO1xuICAgIHZhciBjb21wYXJhdG9yID0gY3JlYXRlRXF1YWxpdHlDb21wYXJhdG9yKGNvbmZpZyk7XG4gICAgdmFyIGVxdWFscyA9IGNyZWF0ZUN1c3RvbUludGVybmFsQ29tcGFyYXRvclxuICAgICAgICA/IGNyZWF0ZUN1c3RvbUludGVybmFsQ29tcGFyYXRvcihjb21wYXJhdG9yKVxuICAgICAgICA6IGNyZWF0ZUludGVybmFsRXF1YWxpdHlDb21wYXJhdG9yKGNvbXBhcmF0b3IpO1xuICAgIHJldHVybiBjcmVhdGVJc0VxdWFsKHsgY2lyY3VsYXI6IGNpcmN1bGFyLCBjb21wYXJhdG9yOiBjb21wYXJhdG9yLCBjcmVhdGVTdGF0ZTogY3JlYXRlU3RhdGUsIGVxdWFsczogZXF1YWxzLCBzdHJpY3Q6IHN0cmljdCB9KTtcbn1cblxuZXhwb3J0IHsgY2lyY3VsYXJEZWVwRXF1YWwsIGNpcmN1bGFyU2hhbGxvd0VxdWFsLCBjcmVhdGVDdXN0b21FcXVhbCwgZGVlcEVxdWFsLCBzYW1lVmFsdWVaZXJvRXF1YWwsIHNoYWxsb3dFcXVhbCwgc3RyaWN0Q2lyY3VsYXJEZWVwRXF1YWwsIHN0cmljdENpcmN1bGFyU2hhbGxvd0VxdWFsLCBzdHJpY3REZWVwRXF1YWwsIHN0cmljdFNoYWxsb3dFcXVhbCB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXgubWpzLm1hcFxuIl0sIm5hbWVzIjpbImdldE93blByb3BlcnR5TmFtZXMiLCJPYmplY3QiLCJnZXRPd25Qcm9wZXJ0eVN5bWJvbHMiLCJoYXNPd25Qcm9wZXJ0eSIsInByb3RvdHlwZSIsImNvbWJpbmVDb21wYXJhdG9ycyIsImNvbXBhcmF0b3JBIiwiY29tcGFyYXRvckIiLCJpc0VxdWFsIiwiYSIsImIiLCJzdGF0ZSIsImNyZWF0ZUlzQ2lyY3VsYXIiLCJhcmVJdGVtc0VxdWFsIiwiaXNDaXJjdWxhciIsImNhY2hlIiwiY2FjaGVkQSIsImdldCIsImNhY2hlZEIiLCJzZXQiLCJyZXN1bHQiLCJkZWxldGUiLCJnZXRTdHJpY3RQcm9wZXJ0aWVzIiwib2JqZWN0IiwiY29uY2F0IiwiaGFzT3duIiwicHJvcGVydHkiLCJjYWxsIiwic2FtZVZhbHVlWmVyb0VxdWFsIiwiT1dORVIiLCJnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IiLCJrZXlzIiwiYXJlQXJyYXlzRXF1YWwiLCJpbmRleCIsImxlbmd0aCIsImVxdWFscyIsImFyZURhdGVzRXF1YWwiLCJnZXRUaW1lIiwiYXJlTWFwc0VxdWFsIiwic2l6ZSIsIm1hdGNoZWRJbmRpY2VzIiwiYUl0ZXJhYmxlIiwiZW50cmllcyIsImFSZXN1bHQiLCJiUmVzdWx0IiwibmV4dCIsImRvbmUiLCJiSXRlcmFibGUiLCJoYXNNYXRjaCIsIm1hdGNoSW5kZXgiLCJfYSIsInZhbHVlIiwiYUtleSIsImFWYWx1ZSIsIl9iIiwiYktleSIsImJWYWx1ZSIsImFyZU9iamVjdHNFcXVhbCIsInByb3BlcnRpZXMiLCIkJHR5cGVvZiIsImFyZU9iamVjdHNFcXVhbFN0cmljdCIsImRlc2NyaXB0b3JBIiwiZGVzY3JpcHRvckIiLCJjb25maWd1cmFibGUiLCJlbnVtZXJhYmxlIiwid3JpdGFibGUiLCJhcmVQcmltaXRpdmVXcmFwcGVyc0VxdWFsIiwidmFsdWVPZiIsImFyZVJlZ0V4cHNFcXVhbCIsInNvdXJjZSIsImZsYWdzIiwiYXJlU2V0c0VxdWFsIiwidmFsdWVzIiwiYXJlVHlwZWRBcnJheXNFcXVhbCIsIkFSR1VNRU5UU19UQUciLCJCT09MRUFOX1RBRyIsIkRBVEVfVEFHIiwiTUFQX1RBRyIsIk5VTUJFUl9UQUciLCJPQkpFQ1RfVEFHIiwiUkVHX0VYUF9UQUciLCJTRVRfVEFHIiwiU1RSSU5HX1RBRyIsImlzQXJyYXkiLCJBcnJheSIsImlzVHlwZWRBcnJheSIsIkFycmF5QnVmZmVyIiwiaXNWaWV3IiwiYXNzaWduIiwiZ2V0VGFnIiwidG9TdHJpbmciLCJiaW5kIiwiY3JlYXRlRXF1YWxpdHlDb21wYXJhdG9yIiwiY29tcGFyYXRvciIsImNvbnN0cnVjdG9yIiwiRGF0ZSIsIlJlZ0V4cCIsIk1hcCIsIlNldCIsInRhZyIsInRoZW4iLCJjcmVhdGVFcXVhbGl0eUNvbXBhcmF0b3JDb25maWciLCJjaXJjdWxhciIsImNyZWF0ZUN1c3RvbUNvbmZpZyIsInN0cmljdCIsImNvbmZpZyIsImFyZUFycmF5c0VxdWFsJDEiLCJhcmVNYXBzRXF1YWwkMSIsImFyZU9iamVjdHNFcXVhbCQxIiwiYXJlU2V0c0VxdWFsJDEiLCJjcmVhdGVJbnRlcm5hbEVxdWFsaXR5Q29tcGFyYXRvciIsImNvbXBhcmUiLCJfaW5kZXhPcktleUEiLCJfaW5kZXhPcktleUIiLCJfcGFyZW50QSIsIl9wYXJlbnRCIiwiY3JlYXRlSXNFcXVhbCIsImNyZWF0ZVN0YXRlIiwiV2Vha01hcCIsInVuZGVmaW5lZCIsIm1ldGEiLCJkZWVwRXF1YWwiLCJjcmVhdGVDdXN0b21FcXVhbCIsInN0cmljdERlZXBFcXVhbCIsImNpcmN1bGFyRGVlcEVxdWFsIiwic3RyaWN0Q2lyY3VsYXJEZWVwRXF1YWwiLCJzaGFsbG93RXF1YWwiLCJjcmVhdGVJbnRlcm5hbENvbXBhcmF0b3IiLCJzdHJpY3RTaGFsbG93RXF1YWwiLCJjaXJjdWxhclNoYWxsb3dFcXVhbCIsInN0cmljdENpcmN1bGFyU2hhbGxvd0VxdWFsIiwib3B0aW9ucyIsImNyZWF0ZUN1c3RvbUludGVybmFsQ29tcGFyYXRvciJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/fast-equals/dist/esm/index.mjs\n");

/***/ })

};
;