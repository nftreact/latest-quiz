/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/react-loading";
exports.ids = ["vendor-chunks/react-loading"];
exports.modules = {

/***/ "(ssr)/./node_modules/react-loading/dist/react-loading.js":
/*!**********************************************************!*\
  !*** ./node_modules/react-loading/dist/react-loading.js ***!
  \**********************************************************/
/***/ (function(module) {

eval("(function webpackUniversalModuleDefinition(root, factory) {\n    if (true) module.exports = factory();\n    else {}\n})(typeof self !== \"undefined\" ? self : this, function() {\n    return /******/ function(modules) {\n        /******/ // The module cache\n        /******/ var installedModules = {};\n        /******/ /******/ // The require function\n        /******/ function __nested_webpack_require_592__(moduleId) {\n            /******/ /******/ // Check if module is in cache\n            /******/ if (installedModules[moduleId]) {\n                /******/ return installedModules[moduleId].exports;\n            /******/ }\n            /******/ // Create a new module (and put it into the cache)\n            /******/ var module1 = installedModules[moduleId] = {\n                /******/ i: moduleId,\n                /******/ l: false,\n                /******/ exports: {}\n            };\n            /******/ /******/ // Execute the module function\n            /******/ modules[moduleId].call(module1.exports, module1, module1.exports, __nested_webpack_require_592__);\n            /******/ /******/ // Flag the module as loaded\n            /******/ module1.l = true;\n            /******/ /******/ // Return the exports of the module\n            /******/ return module1.exports;\n        /******/ }\n        /******/ /******/ /******/ // expose the modules object (__webpack_modules__)\n        /******/ __nested_webpack_require_592__.m = modules;\n        /******/ /******/ // expose the module cache\n        /******/ __nested_webpack_require_592__.c = installedModules;\n        /******/ /******/ // define getter function for harmony exports\n        /******/ __nested_webpack_require_592__.d = function(exports1, name, getter) {\n            /******/ if (!__nested_webpack_require_592__.o(exports1, name)) {\n                /******/ Object.defineProperty(exports1, name, {\n                    /******/ configurable: false,\n                    /******/ enumerable: true,\n                    /******/ get: getter\n                });\n            /******/ }\n        /******/ };\n        /******/ /******/ // getDefaultExport function for compatibility with non-harmony modules\n        /******/ __nested_webpack_require_592__.n = function(module1) {\n            /******/ var getter = module1 && module1.__esModule ? /******/ function getDefault() {\n                return module1[\"default\"];\n            } : /******/ function getModuleExports() {\n                return module1;\n            };\n            /******/ __nested_webpack_require_592__.d(getter, \"a\", getter);\n            /******/ return getter;\n        /******/ };\n        /******/ /******/ // Object.prototype.hasOwnProperty.call\n        /******/ __nested_webpack_require_592__.o = function(object, property) {\n            return Object.prototype.hasOwnProperty.call(object, property);\n        };\n        /******/ /******/ // __webpack_public_path__\n        /******/ __nested_webpack_require_592__.p = \"/\";\n        /******/ /******/ // Load entry module and return exports\n        /******/ return __nested_webpack_require_592__(__nested_webpack_require_592__.s = 7);\n    /******/ }([\n        /* 0 */ /***/ function(module1, exports1, __webpack_require__) {\n            \"use strict\";\n            /**\n * Copyright (c) 2013-present, Facebook, Inc.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */ /**\n * Use invariant() to assert state which your program assumes to be true.\n *\n * Provide sprintf-style format (only %s is supported) and arguments\n * to provide information about what broke and what you were\n * expecting.\n *\n * The invariant message will be stripped in production, but the invariant\n * will remain to ensure logic does not differ in production.\n */ var validateFormat = function validateFormat(format) {};\n            if (true) {\n                validateFormat = function validateFormat(format) {\n                    if (format === undefined) {\n                        throw new Error(\"invariant requires an error message argument\");\n                    }\n                };\n            }\n            function invariant(condition, format, a, b, c, d, e, f) {\n                validateFormat(format);\n                if (!condition) {\n                    var error;\n                    if (format === undefined) {\n                        error = new Error(\"Minified exception occurred; use the non-minified dev environment \" + \"for the full error message and additional helpful warnings.\");\n                    } else {\n                        var args = [\n                            a,\n                            b,\n                            c,\n                            d,\n                            e,\n                            f\n                        ];\n                        var argIndex = 0;\n                        error = new Error(format.replace(/%s/g, function() {\n                            return args[argIndex++];\n                        }));\n                        error.name = \"Invariant Violation\";\n                    }\n                    error.framesToPop = 1; // we don't care about invariant's own frame\n                    throw error;\n                }\n            }\n            module1.exports = invariant;\n        /***/ },\n        /* 1 */ /***/ function(module1, exports1, __webpack_require__) {\n            \"use strict\";\n            /**\n * Copyright (c) 2013-present, Facebook, Inc.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * \n */ function makeEmptyFunction(arg) {\n                return function() {\n                    return arg;\n                };\n            }\n            /**\n * This function accepts and discards inputs; it has no side effects. This is\n * primarily useful idiomatically for overridable function endpoints which\n * always need to be callable, since JS lacks a null-call idiom ala Cocoa.\n */ var emptyFunction = function emptyFunction() {};\n            emptyFunction.thatReturns = makeEmptyFunction;\n            emptyFunction.thatReturnsFalse = makeEmptyFunction(false);\n            emptyFunction.thatReturnsTrue = makeEmptyFunction(true);\n            emptyFunction.thatReturnsNull = makeEmptyFunction(null);\n            emptyFunction.thatReturnsThis = function() {\n                return this;\n            };\n            emptyFunction.thatReturnsArgument = function(arg) {\n                return arg;\n            };\n            module1.exports = emptyFunction;\n        /***/ },\n        /* 2 */ /***/ function(module1, exports1, __webpack_require__) {\n            \"use strict\";\n            /*\nobject-assign\n(c) Sindre Sorhus\n@license MIT\n*/ /* eslint-disable no-unused-vars */ var getOwnPropertySymbols = Object.getOwnPropertySymbols;\n            var hasOwnProperty = Object.prototype.hasOwnProperty;\n            var propIsEnumerable = Object.prototype.propertyIsEnumerable;\n            function toObject(val) {\n                if (val === null || val === undefined) {\n                    throw new TypeError(\"Object.assign cannot be called with null or undefined\");\n                }\n                return Object(val);\n            }\n            function shouldUseNative() {\n                try {\n                    if (!Object.assign) {\n                        return false;\n                    }\n                    // Detect buggy property enumeration order in older V8 versions.\n                    // https://bugs.chromium.org/p/v8/issues/detail?id=4118\n                    var test1 = new String(\"abc\"); // eslint-disable-line no-new-wrappers\n                    test1[5] = \"de\";\n                    if (Object.getOwnPropertyNames(test1)[0] === \"5\") {\n                        return false;\n                    }\n                    // https://bugs.chromium.org/p/v8/issues/detail?id=3056\n                    var test2 = {};\n                    for(var i = 0; i < 10; i++){\n                        test2[\"_\" + String.fromCharCode(i)] = i;\n                    }\n                    var order2 = Object.getOwnPropertyNames(test2).map(function(n) {\n                        return test2[n];\n                    });\n                    if (order2.join(\"\") !== \"0123456789\") {\n                        return false;\n                    }\n                    // https://bugs.chromium.org/p/v8/issues/detail?id=3056\n                    var test3 = {};\n                    \"abcdefghijklmnopqrst\".split(\"\").forEach(function(letter) {\n                        test3[letter] = letter;\n                    });\n                    if (Object.keys(Object.assign({}, test3)).join(\"\") !== \"abcdefghijklmnopqrst\") {\n                        return false;\n                    }\n                    return true;\n                } catch (err) {\n                    // We don't expect any of the above to throw, but better to be safe.\n                    return false;\n                }\n            }\n            module1.exports = shouldUseNative() ? Object.assign : function(target, source) {\n                var from;\n                var to = toObject(target);\n                var symbols;\n                for(var s = 1; s < arguments.length; s++){\n                    from = Object(arguments[s]);\n                    for(var key in from){\n                        if (hasOwnProperty.call(from, key)) {\n                            to[key] = from[key];\n                        }\n                    }\n                    if (getOwnPropertySymbols) {\n                        symbols = getOwnPropertySymbols(from);\n                        for(var i = 0; i < symbols.length; i++){\n                            if (propIsEnumerable.call(from, symbols[i])) {\n                                to[symbols[i]] = from[symbols[i]];\n                            }\n                        }\n                    }\n                }\n                return to;\n            };\n        /***/ },\n        /* 3 */ /***/ function(module1, exports1, __nested_webpack_require_10133__) {\n            \"use strict\";\n            /**\n * Copyright (c) 2014-present, Facebook, Inc.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */ var emptyFunction = __nested_webpack_require_10133__(1);\n            /**\n * Similar to invariant but only logs a warning if the condition is not met.\n * This can be used to log issues in development environments in critical\n * paths. Removing the logging code for production environments will keep the\n * same logic and follow the same code paths.\n */ var warning = emptyFunction;\n            if (true) {\n                var printWarning = function printWarning(format) {\n                    for(var _len = arguments.length, args = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++){\n                        args[_key - 1] = arguments[_key];\n                    }\n                    var argIndex = 0;\n                    var message = \"Warning: \" + format.replace(/%s/g, function() {\n                        return args[argIndex++];\n                    });\n                    if (typeof console !== \"undefined\") {\n                        console.error(message);\n                    }\n                    try {\n                        // --- Welcome to debugging React ---\n                        // This error was thrown as a convenience so that you can use this stack\n                        // to find the callsite that caused this warning to fire.\n                        throw new Error(message);\n                    } catch (x) {}\n                };\n                warning = function warning(condition, format) {\n                    if (format === undefined) {\n                        throw new Error(\"`warning(condition, format, ...args)` requires a warning \" + \"message argument\");\n                    }\n                    if (format.indexOf(\"Failed Composite propType: \") === 0) {\n                        return; // Ignore CompositeComponent proptype check.\n                    }\n                    if (!condition) {\n                        for(var _len2 = arguments.length, args = Array(_len2 > 2 ? _len2 - 2 : 0), _key2 = 2; _key2 < _len2; _key2++){\n                            args[_key2 - 2] = arguments[_key2];\n                        }\n                        printWarning.apply(undefined, [\n                            format\n                        ].concat(args));\n                    }\n                };\n            }\n            module1.exports = warning;\n        /***/ },\n        /* 4 */ /***/ function(module1, exports1, __webpack_require__) {\n            \"use strict\";\n            /**\n * Copyright (c) 2013-present, Facebook, Inc.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */ var ReactPropTypesSecret = \"SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED\";\n            module1.exports = ReactPropTypesSecret;\n        /***/ },\n        /* 5 */ /***/ function(module1, exports1, __webpack_require__) {\n            \"use strict\";\n            /**\n * Copyright (c) 2013-present, Facebook, Inc.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */ var emptyObject = {};\n            if (true) {\n                Object.freeze(emptyObject);\n            }\n            module1.exports = emptyObject;\n        /***/ },\n        /* 6 */ /***/ function(module1, exports1, __nested_webpack_require_13678__) {\n            \"use strict\";\n            /**\n * Copyright (c) 2013-present, Facebook, Inc.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */ if (true) {\n                var invariant = __nested_webpack_require_13678__(0);\n                var warning = __nested_webpack_require_13678__(3);\n                var ReactPropTypesSecret = __nested_webpack_require_13678__(4);\n                var loggedTypeFailures = {};\n            }\n            /**\n * Assert that the values match with the type specs.\n * Error messages are memorized and will only be shown once.\n *\n * @param {object} typeSpecs Map of name to a ReactPropType\n * @param {object} values Runtime values that need to be type-checked\n * @param {string} location e.g. \"prop\", \"context\", \"child context\"\n * @param {string} componentName Name of the component for error messages.\n * @param {?Function} getStack Returns the component stack.\n * @private\n */ function checkPropTypes(typeSpecs, values, location, componentName, getStack) {\n                if (true) {\n                    for(var typeSpecName in typeSpecs){\n                        if (typeSpecs.hasOwnProperty(typeSpecName)) {\n                            var error;\n                            // Prop type validation may throw. In case they do, we don't want to\n                            // fail the render phase where it didn't fail before. So we log it.\n                            // After these have been cleaned up, we'll let them throw.\n                            try {\n                                // This is intentionally an invariant that gets caught. It's the same\n                                // behavior as without this statement except with a better message.\n                                invariant(typeof typeSpecs[typeSpecName] === \"function\", \"%s: %s type `%s` is invalid; it must be a function, usually from \" + \"the `prop-types` package, but received `%s`.\", componentName || \"React class\", location, typeSpecName, typeof typeSpecs[typeSpecName]);\n                                error = typeSpecs[typeSpecName](values, typeSpecName, componentName, location, null, ReactPropTypesSecret);\n                            } catch (ex) {\n                                error = ex;\n                            }\n                            warning(!error || error instanceof Error, \"%s: type specification of %s `%s` is invalid; the type checker \" + \"function must return `null` or an `Error` but returned a %s. \" + \"You may have forgotten to pass an argument to the type checker \" + \"creator (arrayOf, instanceOf, objectOf, oneOf, oneOfType, and \" + \"shape all require an argument).\", componentName || \"React class\", location, typeSpecName, typeof error);\n                            if (error instanceof Error && !(error.message in loggedTypeFailures)) {\n                                // Only monitor this failure once because there tends to be a lot of the\n                                // same error.\n                                loggedTypeFailures[error.message] = true;\n                                var stack = getStack ? getStack() : \"\";\n                                warning(false, \"Failed %s type: %s%s\", location, error.message, stack != null ? stack : \"\");\n                            }\n                        }\n                    }\n                }\n            }\n            module1.exports = checkPropTypes;\n        /***/ },\n        /* 7 */ /***/ function(module1, exports1, __nested_webpack_require_17237__) {\n            \"use strict\";\n            Object.defineProperty(exports1, \"__esModule\", {\n                value: true\n            });\n            var _extends = Object.assign || function(target) {\n                for(var i = 1; i < arguments.length; i++){\n                    var source = arguments[i];\n                    for(var key in source){\n                        if (Object.prototype.hasOwnProperty.call(source, key)) {\n                            target[key] = source[key];\n                        }\n                    }\n                }\n                return target;\n            };\n            var _createClass = function() {\n                function defineProperties(target, props) {\n                    for(var i = 0; i < props.length; i++){\n                        var descriptor = props[i];\n                        descriptor.enumerable = descriptor.enumerable || false;\n                        descriptor.configurable = true;\n                        if (\"value\" in descriptor) descriptor.writable = true;\n                        Object.defineProperty(target, descriptor.key, descriptor);\n                    }\n                }\n                return function(Constructor, protoProps, staticProps) {\n                    if (protoProps) defineProperties(Constructor.prototype, protoProps);\n                    if (staticProps) defineProperties(Constructor, staticProps);\n                    return Constructor;\n                };\n            }();\n            var _react = __nested_webpack_require_17237__(8);\n            var _react2 = _interopRequireDefault(_react);\n            var _propTypes = __nested_webpack_require_17237__(11);\n            var _propTypes2 = _interopRequireDefault(_propTypes);\n            var _svg = __nested_webpack_require_17237__(14);\n            var svgSources = _interopRequireWildcard(_svg);\n            function _interopRequireWildcard(obj) {\n                if (obj && obj.__esModule) {\n                    return obj;\n                } else {\n                    var newObj = {};\n                    if (obj != null) {\n                        for(var key in obj){\n                            if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key];\n                        }\n                    }\n                    newObj.default = obj;\n                    return newObj;\n                }\n            }\n            function _interopRequireDefault(obj) {\n                return obj && obj.__esModule ? obj : {\n                    default: obj\n                };\n            }\n            function _objectWithoutProperties(obj, keys) {\n                var target = {};\n                for(var i in obj){\n                    if (keys.indexOf(i) >= 0) continue;\n                    if (!Object.prototype.hasOwnProperty.call(obj, i)) continue;\n                    target[i] = obj[i];\n                }\n                return target;\n            }\n            function _classCallCheck(instance, Constructor) {\n                if (!(instance instanceof Constructor)) {\n                    throw new TypeError(\"Cannot call a class as a function\");\n                }\n            }\n            function _possibleConstructorReturn(self1, call) {\n                if (!self1) {\n                    throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n                }\n                return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self1;\n            }\n            function _inherits(subClass, superClass) {\n                if (typeof superClass !== \"function\" && superClass !== null) {\n                    throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass);\n                }\n                subClass.prototype = Object.create(superClass && superClass.prototype, {\n                    constructor: {\n                        value: subClass,\n                        enumerable: false,\n                        writable: true,\n                        configurable: true\n                    }\n                });\n                if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;\n            }\n            var Loading = function(_Component) {\n                _inherits(Loading, _Component);\n                function Loading() {\n                    var _ref;\n                    var _temp, _this, _ret;\n                    _classCallCheck(this, Loading);\n                    for(var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++){\n                        args[_key] = arguments[_key];\n                    }\n                    return _ret = (_temp = (_this = _possibleConstructorReturn(this, (_ref = Loading.__proto__ || Object.getPrototypeOf(Loading)).call.apply(_ref, [\n                        this\n                    ].concat(args))), _this), _this.state = {\n                        delayed: _this.props.delay > 0\n                    }, _temp), _possibleConstructorReturn(_this, _ret);\n                }\n                _createClass(Loading, [\n                    {\n                        key: \"componentDidMount\",\n                        value: function componentDidMount() {\n                            var _this2 = this;\n                            var delay = this.props.delay;\n                            var delayed = this.state.delayed;\n                            if (delayed) {\n                                this.timeout = setTimeout(function() {\n                                    _this2.setState({\n                                        delayed: false\n                                    });\n                                }, delay);\n                            }\n                        }\n                    },\n                    {\n                        key: \"componentWillUnmount\",\n                        value: function componentWillUnmount() {\n                            var timeout = this.timeout;\n                            if (timeout) {\n                                clearTimeout(timeout);\n                            }\n                        }\n                    },\n                    {\n                        key: \"render\",\n                        value: function render() {\n                            var _props = this.props, color = _props.color, delay = _props.delay, type = _props.type, height = _props.height, width = _props.width, restProps = _objectWithoutProperties(_props, [\n                                \"color\",\n                                \"delay\",\n                                \"type\",\n                                \"height\",\n                                \"width\"\n                            ]);\n                            var selectedType = this.state.delayed ? \"blank\" : type;\n                            var svg = svgSources[selectedType];\n                            var style = {\n                                fill: color,\n                                height: height,\n                                width: width\n                            };\n                            return _react2.default.createElement(\"div\", _extends({\n                                style: style,\n                                dangerouslySetInnerHTML: {\n                                    __html: svg\n                                }\n                            }, restProps));\n                        }\n                    }\n                ]);\n                return Loading;\n            }(_react.Component);\n            Loading.propTypes = {\n                color: _propTypes2.default.string,\n                delay: _propTypes2.default.number,\n                type: _propTypes2.default.string,\n                height: _propTypes2.default.oneOfType([\n                    _propTypes2.default.string,\n                    _propTypes2.default.number\n                ]),\n                width: _propTypes2.default.oneOfType([\n                    _propTypes2.default.string,\n                    _propTypes2.default.number\n                ])\n            };\n            Loading.defaultProps = {\n                color: \"#fff\",\n                delay: 0,\n                type: \"balls\",\n                height: 64,\n                width: 64\n            };\n            exports1.default = Loading;\n        /***/ },\n        /* 8 */ /***/ function(module1, exports1, __nested_webpack_require_25598__) {\n            \"use strict\";\n            if (false) {} else {\n                module1.exports = __nested_webpack_require_25598__(10);\n            }\n        /***/ },\n        /* 9 */ /***/ function(module1, exports1, __nested_webpack_require_25916__) {\n            \"use strict\";\n            /** @license React v16.3.2\n * react.production.min.js\n *\n * Copyright (c) 2013-present, Facebook, Inc.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */ var m = __nested_webpack_require_25916__(2), n = __nested_webpack_require_25916__(0), p = __nested_webpack_require_25916__(5), q = __nested_webpack_require_25916__(1), r = \"function\" === typeof Symbol && Symbol[\"for\"], t = r ? Symbol[\"for\"](\"react.element\") : 60103, u = r ? Symbol[\"for\"](\"react.portal\") : 60106, v = r ? Symbol[\"for\"](\"react.fragment\") : 60107, w = r ? Symbol[\"for\"](\"react.strict_mode\") : 60108, x = r ? Symbol[\"for\"](\"react.provider\") : 60109, y = r ? Symbol[\"for\"](\"react.context\") : 60110, z = r ? Symbol[\"for\"](\"react.async_mode\") : 60111, A = r ? Symbol[\"for\"](\"react.forward_ref\") : 60112, B = \"function\" === typeof Symbol && Symbol.iterator;\n            function C(a) {\n                for(var b = arguments.length - 1, e = \"http://reactjs.org/docs/error-decoder.html?invariant=\" + a, c = 0; c < b; c++)e += \"&args[]=\" + encodeURIComponent(arguments[c + 1]);\n                n(!1, \"Minified React error #\" + a + \"; visit %s for the full message or use the non-minified dev environment for full errors and additional helpful warnings. \", e);\n            }\n            var D = {\n                isMounted: function() {\n                    return !1;\n                },\n                enqueueForceUpdate: function() {},\n                enqueueReplaceState: function() {},\n                enqueueSetState: function() {}\n            };\n            function E(a, b, e) {\n                this.props = a;\n                this.context = b;\n                this.refs = p;\n                this.updater = e || D;\n            }\n            E.prototype.isReactComponent = {};\n            E.prototype.setState = function(a, b) {\n                \"object\" !== typeof a && \"function\" !== typeof a && null != a ? C(\"85\") : void 0;\n                this.updater.enqueueSetState(this, a, b, \"setState\");\n            };\n            E.prototype.forceUpdate = function(a) {\n                this.updater.enqueueForceUpdate(this, a, \"forceUpdate\");\n            };\n            function F() {}\n            F.prototype = E.prototype;\n            function G(a, b, e) {\n                this.props = a;\n                this.context = b;\n                this.refs = p;\n                this.updater = e || D;\n            }\n            var H = G.prototype = new F;\n            H.constructor = G;\n            m(H, E.prototype);\n            H.isPureReactComponent = !0;\n            var I = {\n                current: null\n            }, J = Object.prototype.hasOwnProperty, K = {\n                key: !0,\n                ref: !0,\n                __self: !0,\n                __source: !0\n            };\n            function L(a, b, e) {\n                var c = void 0, d = {}, g = null, h = null;\n                if (null != b) for(c in void 0 !== b.ref && (h = b.ref), void 0 !== b.key && (g = \"\" + b.key), b)J.call(b, c) && !K.hasOwnProperty(c) && (d[c] = b[c]);\n                var f = arguments.length - 2;\n                if (1 === f) d.children = e;\n                else if (1 < f) {\n                    for(var k = Array(f), l = 0; l < f; l++)k[l] = arguments[l + 2];\n                    d.children = k;\n                }\n                if (a && a.defaultProps) for(c in f = a.defaultProps, f)void 0 === d[c] && (d[c] = f[c]);\n                return {\n                    $$typeof: t,\n                    type: a,\n                    key: g,\n                    ref: h,\n                    props: d,\n                    _owner: I.current\n                };\n            }\n            function M(a) {\n                return \"object\" === typeof a && null !== a && a.$$typeof === t;\n            }\n            function escape(a) {\n                var b = {\n                    \"=\": \"=0\",\n                    \":\": \"=2\"\n                };\n                return \"$\" + (\"\" + a).replace(/[=:]/g, function(a) {\n                    return b[a];\n                });\n            }\n            var N = /\\/+/g, O = [];\n            function P(a, b, e, c) {\n                if (O.length) {\n                    var d = O.pop();\n                    d.result = a;\n                    d.keyPrefix = b;\n                    d.func = e;\n                    d.context = c;\n                    d.count = 0;\n                    return d;\n                }\n                return {\n                    result: a,\n                    keyPrefix: b,\n                    func: e,\n                    context: c,\n                    count: 0\n                };\n            }\n            function Q(a) {\n                a.result = null;\n                a.keyPrefix = null;\n                a.func = null;\n                a.context = null;\n                a.count = 0;\n                10 > O.length && O.push(a);\n            }\n            function R(a, b, e, c) {\n                var d = typeof a;\n                if (\"undefined\" === d || \"boolean\" === d) a = null;\n                var g = !1;\n                if (null === a) g = !0;\n                else switch(d){\n                    case \"string\":\n                    case \"number\":\n                        g = !0;\n                        break;\n                    case \"object\":\n                        switch(a.$$typeof){\n                            case t:\n                            case u:\n                                g = !0;\n                        }\n                }\n                if (g) return e(c, a, \"\" === b ? \".\" + S(a, 0) : b), 1;\n                g = 0;\n                b = \"\" === b ? \".\" : b + \":\";\n                if (Array.isArray(a)) for(var h = 0; h < a.length; h++){\n                    d = a[h];\n                    var f = b + S(d, h);\n                    g += R(d, f, e, c);\n                }\n                else if (null === a || \"undefined\" === typeof a ? f = null : (f = B && a[B] || a[\"@@iterator\"], f = \"function\" === typeof f ? f : null), \"function\" === typeof f) for(a = f.call(a), h = 0; !(d = a.next()).done;)d = d.value, f = b + S(d, h++), g += R(d, f, e, c);\n                else \"object\" === d && (e = \"\" + a, C(\"31\", \"[object Object]\" === e ? \"object with keys {\" + Object.keys(a).join(\", \") + \"}\" : e, \"\"));\n                return g;\n            }\n            function S(a, b) {\n                return \"object\" === typeof a && null !== a && null != a.key ? escape(a.key) : b.toString(36);\n            }\n            function T(a, b) {\n                a.func.call(a.context, b, a.count++);\n            }\n            function U(a, b, e) {\n                var c = a.result, d = a.keyPrefix;\n                a = a.func.call(a.context, b, a.count++);\n                Array.isArray(a) ? V(a, c, e, q.thatReturnsArgument) : null != a && (M(a) && (b = d + (!a.key || b && b.key === a.key ? \"\" : (\"\" + a.key).replace(N, \"$&/\") + \"/\") + e, a = {\n                    $$typeof: t,\n                    type: a.type,\n                    key: b,\n                    ref: a.ref,\n                    props: a.props,\n                    _owner: a._owner\n                }), c.push(a));\n            }\n            function V(a, b, e, c, d) {\n                var g = \"\";\n                null != e && (g = (\"\" + e).replace(N, \"$&/\") + \"/\");\n                b = P(b, g, c, d);\n                null == a || R(a, \"\", U, b);\n                Q(b);\n            }\n            var W = {\n                Children: {\n                    map: function(a, b, e) {\n                        if (null == a) return a;\n                        var c = [];\n                        V(a, c, null, b, e);\n                        return c;\n                    },\n                    forEach: function(a, b, e) {\n                        if (null == a) return a;\n                        b = P(null, null, b, e);\n                        null == a || R(a, \"\", T, b);\n                        Q(b);\n                    },\n                    count: function(a) {\n                        return null == a ? 0 : R(a, \"\", q.thatReturnsNull, null);\n                    },\n                    toArray: function(a) {\n                        var b = [];\n                        V(a, b, null, q.thatReturnsArgument);\n                        return b;\n                    },\n                    only: function(a) {\n                        M(a) ? void 0 : C(\"143\");\n                        return a;\n                    }\n                },\n                createRef: function() {\n                    return {\n                        current: null\n                    };\n                },\n                Component: E,\n                PureComponent: G,\n                createContext: function(a, b) {\n                    void 0 === b && (b = null);\n                    a = {\n                        $$typeof: y,\n                        _calculateChangedBits: b,\n                        _defaultValue: a,\n                        _currentValue: a,\n                        _changedBits: 0,\n                        Provider: null,\n                        Consumer: null\n                    };\n                    a.Provider = {\n                        $$typeof: x,\n                        _context: a\n                    };\n                    return a.Consumer = a;\n                },\n                forwardRef: function(a) {\n                    return {\n                        $$typeof: A,\n                        render: a\n                    };\n                },\n                Fragment: v,\n                StrictMode: w,\n                unstable_AsyncMode: z,\n                createElement: L,\n                cloneElement: function(a, b, e) {\n                    null === a || void 0 === a ? C(\"267\", a) : void 0;\n                    var c = void 0, d = m({}, a.props), g = a.key, h = a.ref, f = a._owner;\n                    if (null != b) {\n                        void 0 !== b.ref && (h = b.ref, f = I.current);\n                        void 0 !== b.key && (g = \"\" + b.key);\n                        var k = void 0;\n                        a.type && a.type.defaultProps && (k = a.type.defaultProps);\n                        for(c in b)J.call(b, c) && !K.hasOwnProperty(c) && (d[c] = void 0 === b[c] && void 0 !== k ? k[c] : b[c]);\n                    }\n                    c = arguments.length - 2;\n                    if (1 === c) d.children = e;\n                    else if (1 < c) {\n                        k = Array(c);\n                        for(var l = 0; l < c; l++)k[l] = arguments[l + 2];\n                        d.children = k;\n                    }\n                    return {\n                        $$typeof: t,\n                        type: a.type,\n                        key: g,\n                        ref: h,\n                        props: d,\n                        _owner: f\n                    };\n                },\n                createFactory: function(a) {\n                    var b = L.bind(null, a);\n                    b.type = a;\n                    return b;\n                },\n                isValidElement: M,\n                version: \"16.3.2\",\n                __SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED: {\n                    ReactCurrentOwner: I,\n                    assign: m\n                }\n            }, X = Object.freeze({\n                default: W\n            }), Y = X && W || X;\n            module1.exports = Y[\"default\"] ? Y[\"default\"] : Y;\n        /***/ },\n        /* 10 */ /***/ function(module1, exports1, __nested_webpack_require_37431__) {\n            \"use strict\";\n            /** @license React v16.3.2\n * react.development.js\n *\n * Copyright (c) 2013-present, Facebook, Inc.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */ if (true) {\n                (function() {\n                    \"use strict\";\n                    var _assign = __nested_webpack_require_37431__(2);\n                    var invariant = __nested_webpack_require_37431__(0);\n                    var emptyObject = __nested_webpack_require_37431__(5);\n                    var warning = __nested_webpack_require_37431__(3);\n                    var emptyFunction = __nested_webpack_require_37431__(1);\n                    var checkPropTypes = __nested_webpack_require_37431__(6);\n                    // TODO: this is special because it gets imported during build.\n                    var ReactVersion = \"16.3.2\";\n                    // The Symbol used to tag the ReactElement-like types. If there is no native Symbol\n                    // nor polyfill, then a plain number is used for performance.\n                    var hasSymbol = typeof Symbol === \"function\" && Symbol[\"for\"];\n                    var REACT_ELEMENT_TYPE = hasSymbol ? Symbol[\"for\"](\"react.element\") : 0xeac7;\n                    var REACT_CALL_TYPE = hasSymbol ? Symbol[\"for\"](\"react.call\") : 0xeac8;\n                    var REACT_RETURN_TYPE = hasSymbol ? Symbol[\"for\"](\"react.return\") : 0xeac9;\n                    var REACT_PORTAL_TYPE = hasSymbol ? Symbol[\"for\"](\"react.portal\") : 0xeaca;\n                    var REACT_FRAGMENT_TYPE = hasSymbol ? Symbol[\"for\"](\"react.fragment\") : 0xeacb;\n                    var REACT_STRICT_MODE_TYPE = hasSymbol ? Symbol[\"for\"](\"react.strict_mode\") : 0xeacc;\n                    var REACT_PROVIDER_TYPE = hasSymbol ? Symbol[\"for\"](\"react.provider\") : 0xeacd;\n                    var REACT_CONTEXT_TYPE = hasSymbol ? Symbol[\"for\"](\"react.context\") : 0xeace;\n                    var REACT_ASYNC_MODE_TYPE = hasSymbol ? Symbol[\"for\"](\"react.async_mode\") : 0xeacf;\n                    var REACT_FORWARD_REF_TYPE = hasSymbol ? Symbol[\"for\"](\"react.forward_ref\") : 0xead0;\n                    var MAYBE_ITERATOR_SYMBOL = typeof Symbol === \"function\" && Symbol.iterator;\n                    var FAUX_ITERATOR_SYMBOL = \"@@iterator\";\n                    function getIteratorFn(maybeIterable) {\n                        if (maybeIterable === null || typeof maybeIterable === \"undefined\") {\n                            return null;\n                        }\n                        var maybeIterator = MAYBE_ITERATOR_SYMBOL && maybeIterable[MAYBE_ITERATOR_SYMBOL] || maybeIterable[FAUX_ITERATOR_SYMBOL];\n                        if (typeof maybeIterator === \"function\") {\n                            return maybeIterator;\n                        }\n                        return null;\n                    }\n                    // Relying on the `invariant()` implementation lets us\n                    // have preserve the format and params in the www builds.\n                    /**\n * Forked from fbjs/warning:\n * https://github.com/facebook/fbjs/blob/e66ba20ad5be433eb54423f2b097d829324d9de6/packages/fbjs/src/__forks__/warning.js\n *\n * Only change is we use console.warn instead of console.error,\n * and do nothing when 'console' is not supported.\n * This really simplifies the code.\n * ---\n * Similar to invariant but only logs a warning if the condition is not met.\n * This can be used to log issues in development environments in critical\n * paths. Removing the logging code for production environments will keep the\n * same logic and follow the same code paths.\n */ var lowPriorityWarning = function() {};\n                    {\n                        var printWarning = function(format) {\n                            for(var _len = arguments.length, args = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++){\n                                args[_key - 1] = arguments[_key];\n                            }\n                            var argIndex = 0;\n                            var message = \"Warning: \" + format.replace(/%s/g, function() {\n                                return args[argIndex++];\n                            });\n                            if (typeof console !== \"undefined\") {\n                                console.warn(message);\n                            }\n                            try {\n                                // --- Welcome to debugging React ---\n                                // This error was thrown as a convenience so that you can use this stack\n                                // to find the callsite that caused this warning to fire.\n                                throw new Error(message);\n                            } catch (x) {}\n                        };\n                        lowPriorityWarning = function(condition, format) {\n                            if (format === undefined) {\n                                throw new Error(\"`warning(condition, format, ...args)` requires a warning \" + \"message argument\");\n                            }\n                            if (!condition) {\n                                for(var _len2 = arguments.length, args = Array(_len2 > 2 ? _len2 - 2 : 0), _key2 = 2; _key2 < _len2; _key2++){\n                                    args[_key2 - 2] = arguments[_key2];\n                                }\n                                printWarning.apply(undefined, [\n                                    format\n                                ].concat(args));\n                            }\n                        };\n                    }\n                    var lowPriorityWarning$1 = lowPriorityWarning;\n                    var didWarnStateUpdateForUnmountedComponent = {};\n                    function warnNoop(publicInstance, callerName) {\n                        {\n                            var _constructor = publicInstance.constructor;\n                            var componentName = _constructor && (_constructor.displayName || _constructor.name) || \"ReactClass\";\n                            var warningKey = componentName + \".\" + callerName;\n                            if (didWarnStateUpdateForUnmountedComponent[warningKey]) {\n                                return;\n                            }\n                            warning(false, \"Can't call %s on a component that is not yet mounted. \" + \"This is a no-op, but it might indicate a bug in your application. \" + \"Instead, assign to `this.state` directly or define a `state = {};` \" + \"class property with the desired state in the %s component.\", callerName, componentName);\n                            didWarnStateUpdateForUnmountedComponent[warningKey] = true;\n                        }\n                    }\n                    /**\n * This is the abstract API for an update queue.\n */ var ReactNoopUpdateQueue = {\n                        /**\n   * Checks whether or not this composite component is mounted.\n   * @param {ReactClass} publicInstance The instance we want to test.\n   * @return {boolean} True if mounted, false otherwise.\n   * @protected\n   * @final\n   */ isMounted: function(publicInstance) {\n                            return false;\n                        },\n                        /**\n   * Forces an update. This should only be invoked when it is known with\n   * certainty that we are **not** in a DOM transaction.\n   *\n   * You may want to call this when you know that some deeper aspect of the\n   * component's state has changed but `setState` was not called.\n   *\n   * This will not invoke `shouldComponentUpdate`, but it will invoke\n   * `componentWillUpdate` and `componentDidUpdate`.\n   *\n   * @param {ReactClass} publicInstance The instance that should rerender.\n   * @param {?function} callback Called after component is updated.\n   * @param {?string} callerName name of the calling function in the public API.\n   * @internal\n   */ enqueueForceUpdate: function(publicInstance, callback, callerName) {\n                            warnNoop(publicInstance, \"forceUpdate\");\n                        },\n                        /**\n   * Replaces all of the state. Always use this or `setState` to mutate state.\n   * You should treat `this.state` as immutable.\n   *\n   * There is no guarantee that `this.state` will be immediately updated, so\n   * accessing `this.state` after calling this method may return the old value.\n   *\n   * @param {ReactClass} publicInstance The instance that should rerender.\n   * @param {object} completeState Next state.\n   * @param {?function} callback Called after component is updated.\n   * @param {?string} callerName name of the calling function in the public API.\n   * @internal\n   */ enqueueReplaceState: function(publicInstance, completeState, callback, callerName) {\n                            warnNoop(publicInstance, \"replaceState\");\n                        },\n                        /**\n   * Sets a subset of the state. This only exists because _pendingState is\n   * internal. This provides a merging strategy that is not available to deep\n   * properties which is confusing. TODO: Expose pendingState or don't use it\n   * during the merge.\n   *\n   * @param {ReactClass} publicInstance The instance that should rerender.\n   * @param {object} partialState Next partial state to be merged with state.\n   * @param {?function} callback Called after component is updated.\n   * @param {?string} Name of the calling function in the public API.\n   * @internal\n   */ enqueueSetState: function(publicInstance, partialState, callback, callerName) {\n                            warnNoop(publicInstance, \"setState\");\n                        }\n                    };\n                    /**\n * Base class helpers for the updating state of a component.\n */ function Component(props, context, updater) {\n                        this.props = props;\n                        this.context = context;\n                        this.refs = emptyObject;\n                        // We initialize the default updater but the real one gets injected by the\n                        // renderer.\n                        this.updater = updater || ReactNoopUpdateQueue;\n                    }\n                    Component.prototype.isReactComponent = {};\n                    /**\n * Sets a subset of the state. Always use this to mutate\n * state. You should treat `this.state` as immutable.\n *\n * There is no guarantee that `this.state` will be immediately updated, so\n * accessing `this.state` after calling this method may return the old value.\n *\n * There is no guarantee that calls to `setState` will run synchronously,\n * as they may eventually be batched together.  You can provide an optional\n * callback that will be executed when the call to setState is actually\n * completed.\n *\n * When a function is provided to setState, it will be called at some point in\n * the future (not synchronously). It will be called with the up to date\n * component arguments (state, props, context). These values can be different\n * from this.* because your function may be called after receiveProps but before\n * shouldComponentUpdate, and this new state, props, and context will not yet be\n * assigned to this.\n *\n * @param {object|function} partialState Next partial state or function to\n *        produce next partial state to be merged with current state.\n * @param {?function} callback Called after state is updated.\n * @final\n * @protected\n */ Component.prototype.setState = function(partialState, callback) {\n                        !(typeof partialState === \"object\" || typeof partialState === \"function\" || partialState == null) ? invariant(false, \"setState(...): takes an object of state variables to update or a function which returns an object of state variables.\") : void 0;\n                        this.updater.enqueueSetState(this, partialState, callback, \"setState\");\n                    };\n                    /**\n * Forces an update. This should only be invoked when it is known with\n * certainty that we are **not** in a DOM transaction.\n *\n * You may want to call this when you know that some deeper aspect of the\n * component's state has changed but `setState` was not called.\n *\n * This will not invoke `shouldComponentUpdate`, but it will invoke\n * `componentWillUpdate` and `componentDidUpdate`.\n *\n * @param {?function} callback Called after update is complete.\n * @final\n * @protected\n */ Component.prototype.forceUpdate = function(callback) {\n                        this.updater.enqueueForceUpdate(this, callback, \"forceUpdate\");\n                    };\n                    /**\n * Deprecated APIs. These APIs used to exist on classic React classes but since\n * we would like to deprecate them, we're not going to move them over to this\n * modern base class. Instead, we define a getter that warns if it's accessed.\n */ {\n                        var deprecatedAPIs = {\n                            isMounted: [\n                                \"isMounted\",\n                                \"Instead, make sure to clean up subscriptions and pending requests in \" + \"componentWillUnmount to prevent memory leaks.\"\n                            ],\n                            replaceState: [\n                                \"replaceState\",\n                                \"Refactor your code to use setState instead (see \" + \"https://github.com/facebook/react/issues/3236).\"\n                            ]\n                        };\n                        var defineDeprecationWarning = function(methodName, info) {\n                            Object.defineProperty(Component.prototype, methodName, {\n                                get: function() {\n                                    lowPriorityWarning$1(false, \"%s(...) is deprecated in plain JavaScript React classes. %s\", info[0], info[1]);\n                                    return undefined;\n                                }\n                            });\n                        };\n                        for(var fnName in deprecatedAPIs){\n                            if (deprecatedAPIs.hasOwnProperty(fnName)) {\n                                defineDeprecationWarning(fnName, deprecatedAPIs[fnName]);\n                            }\n                        }\n                    }\n                    function ComponentDummy() {}\n                    ComponentDummy.prototype = Component.prototype;\n                    /**\n * Convenience component with default shallow equality check for sCU.\n */ function PureComponent(props, context, updater) {\n                        this.props = props;\n                        this.context = context;\n                        this.refs = emptyObject;\n                        this.updater = updater || ReactNoopUpdateQueue;\n                    }\n                    var pureComponentPrototype = PureComponent.prototype = new ComponentDummy();\n                    pureComponentPrototype.constructor = PureComponent;\n                    // Avoid an extra prototype jump for these methods.\n                    _assign(pureComponentPrototype, Component.prototype);\n                    pureComponentPrototype.isPureReactComponent = true;\n                    // an immutable object with a single mutable value\n                    function createRef() {\n                        var refObject = {\n                            current: null\n                        };\n                        {\n                            Object.seal(refObject);\n                        }\n                        return refObject;\n                    }\n                    /**\n * Keeps track of the current owner.\n *\n * The current owner is the component who should own any components that are\n * currently being constructed.\n */ var ReactCurrentOwner = {\n                        /**\n   * @internal\n   * @type {ReactComponent}\n   */ current: null\n                    };\n                    var hasOwnProperty = Object.prototype.hasOwnProperty;\n                    var RESERVED_PROPS = {\n                        key: true,\n                        ref: true,\n                        __self: true,\n                        __source: true\n                    };\n                    var specialPropKeyWarningShown = void 0;\n                    var specialPropRefWarningShown = void 0;\n                    function hasValidRef(config) {\n                        {\n                            if (hasOwnProperty.call(config, \"ref\")) {\n                                var getter = Object.getOwnPropertyDescriptor(config, \"ref\").get;\n                                if (getter && getter.isReactWarning) {\n                                    return false;\n                                }\n                            }\n                        }\n                        return config.ref !== undefined;\n                    }\n                    function hasValidKey(config) {\n                        {\n                            if (hasOwnProperty.call(config, \"key\")) {\n                                var getter = Object.getOwnPropertyDescriptor(config, \"key\").get;\n                                if (getter && getter.isReactWarning) {\n                                    return false;\n                                }\n                            }\n                        }\n                        return config.key !== undefined;\n                    }\n                    function defineKeyPropWarningGetter(props, displayName) {\n                        var warnAboutAccessingKey = function() {\n                            if (!specialPropKeyWarningShown) {\n                                specialPropKeyWarningShown = true;\n                                warning(false, \"%s: `key` is not a prop. Trying to access it will result \" + \"in `undefined` being returned. If you need to access the same \" + \"value within the child component, you should pass it as a different \" + \"prop. (https://fb.me/react-special-props)\", displayName);\n                            }\n                        };\n                        warnAboutAccessingKey.isReactWarning = true;\n                        Object.defineProperty(props, \"key\", {\n                            get: warnAboutAccessingKey,\n                            configurable: true\n                        });\n                    }\n                    function defineRefPropWarningGetter(props, displayName) {\n                        var warnAboutAccessingRef = function() {\n                            if (!specialPropRefWarningShown) {\n                                specialPropRefWarningShown = true;\n                                warning(false, \"%s: `ref` is not a prop. Trying to access it will result \" + \"in `undefined` being returned. If you need to access the same \" + \"value within the child component, you should pass it as a different \" + \"prop. (https://fb.me/react-special-props)\", displayName);\n                            }\n                        };\n                        warnAboutAccessingRef.isReactWarning = true;\n                        Object.defineProperty(props, \"ref\", {\n                            get: warnAboutAccessingRef,\n                            configurable: true\n                        });\n                    }\n                    /**\n * Factory method to create a new React element. This no longer adheres to\n * the class pattern, so do not use new to call it. Also, no instanceof check\n * will work. Instead test $$typeof field against Symbol.for('react.element') to check\n * if something is a React Element.\n *\n * @param {*} type\n * @param {*} key\n * @param {string|object} ref\n * @param {*} self A *temporary* helper to detect places where `this` is\n * different from the `owner` when React.createElement is called, so that we\n * can warn. We want to get rid of owner and replace string `ref`s with arrow\n * functions, and as long as `this` and owner are the same, there will be no\n * change in behavior.\n * @param {*} source An annotation object (added by a transpiler or otherwise)\n * indicating filename, line number, and/or other information.\n * @param {*} owner\n * @param {*} props\n * @internal\n */ var ReactElement = function(type, key, ref, self1, source, owner, props) {\n                        var element = {\n                            // This tag allows us to uniquely identify this as a React Element\n                            $$typeof: REACT_ELEMENT_TYPE,\n                            // Built-in properties that belong on the element\n                            type: type,\n                            key: key,\n                            ref: ref,\n                            props: props,\n                            // Record the component responsible for creating this element.\n                            _owner: owner\n                        };\n                        {\n                            // The validation flag is currently mutative. We put it on\n                            // an external backing store so that we can freeze the whole object.\n                            // This can be replaced with a WeakMap once they are implemented in\n                            // commonly used development environments.\n                            element._store = {};\n                            // To make comparing ReactElements easier for testing purposes, we make\n                            // the validation flag non-enumerable (where possible, which should\n                            // include every environment we run tests in), so the test framework\n                            // ignores it.\n                            Object.defineProperty(element._store, \"validated\", {\n                                configurable: false,\n                                enumerable: false,\n                                writable: true,\n                                value: false\n                            });\n                            // self and source are DEV only properties.\n                            Object.defineProperty(element, \"_self\", {\n                                configurable: false,\n                                enumerable: false,\n                                writable: false,\n                                value: self1\n                            });\n                            // Two elements created in two different places should be considered\n                            // equal for testing purposes and therefore we hide it from enumeration.\n                            Object.defineProperty(element, \"_source\", {\n                                configurable: false,\n                                enumerable: false,\n                                writable: false,\n                                value: source\n                            });\n                            if (Object.freeze) {\n                                Object.freeze(element.props);\n                                Object.freeze(element);\n                            }\n                        }\n                        return element;\n                    };\n                    /**\n * Create and return a new ReactElement of the given type.\n * See https://reactjs.org/docs/react-api.html#createelement\n */ function createElement(type, config, children) {\n                        var propName = void 0;\n                        // Reserved names are extracted\n                        var props = {};\n                        var key = null;\n                        var ref = null;\n                        var self1 = null;\n                        var source = null;\n                        if (config != null) {\n                            if (hasValidRef(config)) {\n                                ref = config.ref;\n                            }\n                            if (hasValidKey(config)) {\n                                key = \"\" + config.key;\n                            }\n                            self1 = config.__self === undefined ? null : config.__self;\n                            source = config.__source === undefined ? null : config.__source;\n                            // Remaining properties are added to a new props object\n                            for(propName in config){\n                                if (hasOwnProperty.call(config, propName) && !RESERVED_PROPS.hasOwnProperty(propName)) {\n                                    props[propName] = config[propName];\n                                }\n                            }\n                        }\n                        // Children can be more than one argument, and those are transferred onto\n                        // the newly allocated props object.\n                        var childrenLength = arguments.length - 2;\n                        if (childrenLength === 1) {\n                            props.children = children;\n                        } else if (childrenLength > 1) {\n                            var childArray = Array(childrenLength);\n                            for(var i = 0; i < childrenLength; i++){\n                                childArray[i] = arguments[i + 2];\n                            }\n                            {\n                                if (Object.freeze) {\n                                    Object.freeze(childArray);\n                                }\n                            }\n                            props.children = childArray;\n                        }\n                        // Resolve default props\n                        if (type && type.defaultProps) {\n                            var defaultProps = type.defaultProps;\n                            for(propName in defaultProps){\n                                if (props[propName] === undefined) {\n                                    props[propName] = defaultProps[propName];\n                                }\n                            }\n                        }\n                        {\n                            if (key || ref) {\n                                if (typeof props.$$typeof === \"undefined\" || props.$$typeof !== REACT_ELEMENT_TYPE) {\n                                    var displayName = typeof type === \"function\" ? type.displayName || type.name || \"Unknown\" : type;\n                                    if (key) {\n                                        defineKeyPropWarningGetter(props, displayName);\n                                    }\n                                    if (ref) {\n                                        defineRefPropWarningGetter(props, displayName);\n                                    }\n                                }\n                            }\n                        }\n                        return ReactElement(type, key, ref, self1, source, ReactCurrentOwner.current, props);\n                    }\n                    /**\n * Return a function that produces ReactElements of a given type.\n * See https://reactjs.org/docs/react-api.html#createfactory\n */ function cloneAndReplaceKey(oldElement, newKey) {\n                        var newElement = ReactElement(oldElement.type, newKey, oldElement.ref, oldElement._self, oldElement._source, oldElement._owner, oldElement.props);\n                        return newElement;\n                    }\n                    /**\n * Clone and return a new ReactElement using element as the starting point.\n * See https://reactjs.org/docs/react-api.html#cloneelement\n */ function cloneElement(element, config, children) {\n                        !!(element === null || element === undefined) ? invariant(false, \"React.cloneElement(...): The argument must be a React element, but you passed %s.\", element) : void 0;\n                        var propName = void 0;\n                        // Original props are copied\n                        var props = _assign({}, element.props);\n                        // Reserved names are extracted\n                        var key = element.key;\n                        var ref = element.ref;\n                        // Self is preserved since the owner is preserved.\n                        var self1 = element._self;\n                        // Source is preserved since cloneElement is unlikely to be targeted by a\n                        // transpiler, and the original source is probably a better indicator of the\n                        // true owner.\n                        var source = element._source;\n                        // Owner will be preserved, unless ref is overridden\n                        var owner = element._owner;\n                        if (config != null) {\n                            if (hasValidRef(config)) {\n                                // Silently steal the ref from the parent.\n                                ref = config.ref;\n                                owner = ReactCurrentOwner.current;\n                            }\n                            if (hasValidKey(config)) {\n                                key = \"\" + config.key;\n                            }\n                            // Remaining properties override existing props\n                            var defaultProps = void 0;\n                            if (element.type && element.type.defaultProps) {\n                                defaultProps = element.type.defaultProps;\n                            }\n                            for(propName in config){\n                                if (hasOwnProperty.call(config, propName) && !RESERVED_PROPS.hasOwnProperty(propName)) {\n                                    if (config[propName] === undefined && defaultProps !== undefined) {\n                                        // Resolve default props\n                                        props[propName] = defaultProps[propName];\n                                    } else {\n                                        props[propName] = config[propName];\n                                    }\n                                }\n                            }\n                        }\n                        // Children can be more than one argument, and those are transferred onto\n                        // the newly allocated props object.\n                        var childrenLength = arguments.length - 2;\n                        if (childrenLength === 1) {\n                            props.children = children;\n                        } else if (childrenLength > 1) {\n                            var childArray = Array(childrenLength);\n                            for(var i = 0; i < childrenLength; i++){\n                                childArray[i] = arguments[i + 2];\n                            }\n                            props.children = childArray;\n                        }\n                        return ReactElement(element.type, key, ref, self1, source, owner, props);\n                    }\n                    /**\n * Verifies the object is a ReactElement.\n * See https://reactjs.org/docs/react-api.html#isvalidelement\n * @param {?object} object\n * @return {boolean} True if `object` is a valid component.\n * @final\n */ function isValidElement(object) {\n                        return typeof object === \"object\" && object !== null && object.$$typeof === REACT_ELEMENT_TYPE;\n                    }\n                    var ReactDebugCurrentFrame = {};\n                    {\n                        // Component that is being worked on\n                        ReactDebugCurrentFrame.getCurrentStack = null;\n                        ReactDebugCurrentFrame.getStackAddendum = function() {\n                            var impl = ReactDebugCurrentFrame.getCurrentStack;\n                            if (impl) {\n                                return impl();\n                            }\n                            return null;\n                        };\n                    }\n                    var SEPARATOR = \".\";\n                    var SUBSEPARATOR = \":\";\n                    /**\n * Escape and wrap key so it is safe to use as a reactid\n *\n * @param {string} key to be escaped.\n * @return {string} the escaped key.\n */ function escape(key) {\n                        var escapeRegex = /[=:]/g;\n                        var escaperLookup = {\n                            \"=\": \"=0\",\n                            \":\": \"=2\"\n                        };\n                        var escapedString = (\"\" + key).replace(escapeRegex, function(match) {\n                            return escaperLookup[match];\n                        });\n                        return \"$\" + escapedString;\n                    }\n                    /**\n * TODO: Test that a single child and an array with one item have the same key\n * pattern.\n */ var didWarnAboutMaps = false;\n                    var userProvidedKeyEscapeRegex = /\\/+/g;\n                    function escapeUserProvidedKey(text) {\n                        return (\"\" + text).replace(userProvidedKeyEscapeRegex, \"$&/\");\n                    }\n                    var POOL_SIZE = 10;\n                    var traverseContextPool = [];\n                    function getPooledTraverseContext(mapResult, keyPrefix, mapFunction, mapContext) {\n                        if (traverseContextPool.length) {\n                            var traverseContext = traverseContextPool.pop();\n                            traverseContext.result = mapResult;\n                            traverseContext.keyPrefix = keyPrefix;\n                            traverseContext.func = mapFunction;\n                            traverseContext.context = mapContext;\n                            traverseContext.count = 0;\n                            return traverseContext;\n                        } else {\n                            return {\n                                result: mapResult,\n                                keyPrefix: keyPrefix,\n                                func: mapFunction,\n                                context: mapContext,\n                                count: 0\n                            };\n                        }\n                    }\n                    function releaseTraverseContext(traverseContext) {\n                        traverseContext.result = null;\n                        traverseContext.keyPrefix = null;\n                        traverseContext.func = null;\n                        traverseContext.context = null;\n                        traverseContext.count = 0;\n                        if (traverseContextPool.length < POOL_SIZE) {\n                            traverseContextPool.push(traverseContext);\n                        }\n                    }\n                    /**\n * @param {?*} children Children tree container.\n * @param {!string} nameSoFar Name of the key path so far.\n * @param {!function} callback Callback to invoke with each child found.\n * @param {?*} traverseContext Used to pass information throughout the traversal\n * process.\n * @return {!number} The number of children in this subtree.\n */ function traverseAllChildrenImpl(children, nameSoFar, callback, traverseContext) {\n                        var type = typeof children;\n                        if (type === \"undefined\" || type === \"boolean\") {\n                            // All of the above are perceived as null.\n                            children = null;\n                        }\n                        var invokeCallback = false;\n                        if (children === null) {\n                            invokeCallback = true;\n                        } else {\n                            switch(type){\n                                case \"string\":\n                                case \"number\":\n                                    invokeCallback = true;\n                                    break;\n                                case \"object\":\n                                    switch(children.$$typeof){\n                                        case REACT_ELEMENT_TYPE:\n                                        case REACT_PORTAL_TYPE:\n                                            invokeCallback = true;\n                                    }\n                            }\n                        }\n                        if (invokeCallback) {\n                            callback(traverseContext, children, // If it's the only child, treat the name as if it was wrapped in an array\n                            // so that it's consistent if the number of children grows.\n                            nameSoFar === \"\" ? SEPARATOR + getComponentKey(children, 0) : nameSoFar);\n                            return 1;\n                        }\n                        var child = void 0;\n                        var nextName = void 0;\n                        var subtreeCount = 0; // Count of children found in the current subtree.\n                        var nextNamePrefix = nameSoFar === \"\" ? SEPARATOR : nameSoFar + SUBSEPARATOR;\n                        if (Array.isArray(children)) {\n                            for(var i = 0; i < children.length; i++){\n                                child = children[i];\n                                nextName = nextNamePrefix + getComponentKey(child, i);\n                                subtreeCount += traverseAllChildrenImpl(child, nextName, callback, traverseContext);\n                            }\n                        } else {\n                            var iteratorFn = getIteratorFn(children);\n                            if (typeof iteratorFn === \"function\") {\n                                {\n                                    // Warn about using Maps as children\n                                    if (iteratorFn === children.entries) {\n                                        !didWarnAboutMaps ? warning(false, \"Using Maps as children is unsupported and will likely yield \" + \"unexpected results. Convert it to a sequence/iterable of keyed \" + \"ReactElements instead.%s\", ReactDebugCurrentFrame.getStackAddendum()) : void 0;\n                                        didWarnAboutMaps = true;\n                                    }\n                                }\n                                var iterator = iteratorFn.call(children);\n                                var step = void 0;\n                                var ii = 0;\n                                while(!(step = iterator.next()).done){\n                                    child = step.value;\n                                    nextName = nextNamePrefix + getComponentKey(child, ii++);\n                                    subtreeCount += traverseAllChildrenImpl(child, nextName, callback, traverseContext);\n                                }\n                            } else if (type === \"object\") {\n                                var addendum = \"\";\n                                {\n                                    addendum = \" If you meant to render a collection of children, use an array \" + \"instead.\" + ReactDebugCurrentFrame.getStackAddendum();\n                                }\n                                var childrenString = \"\" + children;\n                                invariant(false, \"Objects are not valid as a React child (found: %s).%s\", childrenString === \"[object Object]\" ? \"object with keys {\" + Object.keys(children).join(\", \") + \"}\" : childrenString, addendum);\n                            }\n                        }\n                        return subtreeCount;\n                    }\n                    /**\n * Traverses children that are typically specified as `props.children`, but\n * might also be specified through attributes:\n *\n * - `traverseAllChildren(this.props.children, ...)`\n * - `traverseAllChildren(this.props.leftPanelChildren, ...)`\n *\n * The `traverseContext` is an optional argument that is passed through the\n * entire traversal. It can be used to store accumulations or anything else that\n * the callback might find relevant.\n *\n * @param {?*} children Children tree object.\n * @param {!function} callback To invoke upon traversing each child.\n * @param {?*} traverseContext Context for traversal.\n * @return {!number} The number of children in this subtree.\n */ function traverseAllChildren(children, callback, traverseContext) {\n                        if (children == null) {\n                            return 0;\n                        }\n                        return traverseAllChildrenImpl(children, \"\", callback, traverseContext);\n                    }\n                    /**\n * Generate a key string that identifies a component within a set.\n *\n * @param {*} component A component that could contain a manual key.\n * @param {number} index Index that is used if a manual key is not provided.\n * @return {string}\n */ function getComponentKey(component, index) {\n                        // Do some typechecking here since we call this blindly. We want to ensure\n                        // that we don't block potential future ES APIs.\n                        if (typeof component === \"object\" && component !== null && component.key != null) {\n                            // Explicit key\n                            return escape(component.key);\n                        }\n                        // Implicit key determined by the index in the set\n                        return index.toString(36);\n                    }\n                    function forEachSingleChild(bookKeeping, child, name) {\n                        var func = bookKeeping.func, context = bookKeeping.context;\n                        func.call(context, child, bookKeeping.count++);\n                    }\n                    /**\n * Iterates through children that are typically specified as `props.children`.\n *\n * See https://reactjs.org/docs/react-api.html#react.children.foreach\n *\n * The provided forEachFunc(child, index) will be called for each\n * leaf child.\n *\n * @param {?*} children Children tree container.\n * @param {function(*, int)} forEachFunc\n * @param {*} forEachContext Context for forEachContext.\n */ function forEachChildren(children, forEachFunc, forEachContext) {\n                        if (children == null) {\n                            return children;\n                        }\n                        var traverseContext = getPooledTraverseContext(null, null, forEachFunc, forEachContext);\n                        traverseAllChildren(children, forEachSingleChild, traverseContext);\n                        releaseTraverseContext(traverseContext);\n                    }\n                    function mapSingleChildIntoContext(bookKeeping, child, childKey) {\n                        var result = bookKeeping.result, keyPrefix = bookKeeping.keyPrefix, func = bookKeeping.func, context = bookKeeping.context;\n                        var mappedChild = func.call(context, child, bookKeeping.count++);\n                        if (Array.isArray(mappedChild)) {\n                            mapIntoWithKeyPrefixInternal(mappedChild, result, childKey, emptyFunction.thatReturnsArgument);\n                        } else if (mappedChild != null) {\n                            if (isValidElement(mappedChild)) {\n                                mappedChild = cloneAndReplaceKey(mappedChild, // Keep both the (mapped) and old keys if they differ, just as\n                                // traverseAllChildren used to do for objects as children\n                                keyPrefix + (mappedChild.key && (!child || child.key !== mappedChild.key) ? escapeUserProvidedKey(mappedChild.key) + \"/\" : \"\") + childKey);\n                            }\n                            result.push(mappedChild);\n                        }\n                    }\n                    function mapIntoWithKeyPrefixInternal(children, array, prefix, func, context) {\n                        var escapedPrefix = \"\";\n                        if (prefix != null) {\n                            escapedPrefix = escapeUserProvidedKey(prefix) + \"/\";\n                        }\n                        var traverseContext = getPooledTraverseContext(array, escapedPrefix, func, context);\n                        traverseAllChildren(children, mapSingleChildIntoContext, traverseContext);\n                        releaseTraverseContext(traverseContext);\n                    }\n                    /**\n * Maps children that are typically specified as `props.children`.\n *\n * See https://reactjs.org/docs/react-api.html#react.children.map\n *\n * The provided mapFunction(child, key, index) will be called for each\n * leaf child.\n *\n * @param {?*} children Children tree container.\n * @param {function(*, int)} func The map function.\n * @param {*} context Context for mapFunction.\n * @return {object} Object containing the ordered map of results.\n */ function mapChildren(children, func, context) {\n                        if (children == null) {\n                            return children;\n                        }\n                        var result = [];\n                        mapIntoWithKeyPrefixInternal(children, result, null, func, context);\n                        return result;\n                    }\n                    /**\n * Count the number of children that are typically specified as\n * `props.children`.\n *\n * See https://reactjs.org/docs/react-api.html#react.children.count\n *\n * @param {?*} children Children tree container.\n * @return {number} The number of children.\n */ function countChildren(children, context) {\n                        return traverseAllChildren(children, emptyFunction.thatReturnsNull, null);\n                    }\n                    /**\n * Flatten a children object (typically specified as `props.children`) and\n * return an array with appropriately re-keyed children.\n *\n * See https://reactjs.org/docs/react-api.html#react.children.toarray\n */ function toArray(children) {\n                        var result = [];\n                        mapIntoWithKeyPrefixInternal(children, result, null, emptyFunction.thatReturnsArgument);\n                        return result;\n                    }\n                    /**\n * Returns the first child in a collection of children and verifies that there\n * is only one child in the collection.\n *\n * See https://reactjs.org/docs/react-api.html#react.children.only\n *\n * The current implementation of this function assumes that a single child gets\n * passed without a wrapper, but the purpose of this helper function is to\n * abstract away the particular structure of children.\n *\n * @param {?object} children Child collection structure.\n * @return {ReactElement} The first and only `ReactElement` contained in the\n * structure.\n */ function onlyChild(children) {\n                        !isValidElement(children) ? invariant(false, \"React.Children.only expected to receive a single React element child.\") : void 0;\n                        return children;\n                    }\n                    function createContext(defaultValue, calculateChangedBits) {\n                        if (calculateChangedBits === undefined) {\n                            calculateChangedBits = null;\n                        } else {\n                            {\n                                !(calculateChangedBits === null || typeof calculateChangedBits === \"function\") ? warning(false, \"createContext: Expected the optional second argument to be a \" + \"function. Instead received: %s\", calculateChangedBits) : void 0;\n                            }\n                        }\n                        var context = {\n                            $$typeof: REACT_CONTEXT_TYPE,\n                            _calculateChangedBits: calculateChangedBits,\n                            _defaultValue: defaultValue,\n                            _currentValue: defaultValue,\n                            _changedBits: 0,\n                            // These are circular\n                            Provider: null,\n                            Consumer: null\n                        };\n                        context.Provider = {\n                            $$typeof: REACT_PROVIDER_TYPE,\n                            _context: context\n                        };\n                        context.Consumer = context;\n                        {\n                            context._currentRenderer = null;\n                        }\n                        return context;\n                    }\n                    function forwardRef(render) {\n                        {\n                            !(typeof render === \"function\") ? warning(false, \"forwardRef requires a render function but was given %s.\", render === null ? \"null\" : typeof render) : void 0;\n                        }\n                        return {\n                            $$typeof: REACT_FORWARD_REF_TYPE,\n                            render: render\n                        };\n                    }\n                    var describeComponentFrame = function(name, source, ownerName) {\n                        return \"\\n    in \" + (name || \"Unknown\") + (source ? \" (at \" + source.fileName.replace(/^.*[\\\\\\/]/, \"\") + \":\" + source.lineNumber + \")\" : ownerName ? \" (created by \" + ownerName + \")\" : \"\");\n                    };\n                    function isValidElementType(type) {\n                        return typeof type === \"string\" || typeof type === \"function\" || // Note: its typeof might be other than 'symbol' or 'number' if it's a polyfill.\n                        type === REACT_FRAGMENT_TYPE || type === REACT_ASYNC_MODE_TYPE || type === REACT_STRICT_MODE_TYPE || typeof type === \"object\" && type !== null && (type.$$typeof === REACT_PROVIDER_TYPE || type.$$typeof === REACT_CONTEXT_TYPE || type.$$typeof === REACT_FORWARD_REF_TYPE);\n                    }\n                    function getComponentName(fiber) {\n                        var type = fiber.type;\n                        if (typeof type === \"function\") {\n                            return type.displayName || type.name;\n                        }\n                        if (typeof type === \"string\") {\n                            return type;\n                        }\n                        switch(type){\n                            case REACT_FRAGMENT_TYPE:\n                                return \"ReactFragment\";\n                            case REACT_PORTAL_TYPE:\n                                return \"ReactPortal\";\n                            case REACT_CALL_TYPE:\n                                return \"ReactCall\";\n                            case REACT_RETURN_TYPE:\n                                return \"ReactReturn\";\n                        }\n                        if (typeof type === \"object\" && type !== null) {\n                            switch(type.$$typeof){\n                                case REACT_FORWARD_REF_TYPE:\n                                    var functionName = type.render.displayName || type.render.name || \"\";\n                                    return functionName !== \"\" ? \"ForwardRef(\" + functionName + \")\" : \"ForwardRef\";\n                            }\n                        }\n                        return null;\n                    }\n                    /**\n * ReactElementValidator provides a wrapper around a element factory\n * which validates the props passed to the element. This is intended to be\n * used only in DEV and could be replaced by a static type checker for languages\n * that support it.\n */ var currentlyValidatingElement = void 0;\n                    var propTypesMisspellWarningShown = void 0;\n                    var getDisplayName = function() {};\n                    var getStackAddendum = function() {};\n                    {\n                        currentlyValidatingElement = null;\n                        propTypesMisspellWarningShown = false;\n                        getDisplayName = function(element) {\n                            if (element == null) {\n                                return \"#empty\";\n                            } else if (typeof element === \"string\" || typeof element === \"number\") {\n                                return \"#text\";\n                            } else if (typeof element.type === \"string\") {\n                                return element.type;\n                            } else if (element.type === REACT_FRAGMENT_TYPE) {\n                                return \"React.Fragment\";\n                            } else {\n                                return element.type.displayName || element.type.name || \"Unknown\";\n                            }\n                        };\n                        getStackAddendum = function() {\n                            var stack = \"\";\n                            if (currentlyValidatingElement) {\n                                var name = getDisplayName(currentlyValidatingElement);\n                                var owner = currentlyValidatingElement._owner;\n                                stack += describeComponentFrame(name, currentlyValidatingElement._source, owner && getComponentName(owner));\n                            }\n                            stack += ReactDebugCurrentFrame.getStackAddendum() || \"\";\n                            return stack;\n                        };\n                    }\n                    function getDeclarationErrorAddendum() {\n                        if (ReactCurrentOwner.current) {\n                            var name = getComponentName(ReactCurrentOwner.current);\n                            if (name) {\n                                return \"\\n\\nCheck the render method of `\" + name + \"`.\";\n                            }\n                        }\n                        return \"\";\n                    }\n                    function getSourceInfoErrorAddendum(elementProps) {\n                        if (elementProps !== null && elementProps !== undefined && elementProps.__source !== undefined) {\n                            var source = elementProps.__source;\n                            var fileName = source.fileName.replace(/^.*[\\\\\\/]/, \"\");\n                            var lineNumber = source.lineNumber;\n                            return \"\\n\\nCheck your code at \" + fileName + \":\" + lineNumber + \".\";\n                        }\n                        return \"\";\n                    }\n                    /**\n * Warn if there's no key explicitly set on dynamic arrays of children or\n * object keys are not valid. This allows us to keep track of children between\n * updates.\n */ var ownerHasKeyUseWarning = {};\n                    function getCurrentComponentErrorInfo(parentType) {\n                        var info = getDeclarationErrorAddendum();\n                        if (!info) {\n                            var parentName = typeof parentType === \"string\" ? parentType : parentType.displayName || parentType.name;\n                            if (parentName) {\n                                info = \"\\n\\nCheck the top-level render call using <\" + parentName + \">.\";\n                            }\n                        }\n                        return info;\n                    }\n                    /**\n * Warn if the element doesn't have an explicit key assigned to it.\n * This element is in an array. The array could grow and shrink or be\n * reordered. All children that haven't already been validated are required to\n * have a \"key\" property assigned to it. Error statuses are cached so a warning\n * will only be shown once.\n *\n * @internal\n * @param {ReactElement} element Element that requires a key.\n * @param {*} parentType element's parent's type.\n */ function validateExplicitKey(element, parentType) {\n                        if (!element._store || element._store.validated || element.key != null) {\n                            return;\n                        }\n                        element._store.validated = true;\n                        var currentComponentErrorInfo = getCurrentComponentErrorInfo(parentType);\n                        if (ownerHasKeyUseWarning[currentComponentErrorInfo]) {\n                            return;\n                        }\n                        ownerHasKeyUseWarning[currentComponentErrorInfo] = true;\n                        // Usually the current owner is the offender, but if it accepts children as a\n                        // property, it may be the creator of the child that's responsible for\n                        // assigning it a key.\n                        var childOwner = \"\";\n                        if (element && element._owner && element._owner !== ReactCurrentOwner.current) {\n                            // Give the component that originally created this child.\n                            childOwner = \" It was passed a child from \" + getComponentName(element._owner) + \".\";\n                        }\n                        currentlyValidatingElement = element;\n                        {\n                            warning(false, 'Each child in an array or iterator should have a unique \"key\" prop.' + \"%s%s See https://fb.me/react-warning-keys for more information.%s\", currentComponentErrorInfo, childOwner, getStackAddendum());\n                        }\n                        currentlyValidatingElement = null;\n                    }\n                    /**\n * Ensure that every element either is passed in a static location, in an\n * array with an explicit keys property defined, or in an object literal\n * with valid key property.\n *\n * @internal\n * @param {ReactNode} node Statically passed child of any type.\n * @param {*} parentType node's parent's type.\n */ function validateChildKeys(node, parentType) {\n                        if (typeof node !== \"object\") {\n                            return;\n                        }\n                        if (Array.isArray(node)) {\n                            for(var i = 0; i < node.length; i++){\n                                var child = node[i];\n                                if (isValidElement(child)) {\n                                    validateExplicitKey(child, parentType);\n                                }\n                            }\n                        } else if (isValidElement(node)) {\n                            // This element was passed in a valid location.\n                            if (node._store) {\n                                node._store.validated = true;\n                            }\n                        } else if (node) {\n                            var iteratorFn = getIteratorFn(node);\n                            if (typeof iteratorFn === \"function\") {\n                                // Entry iterators used to provide implicit keys,\n                                // but now we print a separate warning for them later.\n                                if (iteratorFn !== node.entries) {\n                                    var iterator = iteratorFn.call(node);\n                                    var step = void 0;\n                                    while(!(step = iterator.next()).done){\n                                        if (isValidElement(step.value)) {\n                                            validateExplicitKey(step.value, parentType);\n                                        }\n                                    }\n                                }\n                            }\n                        }\n                    }\n                    /**\n * Given an element, validate that its props follow the propTypes definition,\n * provided by the type.\n *\n * @param {ReactElement} element\n */ function validatePropTypes(element) {\n                        var componentClass = element.type;\n                        if (typeof componentClass !== \"function\") {\n                            return;\n                        }\n                        var name = componentClass.displayName || componentClass.name;\n                        var propTypes = componentClass.propTypes;\n                        if (propTypes) {\n                            currentlyValidatingElement = element;\n                            checkPropTypes(propTypes, element.props, \"prop\", name, getStackAddendum);\n                            currentlyValidatingElement = null;\n                        } else if (componentClass.PropTypes !== undefined && !propTypesMisspellWarningShown) {\n                            propTypesMisspellWarningShown = true;\n                            warning(false, \"Component %s declared `PropTypes` instead of `propTypes`. Did you misspell the property assignment?\", name || \"Unknown\");\n                        }\n                        if (typeof componentClass.getDefaultProps === \"function\") {\n                            !componentClass.getDefaultProps.isReactClassApproved ? warning(false, \"getDefaultProps is only used on classic React.createClass \" + \"definitions. Use a static property named `defaultProps` instead.\") : void 0;\n                        }\n                    }\n                    /**\n * Given a fragment, validate that it can only be provided with fragment props\n * @param {ReactElement} fragment\n */ function validateFragmentProps(fragment) {\n                        currentlyValidatingElement = fragment;\n                        var keys = Object.keys(fragment.props);\n                        for(var i = 0; i < keys.length; i++){\n                            var key = keys[i];\n                            if (key !== \"children\" && key !== \"key\") {\n                                warning(false, \"Invalid prop `%s` supplied to `React.Fragment`. \" + \"React.Fragment can only have `key` and `children` props.%s\", key, getStackAddendum());\n                                break;\n                            }\n                        }\n                        if (fragment.ref !== null) {\n                            warning(false, \"Invalid attribute `ref` supplied to `React.Fragment`.%s\", getStackAddendum());\n                        }\n                        currentlyValidatingElement = null;\n                    }\n                    function createElementWithValidation(type, props, children) {\n                        var validType = isValidElementType(type);\n                        // We warn in this case but don't throw. We expect the element creation to\n                        // succeed and there will likely be errors in render.\n                        if (!validType) {\n                            var info = \"\";\n                            if (type === undefined || typeof type === \"object\" && type !== null && Object.keys(type).length === 0) {\n                                info += \" You likely forgot to export your component from the file \" + \"it's defined in, or you might have mixed up default and named imports.\";\n                            }\n                            var sourceInfo = getSourceInfoErrorAddendum(props);\n                            if (sourceInfo) {\n                                info += sourceInfo;\n                            } else {\n                                info += getDeclarationErrorAddendum();\n                            }\n                            info += getStackAddendum() || \"\";\n                            var typeString = void 0;\n                            if (type === null) {\n                                typeString = \"null\";\n                            } else if (Array.isArray(type)) {\n                                typeString = \"array\";\n                            } else {\n                                typeString = typeof type;\n                            }\n                            warning(false, \"React.createElement: type is invalid -- expected a string (for \" + \"built-in components) or a class/function (for composite \" + \"components) but got: %s.%s\", typeString, info);\n                        }\n                        var element = createElement.apply(this, arguments);\n                        // The result can be nullish if a mock or a custom function is used.\n                        // TODO: Drop this when these are no longer allowed as the type argument.\n                        if (element == null) {\n                            return element;\n                        }\n                        // Skip key warning if the type isn't valid since our key validation logic\n                        // doesn't expect a non-string/function type and can throw confusing errors.\n                        // We don't want exception behavior to differ between dev and prod.\n                        // (Rendering will throw with a helpful message and as soon as the type is\n                        // fixed, the key warnings will appear.)\n                        if (validType) {\n                            for(var i = 2; i < arguments.length; i++){\n                                validateChildKeys(arguments[i], type);\n                            }\n                        }\n                        if (type === REACT_FRAGMENT_TYPE) {\n                            validateFragmentProps(element);\n                        } else {\n                            validatePropTypes(element);\n                        }\n                        return element;\n                    }\n                    function createFactoryWithValidation(type) {\n                        var validatedFactory = createElementWithValidation.bind(null, type);\n                        validatedFactory.type = type;\n                        // Legacy hook: remove it\n                        {\n                            Object.defineProperty(validatedFactory, \"type\", {\n                                enumerable: false,\n                                get: function() {\n                                    lowPriorityWarning$1(false, \"Factory.type is deprecated. Access the class directly \" + \"before passing it to createFactory.\");\n                                    Object.defineProperty(this, \"type\", {\n                                        value: type\n                                    });\n                                    return type;\n                                }\n                            });\n                        }\n                        return validatedFactory;\n                    }\n                    function cloneElementWithValidation(element, props, children) {\n                        var newElement = cloneElement.apply(this, arguments);\n                        for(var i = 2; i < arguments.length; i++){\n                            validateChildKeys(arguments[i], newElement.type);\n                        }\n                        validatePropTypes(newElement);\n                        return newElement;\n                    }\n                    var React = {\n                        Children: {\n                            map: mapChildren,\n                            forEach: forEachChildren,\n                            count: countChildren,\n                            toArray: toArray,\n                            only: onlyChild\n                        },\n                        createRef: createRef,\n                        Component: Component,\n                        PureComponent: PureComponent,\n                        createContext: createContext,\n                        forwardRef: forwardRef,\n                        Fragment: REACT_FRAGMENT_TYPE,\n                        StrictMode: REACT_STRICT_MODE_TYPE,\n                        unstable_AsyncMode: REACT_ASYNC_MODE_TYPE,\n                        createElement: createElementWithValidation,\n                        cloneElement: cloneElementWithValidation,\n                        createFactory: createFactoryWithValidation,\n                        isValidElement: isValidElement,\n                        version: ReactVersion,\n                        __SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED: {\n                            ReactCurrentOwner: ReactCurrentOwner,\n                            // Used by renderers to avoid bundling object-assign twice in UMD bundles:\n                            assign: _assign\n                        }\n                    };\n                    {\n                        _assign(React.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED, {\n                            // These should not be included in production.\n                            ReactDebugCurrentFrame: ReactDebugCurrentFrame,\n                            // Shim for React DOM 16.0.0 which still destructured (but not used) this.\n                            // TODO: remove in React 17.0.\n                            ReactComponentTreeHook: {}\n                        });\n                    }\n                    var React$2 = Object.freeze({\n                        default: React\n                    });\n                    var React$3 = React$2 && React || React$2;\n                    // TODO: decide on the top-level export form.\n                    // This is hacky but makes it work with both Rollup and Jest.\n                    var react = React$3[\"default\"] ? React$3[\"default\"] : React$3;\n                    module1.exports = react;\n                })();\n            }\n        /***/ },\n        /* 11 */ /***/ function(module1, exports1, __nested_webpack_require_105995__) {\n            /**\n * Copyright (c) 2013-present, Facebook, Inc.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */ if (true) {\n                var REACT_ELEMENT_TYPE = typeof Symbol === \"function\" && Symbol.for && Symbol.for(\"react.element\") || 0xeac7;\n                var isValidElement = function(object) {\n                    return typeof object === \"object\" && object !== null && object.$$typeof === REACT_ELEMENT_TYPE;\n                };\n                // By explicitly using `prop-types` you are opting into new development behavior.\n                // http://fb.me/prop-types-in-prod\n                var throwOnDirectAccess = true;\n                module1.exports = __nested_webpack_require_105995__(12)(isValidElement, throwOnDirectAccess);\n            } else {}\n        /***/ },\n        /* 12 */ /***/ function(module1, exports1, __nested_webpack_require_107173__) {\n            \"use strict\";\n            /**\n * Copyright (c) 2013-present, Facebook, Inc.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */ var emptyFunction = __nested_webpack_require_107173__(1);\n            var invariant = __nested_webpack_require_107173__(0);\n            var warning = __nested_webpack_require_107173__(3);\n            var assign = __nested_webpack_require_107173__(2);\n            var ReactPropTypesSecret = __nested_webpack_require_107173__(4);\n            var checkPropTypes = __nested_webpack_require_107173__(6);\n            module1.exports = function(isValidElement, throwOnDirectAccess) {\n                /* global Symbol */ var ITERATOR_SYMBOL = typeof Symbol === \"function\" && Symbol.iterator;\n                var FAUX_ITERATOR_SYMBOL = \"@@iterator\"; // Before Symbol spec.\n                /**\n   * Returns the iterator method function contained on the iterable object.\n   *\n   * Be sure to invoke the function with the iterable as context:\n   *\n   *     var iteratorFn = getIteratorFn(myIterable);\n   *     if (iteratorFn) {\n   *       var iterator = iteratorFn.call(myIterable);\n   *       ...\n   *     }\n   *\n   * @param {?object} maybeIterable\n   * @return {?function}\n   */ function getIteratorFn(maybeIterable) {\n                    var iteratorFn = maybeIterable && (ITERATOR_SYMBOL && maybeIterable[ITERATOR_SYMBOL] || maybeIterable[FAUX_ITERATOR_SYMBOL]);\n                    if (typeof iteratorFn === \"function\") {\n                        return iteratorFn;\n                    }\n                }\n                /**\n   * Collection of methods that allow declaration and validation of props that are\n   * supplied to React components. Example usage:\n   *\n   *   var Props = require('ReactPropTypes');\n   *   var MyArticle = React.createClass({\n   *     propTypes: {\n   *       // An optional string prop named \"description\".\n   *       description: Props.string,\n   *\n   *       // A required enum prop named \"category\".\n   *       category: Props.oneOf(['News','Photos']).isRequired,\n   *\n   *       // A prop named \"dialog\" that requires an instance of Dialog.\n   *       dialog: Props.instanceOf(Dialog).isRequired\n   *     },\n   *     render: function() { ... }\n   *   });\n   *\n   * A more formal specification of how these methods are used:\n   *\n   *   type := array|bool|func|object|number|string|oneOf([...])|instanceOf(...)\n   *   decl := ReactPropTypes.{type}(.isRequired)?\n   *\n   * Each and every declaration produces a function with the same signature. This\n   * allows the creation of custom validation functions. For example:\n   *\n   *  var MyLink = React.createClass({\n   *    propTypes: {\n   *      // An optional string or URI prop named \"href\".\n   *      href: function(props, propName, componentName) {\n   *        var propValue = props[propName];\n   *        if (propValue != null && typeof propValue !== 'string' &&\n   *            !(propValue instanceof URI)) {\n   *          return new Error(\n   *            'Expected a string or an URI for ' + propName + ' in ' +\n   *            componentName\n   *          );\n   *        }\n   *      }\n   *    },\n   *    render: function() {...}\n   *  });\n   *\n   * @internal\n   */ var ANONYMOUS = \"<<anonymous>>\";\n                // Important!\n                // Keep this list in sync with production version in `./factoryWithThrowingShims.js`.\n                var ReactPropTypes = {\n                    array: createPrimitiveTypeChecker(\"array\"),\n                    bool: createPrimitiveTypeChecker(\"boolean\"),\n                    func: createPrimitiveTypeChecker(\"function\"),\n                    number: createPrimitiveTypeChecker(\"number\"),\n                    object: createPrimitiveTypeChecker(\"object\"),\n                    string: createPrimitiveTypeChecker(\"string\"),\n                    symbol: createPrimitiveTypeChecker(\"symbol\"),\n                    any: createAnyTypeChecker(),\n                    arrayOf: createArrayOfTypeChecker,\n                    element: createElementTypeChecker(),\n                    instanceOf: createInstanceTypeChecker,\n                    node: createNodeChecker(),\n                    objectOf: createObjectOfTypeChecker,\n                    oneOf: createEnumTypeChecker,\n                    oneOfType: createUnionTypeChecker,\n                    shape: createShapeTypeChecker,\n                    exact: createStrictShapeTypeChecker\n                };\n                /**\n   * inlined Object.is polyfill to avoid requiring consumers ship their own\n   * https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/is\n   */ /*eslint-disable no-self-compare*/ function is(x, y) {\n                    // SameValue algorithm\n                    if (x === y) {\n                        // Steps 1-5, 7-10\n                        // Steps 6.b-6.e: +0 != -0\n                        return x !== 0 || 1 / x === 1 / y;\n                    } else {\n                        // Step 6.a: NaN == NaN\n                        return x !== x && y !== y;\n                    }\n                }\n                /*eslint-enable no-self-compare*/ /**\n   * We use an Error-like object for backward compatibility as people may call\n   * PropTypes directly and inspect their output. However, we don't use real\n   * Errors anymore. We don't inspect their stack anyway, and creating them\n   * is prohibitively expensive if they are created too often, such as what\n   * happens in oneOfType() for any type before the one that matched.\n   */ function PropTypeError(message) {\n                    this.message = message;\n                    this.stack = \"\";\n                }\n                // Make `instanceof Error` still work for returned errors.\n                PropTypeError.prototype = Error.prototype;\n                function createChainableTypeChecker(validate) {\n                    if (true) {\n                        var manualPropTypeCallCache = {};\n                        var manualPropTypeWarningCount = 0;\n                    }\n                    function checkType(isRequired, props, propName, componentName, location, propFullName, secret) {\n                        componentName = componentName || ANONYMOUS;\n                        propFullName = propFullName || propName;\n                        if (secret !== ReactPropTypesSecret) {\n                            if (throwOnDirectAccess) {\n                                // New behavior only for users of `prop-types` package\n                                invariant(false, \"Calling PropTypes validators directly is not supported by the `prop-types` package. \" + \"Use `PropTypes.checkPropTypes()` to call them. \" + \"Read more at http://fb.me/use-check-prop-types\");\n                            } else if ( true && typeof console !== \"undefined\") {\n                                // Old behavior for people using React.PropTypes\n                                var cacheKey = componentName + \":\" + propName;\n                                if (!manualPropTypeCallCache[cacheKey] && // Avoid spamming the console because they are often not actionable except for lib authors\n                                manualPropTypeWarningCount < 3) {\n                                    warning(false, \"You are manually calling a React.PropTypes validation \" + \"function for the `%s` prop on `%s`. This is deprecated \" + \"and will throw in the standalone `prop-types` package. \" + \"You may be seeing this warning due to a third-party PropTypes \" + \"library. See https://fb.me/react-warning-dont-call-proptypes \" + \"for details.\", propFullName, componentName);\n                                    manualPropTypeCallCache[cacheKey] = true;\n                                    manualPropTypeWarningCount++;\n                                }\n                            }\n                        }\n                        if (props[propName] == null) {\n                            if (isRequired) {\n                                if (props[propName] === null) {\n                                    return new PropTypeError(\"The \" + location + \" `\" + propFullName + \"` is marked as required \" + (\"in `\" + componentName + \"`, but its value is `null`.\"));\n                                }\n                                return new PropTypeError(\"The \" + location + \" `\" + propFullName + \"` is marked as required in \" + (\"`\" + componentName + \"`, but its value is `undefined`.\"));\n                            }\n                            return null;\n                        } else {\n                            return validate(props, propName, componentName, location, propFullName);\n                        }\n                    }\n                    var chainedCheckType = checkType.bind(null, false);\n                    chainedCheckType.isRequired = checkType.bind(null, true);\n                    return chainedCheckType;\n                }\n                function createPrimitiveTypeChecker(expectedType) {\n                    function validate(props, propName, componentName, location, propFullName, secret) {\n                        var propValue = props[propName];\n                        var propType = getPropType(propValue);\n                        if (propType !== expectedType) {\n                            // `propValue` being instance of, say, date/regexp, pass the 'object'\n                            // check, but we can offer a more precise error message here rather than\n                            // 'of type `object`'.\n                            var preciseType = getPreciseType(propValue);\n                            return new PropTypeError(\"Invalid \" + location + \" `\" + propFullName + \"` of type \" + (\"`\" + preciseType + \"` supplied to `\" + componentName + \"`, expected \") + (\"`\" + expectedType + \"`.\"));\n                        }\n                        return null;\n                    }\n                    return createChainableTypeChecker(validate);\n                }\n                function createAnyTypeChecker() {\n                    return createChainableTypeChecker(emptyFunction.thatReturnsNull);\n                }\n                function createArrayOfTypeChecker(typeChecker) {\n                    function validate(props, propName, componentName, location, propFullName) {\n                        if (typeof typeChecker !== \"function\") {\n                            return new PropTypeError(\"Property `\" + propFullName + \"` of component `\" + componentName + \"` has invalid PropType notation inside arrayOf.\");\n                        }\n                        var propValue = props[propName];\n                        if (!Array.isArray(propValue)) {\n                            var propType = getPropType(propValue);\n                            return new PropTypeError(\"Invalid \" + location + \" `\" + propFullName + \"` of type \" + (\"`\" + propType + \"` supplied to `\" + componentName + \"`, expected an array.\"));\n                        }\n                        for(var i = 0; i < propValue.length; i++){\n                            var error = typeChecker(propValue, i, componentName, location, propFullName + \"[\" + i + \"]\", ReactPropTypesSecret);\n                            if (error instanceof Error) {\n                                return error;\n                            }\n                        }\n                        return null;\n                    }\n                    return createChainableTypeChecker(validate);\n                }\n                function createElementTypeChecker() {\n                    function validate(props, propName, componentName, location, propFullName) {\n                        var propValue = props[propName];\n                        if (!isValidElement(propValue)) {\n                            var propType = getPropType(propValue);\n                            return new PropTypeError(\"Invalid \" + location + \" `\" + propFullName + \"` of type \" + (\"`\" + propType + \"` supplied to `\" + componentName + \"`, expected a single ReactElement.\"));\n                        }\n                        return null;\n                    }\n                    return createChainableTypeChecker(validate);\n                }\n                function createInstanceTypeChecker(expectedClass) {\n                    function validate(props, propName, componentName, location, propFullName) {\n                        if (!(props[propName] instanceof expectedClass)) {\n                            var expectedClassName = expectedClass.name || ANONYMOUS;\n                            var actualClassName = getClassName(props[propName]);\n                            return new PropTypeError(\"Invalid \" + location + \" `\" + propFullName + \"` of type \" + (\"`\" + actualClassName + \"` supplied to `\" + componentName + \"`, expected \") + (\"instance of `\" + expectedClassName + \"`.\"));\n                        }\n                        return null;\n                    }\n                    return createChainableTypeChecker(validate);\n                }\n                function createEnumTypeChecker(expectedValues) {\n                    if (!Array.isArray(expectedValues)) {\n                         true ? warning(false, \"Invalid argument supplied to oneOf, expected an instance of array.\") : 0;\n                        return emptyFunction.thatReturnsNull;\n                    }\n                    function validate(props, propName, componentName, location, propFullName) {\n                        var propValue = props[propName];\n                        for(var i = 0; i < expectedValues.length; i++){\n                            if (is(propValue, expectedValues[i])) {\n                                return null;\n                            }\n                        }\n                        var valuesString = JSON.stringify(expectedValues);\n                        return new PropTypeError(\"Invalid \" + location + \" `\" + propFullName + \"` of value `\" + propValue + \"` \" + (\"supplied to `\" + componentName + \"`, expected one of \" + valuesString + \".\"));\n                    }\n                    return createChainableTypeChecker(validate);\n                }\n                function createObjectOfTypeChecker(typeChecker) {\n                    function validate(props, propName, componentName, location, propFullName) {\n                        if (typeof typeChecker !== \"function\") {\n                            return new PropTypeError(\"Property `\" + propFullName + \"` of component `\" + componentName + \"` has invalid PropType notation inside objectOf.\");\n                        }\n                        var propValue = props[propName];\n                        var propType = getPropType(propValue);\n                        if (propType !== \"object\") {\n                            return new PropTypeError(\"Invalid \" + location + \" `\" + propFullName + \"` of type \" + (\"`\" + propType + \"` supplied to `\" + componentName + \"`, expected an object.\"));\n                        }\n                        for(var key in propValue){\n                            if (propValue.hasOwnProperty(key)) {\n                                var error = typeChecker(propValue, key, componentName, location, propFullName + \".\" + key, ReactPropTypesSecret);\n                                if (error instanceof Error) {\n                                    return error;\n                                }\n                            }\n                        }\n                        return null;\n                    }\n                    return createChainableTypeChecker(validate);\n                }\n                function createUnionTypeChecker(arrayOfTypeCheckers) {\n                    if (!Array.isArray(arrayOfTypeCheckers)) {\n                         true ? warning(false, \"Invalid argument supplied to oneOfType, expected an instance of array.\") : 0;\n                        return emptyFunction.thatReturnsNull;\n                    }\n                    for(var i = 0; i < arrayOfTypeCheckers.length; i++){\n                        var checker = arrayOfTypeCheckers[i];\n                        if (typeof checker !== \"function\") {\n                            warning(false, \"Invalid argument supplied to oneOfType. Expected an array of check functions, but \" + \"received %s at index %s.\", getPostfixForTypeWarning(checker), i);\n                            return emptyFunction.thatReturnsNull;\n                        }\n                    }\n                    function validate(props, propName, componentName, location, propFullName) {\n                        for(var i = 0; i < arrayOfTypeCheckers.length; i++){\n                            var checker = arrayOfTypeCheckers[i];\n                            if (checker(props, propName, componentName, location, propFullName, ReactPropTypesSecret) == null) {\n                                return null;\n                            }\n                        }\n                        return new PropTypeError(\"Invalid \" + location + \" `\" + propFullName + \"` supplied to \" + (\"`\" + componentName + \"`.\"));\n                    }\n                    return createChainableTypeChecker(validate);\n                }\n                function createNodeChecker() {\n                    function validate(props, propName, componentName, location, propFullName) {\n                        if (!isNode(props[propName])) {\n                            return new PropTypeError(\"Invalid \" + location + \" `\" + propFullName + \"` supplied to \" + (\"`\" + componentName + \"`, expected a ReactNode.\"));\n                        }\n                        return null;\n                    }\n                    return createChainableTypeChecker(validate);\n                }\n                function createShapeTypeChecker(shapeTypes) {\n                    function validate(props, propName, componentName, location, propFullName) {\n                        var propValue = props[propName];\n                        var propType = getPropType(propValue);\n                        if (propType !== \"object\") {\n                            return new PropTypeError(\"Invalid \" + location + \" `\" + propFullName + \"` of type `\" + propType + \"` \" + (\"supplied to `\" + componentName + \"`, expected `object`.\"));\n                        }\n                        for(var key in shapeTypes){\n                            var checker = shapeTypes[key];\n                            if (!checker) {\n                                continue;\n                            }\n                            var error = checker(propValue, key, componentName, location, propFullName + \".\" + key, ReactPropTypesSecret);\n                            if (error) {\n                                return error;\n                            }\n                        }\n                        return null;\n                    }\n                    return createChainableTypeChecker(validate);\n                }\n                function createStrictShapeTypeChecker(shapeTypes) {\n                    function validate(props, propName, componentName, location, propFullName) {\n                        var propValue = props[propName];\n                        var propType = getPropType(propValue);\n                        if (propType !== \"object\") {\n                            return new PropTypeError(\"Invalid \" + location + \" `\" + propFullName + \"` of type `\" + propType + \"` \" + (\"supplied to `\" + componentName + \"`, expected `object`.\"));\n                        }\n                        // We need to check all keys in case some are required but missing from\n                        // props.\n                        var allKeys = assign({}, props[propName], shapeTypes);\n                        for(var key in allKeys){\n                            var checker = shapeTypes[key];\n                            if (!checker) {\n                                return new PropTypeError(\"Invalid \" + location + \" `\" + propFullName + \"` key `\" + key + \"` supplied to `\" + componentName + \"`.\" + \"\\nBad object: \" + JSON.stringify(props[propName], null, \"  \") + \"\\nValid keys: \" + JSON.stringify(Object.keys(shapeTypes), null, \"  \"));\n                            }\n                            var error = checker(propValue, key, componentName, location, propFullName + \".\" + key, ReactPropTypesSecret);\n                            if (error) {\n                                return error;\n                            }\n                        }\n                        return null;\n                    }\n                    return createChainableTypeChecker(validate);\n                }\n                function isNode(propValue) {\n                    switch(typeof propValue){\n                        case \"number\":\n                        case \"string\":\n                        case \"undefined\":\n                            return true;\n                        case \"boolean\":\n                            return !propValue;\n                        case \"object\":\n                            if (Array.isArray(propValue)) {\n                                return propValue.every(isNode);\n                            }\n                            if (propValue === null || isValidElement(propValue)) {\n                                return true;\n                            }\n                            var iteratorFn = getIteratorFn(propValue);\n                            if (iteratorFn) {\n                                var iterator = iteratorFn.call(propValue);\n                                var step;\n                                if (iteratorFn !== propValue.entries) {\n                                    while(!(step = iterator.next()).done){\n                                        if (!isNode(step.value)) {\n                                            return false;\n                                        }\n                                    }\n                                } else {\n                                    // Iterator will provide entry [k,v] tuples rather than values.\n                                    while(!(step = iterator.next()).done){\n                                        var entry = step.value;\n                                        if (entry) {\n                                            if (!isNode(entry[1])) {\n                                                return false;\n                                            }\n                                        }\n                                    }\n                                }\n                            } else {\n                                return false;\n                            }\n                            return true;\n                        default:\n                            return false;\n                    }\n                }\n                function isSymbol(propType, propValue) {\n                    // Native Symbol.\n                    if (propType === \"symbol\") {\n                        return true;\n                    }\n                    // 19.4.3.5 Symbol.prototype[@@toStringTag] === 'Symbol'\n                    if (propValue[\"@@toStringTag\"] === \"Symbol\") {\n                        return true;\n                    }\n                    // Fallback for non-spec compliant Symbols which are polyfilled.\n                    if (typeof Symbol === \"function\" && propValue instanceof Symbol) {\n                        return true;\n                    }\n                    return false;\n                }\n                // Equivalent of `typeof` but with special handling for array and regexp.\n                function getPropType(propValue) {\n                    var propType = typeof propValue;\n                    if (Array.isArray(propValue)) {\n                        return \"array\";\n                    }\n                    if (propValue instanceof RegExp) {\n                        // Old webkits (at least until Android 4.0) return 'function' rather than\n                        // 'object' for typeof a RegExp. We'll normalize this here so that /bla/\n                        // passes PropTypes.object.\n                        return \"object\";\n                    }\n                    if (isSymbol(propType, propValue)) {\n                        return \"symbol\";\n                    }\n                    return propType;\n                }\n                // This handles more types than `getPropType`. Only used for error messages.\n                // See `createPrimitiveTypeChecker`.\n                function getPreciseType(propValue) {\n                    if (typeof propValue === \"undefined\" || propValue === null) {\n                        return \"\" + propValue;\n                    }\n                    var propType = getPropType(propValue);\n                    if (propType === \"object\") {\n                        if (propValue instanceof Date) {\n                            return \"date\";\n                        } else if (propValue instanceof RegExp) {\n                            return \"regexp\";\n                        }\n                    }\n                    return propType;\n                }\n                // Returns a string that is postfixed to a warning about an invalid type.\n                // For example, \"undefined\" or \"of type array\"\n                function getPostfixForTypeWarning(value) {\n                    var type = getPreciseType(value);\n                    switch(type){\n                        case \"array\":\n                        case \"object\":\n                            return \"an \" + type;\n                        case \"boolean\":\n                        case \"date\":\n                        case \"regexp\":\n                            return \"a \" + type;\n                        default:\n                            return type;\n                    }\n                }\n                // Returns class name of the object, if any.\n                function getClassName(propValue) {\n                    if (!propValue.constructor || !propValue.constructor.name) {\n                        return ANONYMOUS;\n                    }\n                    return propValue.constructor.name;\n                }\n                ReactPropTypes.checkPropTypes = checkPropTypes;\n                ReactPropTypes.PropTypes = ReactPropTypes;\n                return ReactPropTypes;\n            };\n        /***/ },\n        /* 13 */ /***/ function(module1, exports1, __nested_webpack_require_133513__) {\n            \"use strict\";\n            /**\n * Copyright (c) 2013-present, Facebook, Inc.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */ var emptyFunction = __nested_webpack_require_133513__(1);\n            var invariant = __nested_webpack_require_133513__(0);\n            var ReactPropTypesSecret = __nested_webpack_require_133513__(4);\n            module1.exports = function() {\n                function shim(props, propName, componentName, location, propFullName, secret) {\n                    if (secret === ReactPropTypesSecret) {\n                        // It is still safe when called from React.\n                        return;\n                    }\n                    invariant(false, \"Calling PropTypes validators directly is not supported by the `prop-types` package. \" + \"Use PropTypes.checkPropTypes() to call them. \" + \"Read more at http://fb.me/use-check-prop-types\");\n                }\n                ;\n                shim.isRequired = shim;\n                function getShim() {\n                    return shim;\n                }\n                ;\n                // Important!\n                // Keep this list in sync with production version in `./factoryWithTypeCheckers.js`.\n                var ReactPropTypes = {\n                    array: shim,\n                    bool: shim,\n                    func: shim,\n                    number: shim,\n                    object: shim,\n                    string: shim,\n                    symbol: shim,\n                    any: shim,\n                    arrayOf: getShim,\n                    element: shim,\n                    instanceOf: getShim,\n                    node: shim,\n                    objectOf: getShim,\n                    oneOf: getShim,\n                    oneOfType: getShim,\n                    shape: getShim,\n                    exact: getShim\n                };\n                ReactPropTypes.checkPropTypes = emptyFunction;\n                ReactPropTypes.PropTypes = ReactPropTypes;\n                return ReactPropTypes;\n            };\n        /***/ },\n        /* 14 */ /***/ function(module1, exports1, __nested_webpack_require_135674__) {\n            \"use strict\";\n            Object.defineProperty(exports1, \"__esModule\", {\n                value: true\n            });\n            var _blank = __nested_webpack_require_135674__(15);\n            Object.defineProperty(exports1, \"blank\", {\n                enumerable: true,\n                get: function get() {\n                    return _interopRequireDefault(_blank).default;\n                }\n            });\n            var _loadingBalls = __nested_webpack_require_135674__(16);\n            Object.defineProperty(exports1, \"balls\", {\n                enumerable: true,\n                get: function get() {\n                    return _interopRequireDefault(_loadingBalls).default;\n                }\n            });\n            var _loadingBars = __nested_webpack_require_135674__(17);\n            Object.defineProperty(exports1, \"bars\", {\n                enumerable: true,\n                get: function get() {\n                    return _interopRequireDefault(_loadingBars).default;\n                }\n            });\n            var _loadingBubbles = __nested_webpack_require_135674__(18);\n            Object.defineProperty(exports1, \"bubbles\", {\n                enumerable: true,\n                get: function get() {\n                    return _interopRequireDefault(_loadingBubbles).default;\n                }\n            });\n            var _loadingCubes = __nested_webpack_require_135674__(19);\n            Object.defineProperty(exports1, \"cubes\", {\n                enumerable: true,\n                get: function get() {\n                    return _interopRequireDefault(_loadingCubes).default;\n                }\n            });\n            var _loadingCylon = __nested_webpack_require_135674__(20);\n            Object.defineProperty(exports1, \"cylon\", {\n                enumerable: true,\n                get: function get() {\n                    return _interopRequireDefault(_loadingCylon).default;\n                }\n            });\n            var _loadingSpin = __nested_webpack_require_135674__(21);\n            Object.defineProperty(exports1, \"spin\", {\n                enumerable: true,\n                get: function get() {\n                    return _interopRequireDefault(_loadingSpin).default;\n                }\n            });\n            var _loadingSpinningBubbles = __nested_webpack_require_135674__(22);\n            Object.defineProperty(exports1, \"spinningBubbles\", {\n                enumerable: true,\n                get: function get() {\n                    return _interopRequireDefault(_loadingSpinningBubbles).default;\n                }\n            });\n            var _loadingSpokes = __nested_webpack_require_135674__(23);\n            Object.defineProperty(exports1, \"spokes\", {\n                enumerable: true,\n                get: function get() {\n                    return _interopRequireDefault(_loadingSpokes).default;\n                }\n            });\n            function _interopRequireDefault(obj) {\n                return obj && obj.__esModule ? obj : {\n                    default: obj\n                };\n            }\n        /***/ },\n        /* 15 */ /***/ function(module1, exports1) {\n            module1.exports = '<svg class=\"icon-blank\" xmlns=\"http://www.w3.org/2000/svg\" viewBox=\"0 0 32 32\"></svg>\\n';\n        /***/ },\n        /* 16 */ /***/ function(module1, exports1) {\n            module1.exports = '<svg class=\"icon-loading\" xmlns=\"http://www.w3.org/2000/svg\" viewBox=\"0 0 32 32\">\\n  <path transform=\"translate(-8 0)\" d=\"M4 12 A4 4 0 0 0 4 20 A4 4 0 0 0 4 12\"> \\n    <animateTransform attributeName=\"transform\" type=\"translate\" values=\"-8 0; 2 0; 2 0;\" dur=\"0.8s\" repeatCount=\"indefinite\" begin=\"0\" keytimes=\"0;.25;1\" keySplines=\"0.2 0.2 0.4 0.8;0.2 0.6 0.4 0.8\" calcMode=\"spline\"  />\\n  </path>\\n  <path transform=\"translate(2 0)\" d=\"M4 12 A4 4 0 0 0 4 20 A4 4 0 0 0 4 12\"> \\n    <animateTransform attributeName=\"transform\" type=\"translate\" values=\"2 0; 12 0; 12 0;\" dur=\"0.8s\" repeatCount=\"indefinite\" begin=\"0\" keytimes=\"0;.35;1\" keySplines=\"0.2 0.2 0.4 0.8;0.2 0.6 0.4 0.8\" calcMode=\"spline\"  />\\n  </path>\\n  <path transform=\"translate(12 0)\" d=\"M4 12 A4 4 0 0 0 4 20 A4 4 0 0 0 4 12\"> \\n    <animateTransform attributeName=\"transform\" type=\"translate\" values=\"12 0; 22 0; 22 0;\" dur=\"0.8s\" repeatCount=\"indefinite\" begin=\"0\" keytimes=\"0;.45;1\" keySplines=\"0.2 0.2 0.4 0.8;0.2 0.6 0.4 0.8\" calcMode=\"spline\"  />\\n  </path>\\n  <path transform=\"translate(24 0)\" d=\"M4 12 A4 4 0 0 0 4 20 A4 4 0 0 0 4 12\"> \\n    <animateTransform attributeName=\"transform\" type=\"translate\" values=\"22 0; 32 0; 32 0;\" dur=\"0.8s\" repeatCount=\"indefinite\" begin=\"0\" keytimes=\"0;.55;1\" keySplines=\"0.2 0.2 0.4 0.8;0.2 0.6 0.4 0.8\" calcMode=\"spline\"  />\\n  </path>\\n</svg>\\n';\n        /***/ },\n        /* 17 */ /***/ function(module1, exports1) {\n            module1.exports = '<svg xmlns=\"http://www.w3.org/2000/svg\" viewBox=\"0 0 32 32\">\\n  <path transform=\"translate(2)\" d=\"M0 12 V20 H4 V12z\"> \\n    <animate attributeName=\"d\" values=\"M0 12 V20 H4 V12z; M0 4 V28 H4 V4z; M0 12 V20 H4 V12z; M0 12 V20 H4 V12z\" dur=\"1.2s\" repeatCount=\"indefinite\" begin=\"0\" keytimes=\"0;.2;.5;1\" keySplines=\"0.2 0.2 0.4 0.8;0.2 0.6 0.4 0.8;0.2 0.8 0.4 0.8\" calcMode=\"spline\"  />\\n  </path>\\n  <path transform=\"translate(8)\" d=\"M0 12 V20 H4 V12z\">\\n    <animate attributeName=\"d\" values=\"M0 12 V20 H4 V12z; M0 4 V28 H4 V4z; M0 12 V20 H4 V12z; M0 12 V20 H4 V12z\" dur=\"1.2s\" repeatCount=\"indefinite\" begin=\"0.2\" keytimes=\"0;.2;.5;1\" keySplines=\"0.2 0.2 0.4 0.8;0.2 0.6 0.4 0.8;0.2 0.8 0.4 0.8\" calcMode=\"spline\"  />\\n  </path>\\n  <path transform=\"translate(14)\" d=\"M0 12 V20 H4 V12z\">\\n    <animate attributeName=\"d\" values=\"M0 12 V20 H4 V12z; M0 4 V28 H4 V4z; M0 12 V20 H4 V12z; M0 12 V20 H4 V12z\" dur=\"1.2s\" repeatCount=\"indefinite\" begin=\"0.4\" keytimes=\"0;.2;.5;1\" keySplines=\"0.2 0.2 0.4 0.8;0.2 0.6 0.4 0.8;0.2 0.8 0.4 0.8\" calcMode=\"spline\" />\\n  </path>\\n  <path transform=\"translate(20)\" d=\"M0 12 V20 H4 V12z\">\\n    <animate attributeName=\"d\" values=\"M0 12 V20 H4 V12z; M0 4 V28 H4 V4z; M0 12 V20 H4 V12z; M0 12 V20 H4 V12z\" dur=\"1.2s\" repeatCount=\"indefinite\" begin=\"0.6\" keytimes=\"0;.2;.5;1\" keySplines=\"0.2 0.2 0.4 0.8;0.2 0.6 0.4 0.8;0.2 0.8 0.4 0.8\" calcMode=\"spline\" />\\n  </path>\\n  <path transform=\"translate(26)\" d=\"M0 12 V20 H4 V12z\">\\n    <animate attributeName=\"d\" values=\"M0 12 V20 H4 V12z; M0 4 V28 H4 V4z; M0 12 V20 H4 V12z; M0 12 V20 H4 V12z\" dur=\"1.2s\" repeatCount=\"indefinite\" begin=\"0.8\" keytimes=\"0;.2;.5;1\" keySplines=\"0.2 0.2 0.4 0.8;0.2 0.6 0.4 0.8;0.2 0.8 0.4 0.8\" calcMode=\"spline\" />\\n  </path>\\n</svg>\\n';\n        /***/ },\n        /* 18 */ /***/ function(module1, exports1) {\n            module1.exports = '<svg xmlns=\"http://www.w3.org/2000/svg\" viewBox=\"0 0 32 32\">\\n  <circle transform=\"translate(8 0)\" cx=\"0\" cy=\"16\" r=\"0\"> \\n    <animate attributeName=\"r\" values=\"0; 4; 0; 0\" dur=\"1.2s\" repeatCount=\"indefinite\" begin=\"0\"\\n      keytimes=\"0;0.2;0.7;1\" keySplines=\"0.2 0.2 0.4 0.8;0.2 0.6 0.4 0.8;0.2 0.6 0.4 0.8\" calcMode=\"spline\" />\\n  </circle>\\n  <circle transform=\"translate(16 0)\" cx=\"0\" cy=\"16\" r=\"0\"> \\n    <animate attributeName=\"r\" values=\"0; 4; 0; 0\" dur=\"1.2s\" repeatCount=\"indefinite\" begin=\"0.3\"\\n      keytimes=\"0;0.2;0.7;1\" keySplines=\"0.2 0.2 0.4 0.8;0.2 0.6 0.4 0.8;0.2 0.6 0.4 0.8\" calcMode=\"spline\" />\\n  </circle>\\n  <circle transform=\"translate(24 0)\" cx=\"0\" cy=\"16\" r=\"0\"> \\n    <animate attributeName=\"r\" values=\"0; 4; 0; 0\" dur=\"1.2s\" repeatCount=\"indefinite\" begin=\"0.6\"\\n      keytimes=\"0;0.2;0.7;1\" keySplines=\"0.2 0.2 0.4 0.8;0.2 0.6 0.4 0.8;0.2 0.6 0.4 0.8\" calcMode=\"spline\" />\\n  </circle>\\n</svg>\\n';\n        /***/ },\n        /* 19 */ /***/ function(module1, exports1) {\n            module1.exports = '<svg xmlns=\"http://www.w3.org/2000/svg\" viewBox=\"0 0 32 32\">\\n  <path transform=\"translate(-8 0)\" d=\"M0 12 V20 H8 V12z\"> \\n    <animateTransform attributeName=\"transform\" type=\"translate\" values=\"-8 0; 2 0; 2 0;\" dur=\"0.8s\" repeatCount=\"indefinite\" begin=\"0\" keytimes=\"0;.25;1\" keySplines=\"0.2 0.2 0.4 0.8;0.2 0.6 0.4 0.8\" calcMode=\"spline\"  />\\n  </path>\\n  <path transform=\"translate(2 0)\" d=\"M0 12 V20 H8 V12z\"> \\n    <animateTransform attributeName=\"transform\" type=\"translate\" values=\"2 0; 12 0; 12 0;\" dur=\"0.8s\" repeatCount=\"indefinite\" begin=\"0\" keytimes=\"0;.35;1\" keySplines=\"0.2 0.2 0.4 0.8;0.2 0.6 0.4 0.8\" calcMode=\"spline\"  />\\n  </path>\\n  <path transform=\"translate(12 0)\" d=\"M0 12 V20 H8 V12z\"> \\n    <animateTransform attributeName=\"transform\" type=\"translate\" values=\"12 0; 22 0; 22 0;\" dur=\"0.8s\" repeatCount=\"indefinite\" begin=\"0\" keytimes=\"0;.45;1\" keySplines=\"0.2 0.2 0.4 0.8;0.2 0.6 0.4 0.8\" calcMode=\"spline\"  />\\n  </path>\\n  <path transform=\"translate(24 0)\" d=\"M0 12 V20 H8 V12z\"> \\n    <animateTransform attributeName=\"transform\" type=\"translate\" values=\"22 0; 32 0; 32 0;\" dur=\"0.8s\" repeatCount=\"indefinite\" begin=\"0\" keytimes=\"0;.55;1\" keySplines=\"0.2 0.2 0.4 0.8;0.2 0.6 0.4 0.8\" calcMode=\"spline\"  />\\n  </path>\\n</svg>\\n';\n        /***/ },\n        /* 20 */ /***/ function(module1, exports1) {\n            module1.exports = '<svg xmlns=\"http://www.w3.org/2000/svg\" viewBox=\"0 0 32 32\">\\n  <path transform=\"translate(0 0)\" d=\"M0 12 V20 H4 V12z\">\\n    <animateTransform attributeName=\"transform\" type=\"translate\" values=\"0 0; 28 0; 0 0; 0 0\" dur=\"1.5s\" begin=\"0\" repeatCount=\"indefinite\" keytimes=\"0;0.3;0.6;1\" keySplines=\"0.2 0.2 0.4 0.8;0.2 0.2 0.4 0.8;0.2 0.2 0.4 0.8\" calcMode=\"spline\" />\\n  </path>\\n  <path opacity=\"0.5\" transform=\"translate(0 0)\" d=\"M0 12 V20 H4 V12z\">\\n    <animateTransform attributeName=\"transform\" type=\"translate\" values=\"0 0; 28 0; 0 0; 0 0\" dur=\"1.5s\" begin=\"0.1s\" repeatCount=\"indefinite\" keytimes=\"0;0.3;0.6;1\" keySplines=\"0.2 0.2 0.4 0.8;0.2 0.2 0.4 0.8;0.2 0.2 0.4 0.8\" calcMode=\"spline\" />\\n  </path>\\n  <path opacity=\"0.25\" transform=\"translate(0 0)\" d=\"M0 12 V20 H4 V12z\">\\n    <animateTransform attributeName=\"transform\" type=\"translate\" values=\"0 0; 28 0; 0 0; 0 0\" dur=\"1.5s\" begin=\"0.2s\" repeatCount=\"indefinite\" keytimes=\"0;0.3;0.6;1\" keySplines=\"0.2 0.2 0.4 0.8;0.2 0.2 0.4 0.8;0.2 0.2 0.4 0.8\" calcMode=\"spline\" />\\n  </path>\\n</svg>\\n';\n        /***/ },\n        /* 21 */ /***/ function(module1, exports1) {\n            module1.exports = '<svg xmlns=\"http://www.w3.org/2000/svg\" viewBox=\"0 0 32 32\">\\n  <path opacity=\".25\" d=\"M16 0 A16 16 0 0 0 16 32 A16 16 0 0 0 16 0 M16 4 A12 12 0 0 1 16 28 A12 12 0 0 1 16 4\"/>\\n  <path d=\"M16 0 A16 16 0 0 1 32 16 L28 16 A12 12 0 0 0 16 4z\">\\n    <animateTransform attributeName=\"transform\" type=\"rotate\" from=\"0 16 16\" to=\"360 16 16\" dur=\"0.8s\" repeatCount=\"indefinite\" />\\n  </path>\\n</svg>\\n';\n        /***/ },\n        /* 22 */ /***/ function(module1, exports1) {\n            module1.exports = '<svg xmlns=\"http://www.w3.org/2000/svg\" viewBox=\"0 0 32 32\">\\n  <circle cx=\"16\" cy=\"3\" r=\"0\">\\n    <animate attributeName=\"r\" values=\"0;3;0;0\" dur=\"1s\" repeatCount=\"indefinite\" begin=\"0\" keySplines=\"0.2 0.2 0.4 0.8;0.2 0.2 0.4 0.8;0.2 0.2 0.4 0.8\" calcMode=\"spline\" />\\n  </circle>\\n  <circle transform=\"rotate(45 16 16)\" cx=\"16\" cy=\"3\" r=\"0\">\\n    <animate attributeName=\"r\" values=\"0;3;0;0\" dur=\"1s\" repeatCount=\"indefinite\" begin=\"0.125s\" keySplines=\"0.2 0.2 0.4 0.8;0.2 0.2 0.4 0.8;0.2 0.2 0.4 0.8\" calcMode=\"spline\" />\\n  </circle>\\n  <circle transform=\"rotate(90 16 16)\" cx=\"16\" cy=\"3\" r=\"0\">\\n    <animate attributeName=\"r\" values=\"0;3;0;0\" dur=\"1s\" repeatCount=\"indefinite\" begin=\"0.25s\" keySplines=\"0.2 0.2 0.4 0.8;0.2 0.2 0.4 0.8;0.2 0.2 0.4 0.8\" calcMode=\"spline\" />\\n  </circle>\\n  <circle transform=\"rotate(135 16 16)\" cx=\"16\" cy=\"3\" r=\"0\">\\n    <animate attributeName=\"r\" values=\"0;3;0;0\" dur=\"1s\" repeatCount=\"indefinite\" begin=\"0.375s\" keySplines=\"0.2 0.2 0.4 0.8;0.2 0.2 0.4 0.8;0.2 0.2 0.4 0.8\" calcMode=\"spline\" />\\n  </circle>\\n  <circle transform=\"rotate(180 16 16)\" cx=\"16\" cy=\"3\" r=\"0\">\\n    <animate attributeName=\"r\" values=\"0;3;0;0\" dur=\"1s\" repeatCount=\"indefinite\" begin=\"0.5s\" keySplines=\"0.2 0.2 0.4 0.8;0.2 0.2 0.4 0.8;0.2 0.2 0.4 0.8\" calcMode=\"spline\" />\\n  </circle>\\n  <circle transform=\"rotate(225 16 16)\" cx=\"16\" cy=\"3\" r=\"0\">\\n    <animate attributeName=\"r\" values=\"0;3;0;0\" dur=\"1s\" repeatCount=\"indefinite\" begin=\"0.625s\" keySplines=\"0.2 0.2 0.4 0.8;0.2 0.2 0.4 0.8;0.2 0.2 0.4 0.8\" calcMode=\"spline\" />\\n  </circle>\\n  <circle transform=\"rotate(270 16 16)\" cx=\"16\" cy=\"3\" r=\"0\">\\n    <animate attributeName=\"r\" values=\"0;3;0;0\" dur=\"1s\" repeatCount=\"indefinite\" begin=\"0.75s\" keySplines=\"0.2 0.2 0.4 0.8;0.2 0.2 0.4 0.8;0.2 0.2 0.4 0.8\" calcMode=\"spline\" />\\n  </circle>\\n  <circle transform=\"rotate(315 16 16)\" cx=\"16\" cy=\"3\" r=\"0\">\\n    <animate attributeName=\"r\" values=\"0;3;0;0\" dur=\"1s\" repeatCount=\"indefinite\" begin=\"0.875s\" keySplines=\"0.2 0.2 0.4 0.8;0.2 0.2 0.4 0.8;0.2 0.2 0.4 0.8\" calcMode=\"spline\" />\\n  </circle>\\n  <circle transform=\"rotate(180 16 16)\" cx=\"16\" cy=\"3\" r=\"0\">\\n    <animate attributeName=\"r\" values=\"0;3;0;0\" dur=\"1s\" repeatCount=\"indefinite\" begin=\"0.5s\" keySplines=\"0.2 0.2 0.4 0.8;0.2 0.2 0.4 0.8;0.2 0.2 0.4 0.8\" calcMode=\"spline\" />\\n  </circle>\\n</svg>\\n';\n        /***/ },\n        /* 23 */ /***/ function(module1, exports1) {\n            module1.exports = '<svg id=\"loading\" xmlns=\"http://www.w3.org/2000/svg\" viewBox=\"0 0 32 32\">\\n  <path opacity=\".1\" d=\"M14 0 H18 V8 H14 z\" transform=\"rotate(0 16 16)\">\\n    <animate attributeName=\"opacity\" from=\"1\" to=\".1\" dur=\"1s\" repeatCount=\"indefinite\" begin=\"0\"/>\\n  </path>\\n  <path opacity=\".1\" d=\"M14 0 H18 V8 H14 z\" transform=\"rotate(45 16 16)\">\\n    <animate attributeName=\"opacity\" from=\"1\" to=\".1\" dur=\"1s\" repeatCount=\"indefinite\" begin=\"0.125s\"/>\\n  </path>\\n  <path opacity=\".1\" d=\"M14 0 H18 V8 H14 z\" transform=\"rotate(90 16 16)\">\\n    <animate attributeName=\"opacity\" from=\"1\" to=\".1\" dur=\"1s\" repeatCount=\"indefinite\" begin=\"0.25s\"/>\\n  </path>\\n  <path opacity=\".1\" d=\"M14 0 H18 V8 H14 z\" transform=\"rotate(135 16 16)\">\\n    <animate attributeName=\"opacity\" from=\"1\" to=\".1\" dur=\"1s\" repeatCount=\"indefinite\" begin=\"0.375s\"/>\\n  </path>\\n  <path opacity=\".1\" d=\"M14 0 H18 V8 H14 z\" transform=\"rotate(180 16 16)\">\\n    <animate attributeName=\"opacity\" from=\"1\" to=\".1\" dur=\"1s\" repeatCount=\"indefinite\" begin=\"0.5s\"/>\\n  </path>\\n  <path opacity=\".1\" d=\"M14 0 H18 V8 H14 z\" transform=\"rotate(225 16 16)\">\\n    <animate attributeName=\"opacity\" from=\"1\" to=\".1\" dur=\"1s\" repeatCount=\"indefinite\" begin=\"0.675s\"/>\\n  </path>\\n  <path opacity=\".1\" d=\"M14 0 H18 V8 H14 z\" transform=\"rotate(270 16 16)\">\\n    <animate attributeName=\"opacity\" from=\"1\" to=\".1\" dur=\"1s\" repeatCount=\"indefinite\" begin=\"0.75s\"/>\\n  </path>\\n  <path opacity=\".1\" d=\"M14 0 H18 V8 H14 z\" transform=\"rotate(315 16 16)\">\\n    <animate attributeName=\"opacity\" from=\"1\" to=\".1\" dur=\"1s\" repeatCount=\"indefinite\" begin=\"0.875s\"/>\\n  </path>\\n</svg>\\n';\n        /***/ }\n    ]);\n}); //# sourceMappingURL=react-loading.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvcmVhY3QtbG9hZGluZy9kaXN0L3JlYWN0LWxvYWRpbmcuanMiLCJtYXBwaW5ncyI6IkFBQUMsVUFBU0EsaUNBQWlDQyxJQUFJLEVBQUVDLE9BQU87SUFDdkQsSUFBRyxJQUFpRCxFQUNuREUsT0FBT0QsT0FBTyxHQUFHRDtTQUNiLEVBS3dCQTtBQUM5QixHQUFHLE9BQU9LLFNBQVMsY0FBY0EsT0FBTyxJQUFJLEVBQUU7SUFDOUMsT0FBZ0IsTUFBSCxHQUFJLFNBQVNDLE9BQU87UUFDakMsTUFBTSxHQUFJLG1CQUFtQjtRQUM3QixNQUFNLEdBQUksSUFBSUMsbUJBQW1CLENBQUM7UUFDbEMsTUFBTSxHQUNOLE1BQU0sR0FBSSx1QkFBdUI7UUFDakMsTUFBTSxHQUFJLFNBQVNDLDhCQUFtQkEsQ0FBQ0MsUUFBUTtZQUMvQyxNQUFNLEdBQ04sTUFBTSxHQUFLLDhCQUE4QjtZQUN6QyxNQUFNLEdBQUssSUFBR0YsZ0JBQWdCLENBQUNFLFNBQVMsRUFBRTtnQkFDMUMsTUFBTSxHQUFNLE9BQU9GLGdCQUFnQixDQUFDRSxTQUFTLENBQUNSLE9BQU87WUFDckQsTUFBTSxHQUFLO1lBQ1gsTUFBTSxHQUFLLGtEQUFrRDtZQUM3RCxNQUFNLEdBQUssSUFBSUMsVUFBU0ssZ0JBQWdCLENBQUNFLFNBQVMsR0FBRztnQkFDckQsTUFBTSxHQUFNQyxHQUFHRDtnQkFDZixNQUFNLEdBQU1FLEdBQUc7Z0JBQ2YsTUFBTSxHQUFNVixTQUFTLENBQUM7WUFDWDtZQUNYLE1BQU0sR0FDTixNQUFNLEdBQUssOEJBQThCO1lBQ3pDLE1BQU0sR0FBS0ssT0FBTyxDQUFDRyxTQUFTLENBQUNHLElBQUksQ0FBQ1YsUUFBT0QsT0FBTyxFQUFFQyxTQUFRQSxRQUFPRCxPQUFPLEVBQUVPLDhCQUFtQkE7WUFDN0YsTUFBTSxHQUNOLE1BQU0sR0FBSyw0QkFBNEI7WUFDdkMsTUFBTSxHQUFLTixRQUFPUyxDQUFDLEdBQUc7WUFDdEIsTUFBTSxHQUNOLE1BQU0s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LEdBQUksU0FBU0MsT0FBTSxFQUFFRCxRQUFPO1lBRS9CQyxRQUFPRCxPQUFPLEdBQUc7UUFFakIsR0FBRyxHQUFHO1FBQ04sTUFBTSxHQUNOLEdBQUcsR0FBSSxTQUFTQyxPQUFNLEVBQUVELFFBQU87WUFFL0JDLFFBQU9ELE9BQU8sR0FBRztRQUVqQixHQUFHLEdBQUc7UUFDTixNQUFNLEdBQ04sR0FBRyxHQUFJLFNBQVNDLE9BQU0sRUFBRUQsUUFBTztZQUUvQkMsUUFBT0QsT0FBTyxHQUFHO1FBRWpCLEdBQUcsR0FBRztRQUNOLE1BQU0sR0FDTixHQUFHLEdBQUksU0FBU0MsT0FBTSxFQUFFRCxRQUFPO1lBRS9CQyxRQUFPRCxPQUFPLEdBQUc7UUFFakIsR0FBRyxHQUFHO0tBQ0k7QUFDVixJQUNBLHlDQUF5QyIsInNvdXJjZXMiOlsid2VicGFjazovL2xhbmRpbmcvLi9ub2RlX21vZHVsZXMvcmVhY3QtbG9hZGluZy9kaXN0L3JlYWN0LWxvYWRpbmcuanM/NWMwNSJdLCJzb3VyY2VzQ29udGVudCI6WyIoZnVuY3Rpb24gd2VicGFja1VuaXZlcnNhbE1vZHVsZURlZmluaXRpb24ocm9vdCwgZmFjdG9yeSkge1xuXHRpZih0eXBlb2YgZXhwb3J0cyA9PT0gJ29iamVjdCcgJiYgdHlwZW9mIG1vZHVsZSA9PT0gJ29iamVjdCcpXG5cdFx0bW9kdWxlLmV4cG9ydHMgPSBmYWN0b3J5KCk7XG5cdGVsc2UgaWYodHlwZW9mIGRlZmluZSA9PT0gJ2Z1bmN0aW9uJyAmJiBkZWZpbmUuYW1kKVxuXHRcdGRlZmluZShbXSwgZmFjdG9yeSk7XG5cdGVsc2UgaWYodHlwZW9mIGV4cG9ydHMgPT09ICdvYmplY3QnKVxuXHRcdGV4cG9ydHNbXCJMb2FkaW5nXCJdID0gZmFjdG9yeSgpO1xuXHRlbHNlXG5cdFx0cm9vdFtcIkxvYWRpbmdcIl0gPSBmYWN0b3J5KCk7XG59KSh0eXBlb2Ygc2VsZiAhPT0gJ3VuZGVmaW5lZCcgPyBzZWxmIDogdGhpcywgZnVuY3Rpb24oKSB7XG5yZXR1cm4gLyoqKioqKi8gKGZ1bmN0aW9uKG1vZHVsZXMpIHsgLy8gd2VicGFja0Jvb3RzdHJhcFxuLyoqKioqKi8gXHQvLyBUaGUgbW9kdWxlIGNhY2hlXG4vKioqKioqLyBcdHZhciBpbnN0YWxsZWRNb2R1bGVzID0ge307XG4vKioqKioqL1xuLyoqKioqKi8gXHQvLyBUaGUgcmVxdWlyZSBmdW5jdGlvblxuLyoqKioqKi8gXHRmdW5jdGlvbiBfX3dlYnBhY2tfcmVxdWlyZV9fKG1vZHVsZUlkKSB7XG4vKioqKioqL1xuLyoqKioqKi8gXHRcdC8vIENoZWNrIGlmIG1vZHVsZSBpcyBpbiBjYWNoZVxuLyoqKioqKi8gXHRcdGlmKGluc3RhbGxlZE1vZHVsZXNbbW9kdWxlSWRdKSB7XG4vKioqKioqLyBcdFx0XHRyZXR1cm4gaW5zdGFsbGVkTW9kdWxlc1ttb2R1bGVJZF0uZXhwb3J0cztcbi8qKioqKiovIFx0XHR9XG4vKioqKioqLyBcdFx0Ly8gQ3JlYXRlIGEgbmV3IG1vZHVsZSAoYW5kIHB1dCBpdCBpbnRvIHRoZSBjYWNoZSlcbi8qKioqKiovIFx0XHR2YXIgbW9kdWxlID0gaW5zdGFsbGVkTW9kdWxlc1ttb2R1bGVJZF0gPSB7XG4vKioqKioqLyBcdFx0XHRpOiBtb2R1bGVJZCxcbi8qKioqKiovIFx0XHRcdGw6IGZhbHNlLFxuLyoqKioqKi8gXHRcdFx0ZXhwb3J0czoge31cbi8qKioqKiovIFx0XHR9O1xuLyoqKioqKi9cbi8qKioqKiovIFx0XHQvLyBFeGVjdXRlIHRoZSBtb2R1bGUgZnVuY3Rpb25cbi8qKioqKiovIFx0XHRtb2R1bGVzW21vZHVsZUlkXS5jYWxsKG1vZHVsZS5leHBvcnRzLCBtb2R1bGUsIG1vZHVsZS5leHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKTtcbi8qKioqKiovXG4vKioqKioqLyBcdFx0Ly8gRmxhZyB0aGUgbW9kdWxlIGFzIGxvYWRlZFxuLyoqKioqKi8gXHRcdG1vZHVsZS5sID0gdHJ1ZTtcbi8qKioqKiovXG4vKioqKioqLyBcdFx0Ly8gUmV0dXJuIHRoZSBleHBvcnRzIG9mIHRoZSBtb2R1bGVcbi8qKioqKiovIFx0XHRyZXR1cm4gbW9kdWxlLmV4cG9ydHM7XG4vKioqKioqLyBcdH1cbi8qKioqKiovXG4vKioqKioqL1xuLyoqKioqKi8gXHQvLyBleHBvc2UgdGhlIG1vZHVsZXMgb2JqZWN0IChfX3dlYnBhY2tfbW9kdWxlc19fKVxuLyoqKioqKi8gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLm0gPSBtb2R1bGVzO1xuLyoqKioqKi9cbi8qKioqKiovIFx0Ly8gZXhwb3NlIHRoZSBtb2R1bGUgY2FjaGVcbi8qKioqKiovIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5jID0gaW5zdGFsbGVkTW9kdWxlcztcbi8qKioqKiovXG4vKioqKioqLyBcdC8vIGRlZmluZSBnZXR0ZXIgZnVuY3Rpb24gZm9yIGhhcm1vbnkgZXhwb3J0c1xuLyoqKioqKi8gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLmQgPSBmdW5jdGlvbihleHBvcnRzLCBuYW1lLCBnZXR0ZXIpIHtcbi8qKioqKiovIFx0XHRpZighX193ZWJwYWNrX3JlcXVpcmVfXy5vKGV4cG9ydHMsIG5hbWUpKSB7XG4vKioqKioqLyBcdFx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgbmFtZSwge1xuLyoqKioqKi8gXHRcdFx0XHRjb25maWd1cmFibGU6IGZhbHNlLFxuLyoqKioqKi8gXHRcdFx0XHRlbnVtZXJhYmxlOiB0cnVlLFxuLyoqKioqKi8gXHRcdFx0XHRnZXQ6IGdldHRlclxuLyoqKioqKi8gXHRcdFx0fSk7XG4vKioqKioqLyBcdFx0fVxuLyoqKioqKi8gXHR9O1xuLyoqKioqKi9cbi8qKioqKiovIFx0Ly8gZ2V0RGVmYXVsdEV4cG9ydCBmdW5jdGlvbiBmb3IgY29tcGF0aWJpbGl0eSB3aXRoIG5vbi1oYXJtb255IG1vZHVsZXNcbi8qKioqKiovIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5uID0gZnVuY3Rpb24obW9kdWxlKSB7XG4vKioqKioqLyBcdFx0dmFyIGdldHRlciA9IG1vZHVsZSAmJiBtb2R1bGUuX19lc01vZHVsZSA/XG4vKioqKioqLyBcdFx0XHRmdW5jdGlvbiBnZXREZWZhdWx0KCkgeyByZXR1cm4gbW9kdWxlWydkZWZhdWx0J107IH0gOlxuLyoqKioqKi8gXHRcdFx0ZnVuY3Rpb24gZ2V0TW9kdWxlRXhwb3J0cygpIHsgcmV0dXJuIG1vZHVsZTsgfTtcbi8qKioqKiovIFx0XHRfX3dlYnBhY2tfcmVxdWlyZV9fLmQoZ2V0dGVyLCAnYScsIGdldHRlcik7XG4vKioqKioqLyBcdFx0cmV0dXJuIGdldHRlcjtcbi8qKioqKiovIFx0fTtcbi8qKioqKiovXG4vKioqKioqLyBcdC8vIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbFxuLyoqKioqKi8gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLm8gPSBmdW5jdGlvbihvYmplY3QsIHByb3BlcnR5KSB7IHJldHVybiBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob2JqZWN0LCBwcm9wZXJ0eSk7IH07XG4vKioqKioqL1xuLyoqKioqKi8gXHQvLyBfX3dlYnBhY2tfcHVibGljX3BhdGhfX1xuLyoqKioqKi8gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLnAgPSBcIi9cIjtcbi8qKioqKiovXG4vKioqKioqLyBcdC8vIExvYWQgZW50cnkgbW9kdWxlIGFuZCByZXR1cm4gZXhwb3J0c1xuLyoqKioqKi8gXHRyZXR1cm4gX193ZWJwYWNrX3JlcXVpcmVfXyhfX3dlYnBhY2tfcmVxdWlyZV9fLnMgPSA3KTtcbi8qKioqKiovIH0pXG4vKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyoqKioqKi8gKFtcbi8qIDAgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG4vKipcbiAqIENvcHlyaWdodCAoYykgMjAxMy1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICpcbiAqL1xuXG5cblxuLyoqXG4gKiBVc2UgaW52YXJpYW50KCkgdG8gYXNzZXJ0IHN0YXRlIHdoaWNoIHlvdXIgcHJvZ3JhbSBhc3N1bWVzIHRvIGJlIHRydWUuXG4gKlxuICogUHJvdmlkZSBzcHJpbnRmLXN0eWxlIGZvcm1hdCAob25seSAlcyBpcyBzdXBwb3J0ZWQpIGFuZCBhcmd1bWVudHNcbiAqIHRvIHByb3ZpZGUgaW5mb3JtYXRpb24gYWJvdXQgd2hhdCBicm9rZSBhbmQgd2hhdCB5b3Ugd2VyZVxuICogZXhwZWN0aW5nLlxuICpcbiAqIFRoZSBpbnZhcmlhbnQgbWVzc2FnZSB3aWxsIGJlIHN0cmlwcGVkIGluIHByb2R1Y3Rpb24sIGJ1dCB0aGUgaW52YXJpYW50XG4gKiB3aWxsIHJlbWFpbiB0byBlbnN1cmUgbG9naWMgZG9lcyBub3QgZGlmZmVyIGluIHByb2R1Y3Rpb24uXG4gKi9cblxudmFyIHZhbGlkYXRlRm9ybWF0ID0gZnVuY3Rpb24gdmFsaWRhdGVGb3JtYXQoZm9ybWF0KSB7fTtcblxuaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgdmFsaWRhdGVGb3JtYXQgPSBmdW5jdGlvbiB2YWxpZGF0ZUZvcm1hdChmb3JtYXQpIHtcbiAgICBpZiAoZm9ybWF0ID09PSB1bmRlZmluZWQpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignaW52YXJpYW50IHJlcXVpcmVzIGFuIGVycm9yIG1lc3NhZ2UgYXJndW1lbnQnKTtcbiAgICB9XG4gIH07XG59XG5cbmZ1bmN0aW9uIGludmFyaWFudChjb25kaXRpb24sIGZvcm1hdCwgYSwgYiwgYywgZCwgZSwgZikge1xuICB2YWxpZGF0ZUZvcm1hdChmb3JtYXQpO1xuXG4gIGlmICghY29uZGl0aW9uKSB7XG4gICAgdmFyIGVycm9yO1xuICAgIGlmIChmb3JtYXQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgZXJyb3IgPSBuZXcgRXJyb3IoJ01pbmlmaWVkIGV4Y2VwdGlvbiBvY2N1cnJlZDsgdXNlIHRoZSBub24tbWluaWZpZWQgZGV2IGVudmlyb25tZW50ICcgKyAnZm9yIHRoZSBmdWxsIGVycm9yIG1lc3NhZ2UgYW5kIGFkZGl0aW9uYWwgaGVscGZ1bCB3YXJuaW5ncy4nKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdmFyIGFyZ3MgPSBbYSwgYiwgYywgZCwgZSwgZl07XG4gICAgICB2YXIgYXJnSW5kZXggPSAwO1xuICAgICAgZXJyb3IgPSBuZXcgRXJyb3IoZm9ybWF0LnJlcGxhY2UoLyVzL2csIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIGFyZ3NbYXJnSW5kZXgrK107XG4gICAgICB9KSk7XG4gICAgICBlcnJvci5uYW1lID0gJ0ludmFyaWFudCBWaW9sYXRpb24nO1xuICAgIH1cblxuICAgIGVycm9yLmZyYW1lc1RvUG9wID0gMTsgLy8gd2UgZG9uJ3QgY2FyZSBhYm91dCBpbnZhcmlhbnQncyBvd24gZnJhbWVcbiAgICB0aHJvdyBlcnJvcjtcbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGludmFyaWFudDtcblxuLyoqKi8gfSksXG4vKiAxICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuXG5cbi8qKlxuICogQ29weXJpZ2h0IChjKSAyMDEzLXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKlxuICogXG4gKi9cblxuZnVuY3Rpb24gbWFrZUVtcHR5RnVuY3Rpb24oYXJnKSB7XG4gIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIGFyZztcbiAgfTtcbn1cblxuLyoqXG4gKiBUaGlzIGZ1bmN0aW9uIGFjY2VwdHMgYW5kIGRpc2NhcmRzIGlucHV0czsgaXQgaGFzIG5vIHNpZGUgZWZmZWN0cy4gVGhpcyBpc1xuICogcHJpbWFyaWx5IHVzZWZ1bCBpZGlvbWF0aWNhbGx5IGZvciBvdmVycmlkYWJsZSBmdW5jdGlvbiBlbmRwb2ludHMgd2hpY2hcbiAqIGFsd2F5cyBuZWVkIHRvIGJlIGNhbGxhYmxlLCBzaW5jZSBKUyBsYWNrcyBhIG51bGwtY2FsbCBpZGlvbSBhbGEgQ29jb2EuXG4gKi9cbnZhciBlbXB0eUZ1bmN0aW9uID0gZnVuY3Rpb24gZW1wdHlGdW5jdGlvbigpIHt9O1xuXG5lbXB0eUZ1bmN0aW9uLnRoYXRSZXR1cm5zID0gbWFrZUVtcHR5RnVuY3Rpb247XG5lbXB0eUZ1bmN0aW9uLnRoYXRSZXR1cm5zRmFsc2UgPSBtYWtlRW1wdHlGdW5jdGlvbihmYWxzZSk7XG5lbXB0eUZ1bmN0aW9uLnRoYXRSZXR1cm5zVHJ1ZSA9IG1ha2VFbXB0eUZ1bmN0aW9uKHRydWUpO1xuZW1wdHlGdW5jdGlvbi50aGF0UmV0dXJuc051bGwgPSBtYWtlRW1wdHlGdW5jdGlvbihudWxsKTtcbmVtcHR5RnVuY3Rpb24udGhhdFJldHVybnNUaGlzID0gZnVuY3Rpb24gKCkge1xuICByZXR1cm4gdGhpcztcbn07XG5lbXB0eUZ1bmN0aW9uLnRoYXRSZXR1cm5zQXJndW1lbnQgPSBmdW5jdGlvbiAoYXJnKSB7XG4gIHJldHVybiBhcmc7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IGVtcHR5RnVuY3Rpb247XG5cbi8qKiovIH0pLFxuLyogMiAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcbi8qXG5vYmplY3QtYXNzaWduXG4oYykgU2luZHJlIFNvcmh1c1xuQGxpY2Vuc2UgTUlUXG4qL1xuXG5cbi8qIGVzbGludC1kaXNhYmxlIG5vLXVudXNlZC12YXJzICovXG52YXIgZ2V0T3duUHJvcGVydHlTeW1ib2xzID0gT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scztcbnZhciBoYXNPd25Qcm9wZXJ0eSA9IE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHk7XG52YXIgcHJvcElzRW51bWVyYWJsZSA9IE9iamVjdC5wcm90b3R5cGUucHJvcGVydHlJc0VudW1lcmFibGU7XG5cbmZ1bmN0aW9uIHRvT2JqZWN0KHZhbCkge1xuXHRpZiAodmFsID09PSBudWxsIHx8IHZhbCA9PT0gdW5kZWZpbmVkKSB7XG5cdFx0dGhyb3cgbmV3IFR5cGVFcnJvcignT2JqZWN0LmFzc2lnbiBjYW5ub3QgYmUgY2FsbGVkIHdpdGggbnVsbCBvciB1bmRlZmluZWQnKTtcblx0fVxuXG5cdHJldHVybiBPYmplY3QodmFsKTtcbn1cblxuZnVuY3Rpb24gc2hvdWxkVXNlTmF0aXZlKCkge1xuXHR0cnkge1xuXHRcdGlmICghT2JqZWN0LmFzc2lnbikge1xuXHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdH1cblxuXHRcdC8vIERldGVjdCBidWdneSBwcm9wZXJ0eSBlbnVtZXJhdGlvbiBvcmRlciBpbiBvbGRlciBWOCB2ZXJzaW9ucy5cblxuXHRcdC8vIGh0dHBzOi8vYnVncy5jaHJvbWl1bS5vcmcvcC92OC9pc3N1ZXMvZGV0YWlsP2lkPTQxMThcblx0XHR2YXIgdGVzdDEgPSBuZXcgU3RyaW5nKCdhYmMnKTsgIC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tbmV3LXdyYXBwZXJzXG5cdFx0dGVzdDFbNV0gPSAnZGUnO1xuXHRcdGlmIChPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyh0ZXN0MSlbMF0gPT09ICc1Jykge1xuXHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdH1cblxuXHRcdC8vIGh0dHBzOi8vYnVncy5jaHJvbWl1bS5vcmcvcC92OC9pc3N1ZXMvZGV0YWlsP2lkPTMwNTZcblx0XHR2YXIgdGVzdDIgPSB7fTtcblx0XHRmb3IgKHZhciBpID0gMDsgaSA8IDEwOyBpKyspIHtcblx0XHRcdHRlc3QyWydfJyArIFN0cmluZy5mcm9tQ2hhckNvZGUoaSldID0gaTtcblx0XHR9XG5cdFx0dmFyIG9yZGVyMiA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKHRlc3QyKS5tYXAoZnVuY3Rpb24gKG4pIHtcblx0XHRcdHJldHVybiB0ZXN0MltuXTtcblx0XHR9KTtcblx0XHRpZiAob3JkZXIyLmpvaW4oJycpICE9PSAnMDEyMzQ1Njc4OScpIHtcblx0XHRcdHJldHVybiBmYWxzZTtcblx0XHR9XG5cblx0XHQvLyBodHRwczovL2J1Z3MuY2hyb21pdW0ub3JnL3AvdjgvaXNzdWVzL2RldGFpbD9pZD0zMDU2XG5cdFx0dmFyIHRlc3QzID0ge307XG5cdFx0J2FiY2RlZmdoaWprbG1ub3BxcnN0Jy5zcGxpdCgnJykuZm9yRWFjaChmdW5jdGlvbiAobGV0dGVyKSB7XG5cdFx0XHR0ZXN0M1tsZXR0ZXJdID0gbGV0dGVyO1xuXHRcdH0pO1xuXHRcdGlmIChPYmplY3Qua2V5cyhPYmplY3QuYXNzaWduKHt9LCB0ZXN0MykpLmpvaW4oJycpICE9PVxuXHRcdFx0XHQnYWJjZGVmZ2hpamtsbW5vcHFyc3QnKSB7XG5cdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIHRydWU7XG5cdH0gY2F0Y2ggKGVycikge1xuXHRcdC8vIFdlIGRvbid0IGV4cGVjdCBhbnkgb2YgdGhlIGFib3ZlIHRvIHRocm93LCBidXQgYmV0dGVyIHRvIGJlIHNhZmUuXG5cdFx0cmV0dXJuIGZhbHNlO1xuXHR9XG59XG5cbm1vZHVsZS5leHBvcnRzID0gc2hvdWxkVXNlTmF0aXZlKCkgPyBPYmplY3QuYXNzaWduIDogZnVuY3Rpb24gKHRhcmdldCwgc291cmNlKSB7XG5cdHZhciBmcm9tO1xuXHR2YXIgdG8gPSB0b09iamVjdCh0YXJnZXQpO1xuXHR2YXIgc3ltYm9scztcblxuXHRmb3IgKHZhciBzID0gMTsgcyA8IGFyZ3VtZW50cy5sZW5ndGg7IHMrKykge1xuXHRcdGZyb20gPSBPYmplY3QoYXJndW1lbnRzW3NdKTtcblxuXHRcdGZvciAodmFyIGtleSBpbiBmcm9tKSB7XG5cdFx0XHRpZiAoaGFzT3duUHJvcGVydHkuY2FsbChmcm9tLCBrZXkpKSB7XG5cdFx0XHRcdHRvW2tleV0gPSBmcm9tW2tleV07XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0aWYgKGdldE93blByb3BlcnR5U3ltYm9scykge1xuXHRcdFx0c3ltYm9scyA9IGdldE93blByb3BlcnR5U3ltYm9scyhmcm9tKTtcblx0XHRcdGZvciAodmFyIGkgPSAwOyBpIDwgc3ltYm9scy5sZW5ndGg7IGkrKykge1xuXHRcdFx0XHRpZiAocHJvcElzRW51bWVyYWJsZS5jYWxsKGZyb20sIHN5bWJvbHNbaV0pKSB7XG5cdFx0XHRcdFx0dG9bc3ltYm9sc1tpXV0gPSBmcm9tW3N5bWJvbHNbaV1dO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG5cblx0cmV0dXJuIHRvO1xufTtcblxuXG4vKioqLyB9KSxcbi8qIDMgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG4vKipcbiAqIENvcHlyaWdodCAoYykgMjAxNC1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICpcbiAqL1xuXG5cblxudmFyIGVtcHR5RnVuY3Rpb24gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDEpO1xuXG4vKipcbiAqIFNpbWlsYXIgdG8gaW52YXJpYW50IGJ1dCBvbmx5IGxvZ3MgYSB3YXJuaW5nIGlmIHRoZSBjb25kaXRpb24gaXMgbm90IG1ldC5cbiAqIFRoaXMgY2FuIGJlIHVzZWQgdG8gbG9nIGlzc3VlcyBpbiBkZXZlbG9wbWVudCBlbnZpcm9ubWVudHMgaW4gY3JpdGljYWxcbiAqIHBhdGhzLiBSZW1vdmluZyB0aGUgbG9nZ2luZyBjb2RlIGZvciBwcm9kdWN0aW9uIGVudmlyb25tZW50cyB3aWxsIGtlZXAgdGhlXG4gKiBzYW1lIGxvZ2ljIGFuZCBmb2xsb3cgdGhlIHNhbWUgY29kZSBwYXRocy5cbiAqL1xuXG52YXIgd2FybmluZyA9IGVtcHR5RnVuY3Rpb247XG5cbmlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gIHZhciBwcmludFdhcm5pbmcgPSBmdW5jdGlvbiBwcmludFdhcm5pbmcoZm9ybWF0KSB7XG4gICAgZm9yICh2YXIgX2xlbiA9IGFyZ3VtZW50cy5sZW5ndGgsIGFyZ3MgPSBBcnJheShfbGVuID4gMSA/IF9sZW4gLSAxIDogMCksIF9rZXkgPSAxOyBfa2V5IDwgX2xlbjsgX2tleSsrKSB7XG4gICAgICBhcmdzW19rZXkgLSAxXSA9IGFyZ3VtZW50c1tfa2V5XTtcbiAgICB9XG5cbiAgICB2YXIgYXJnSW5kZXggPSAwO1xuICAgIHZhciBtZXNzYWdlID0gJ1dhcm5pbmc6ICcgKyBmb3JtYXQucmVwbGFjZSgvJXMvZywgZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIGFyZ3NbYXJnSW5kZXgrK107XG4gICAgfSk7XG4gICAgaWYgKHR5cGVvZiBjb25zb2xlICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgY29uc29sZS5lcnJvcihtZXNzYWdlKTtcbiAgICB9XG4gICAgdHJ5IHtcbiAgICAgIC8vIC0tLSBXZWxjb21lIHRvIGRlYnVnZ2luZyBSZWFjdCAtLS1cbiAgICAgIC8vIFRoaXMgZXJyb3Igd2FzIHRocm93biBhcyBhIGNvbnZlbmllbmNlIHNvIHRoYXQgeW91IGNhbiB1c2UgdGhpcyBzdGFja1xuICAgICAgLy8gdG8gZmluZCB0aGUgY2FsbHNpdGUgdGhhdCBjYXVzZWQgdGhpcyB3YXJuaW5nIHRvIGZpcmUuXG4gICAgICB0aHJvdyBuZXcgRXJyb3IobWVzc2FnZSk7XG4gICAgfSBjYXRjaCAoeCkge31cbiAgfTtcblxuICB3YXJuaW5nID0gZnVuY3Rpb24gd2FybmluZyhjb25kaXRpb24sIGZvcm1hdCkge1xuICAgIGlmIChmb3JtYXQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdgd2FybmluZyhjb25kaXRpb24sIGZvcm1hdCwgLi4uYXJncylgIHJlcXVpcmVzIGEgd2FybmluZyAnICsgJ21lc3NhZ2UgYXJndW1lbnQnKTtcbiAgICB9XG5cbiAgICBpZiAoZm9ybWF0LmluZGV4T2YoJ0ZhaWxlZCBDb21wb3NpdGUgcHJvcFR5cGU6ICcpID09PSAwKSB7XG4gICAgICByZXR1cm47IC8vIElnbm9yZSBDb21wb3NpdGVDb21wb25lbnQgcHJvcHR5cGUgY2hlY2suXG4gICAgfVxuXG4gICAgaWYgKCFjb25kaXRpb24pIHtcbiAgICAgIGZvciAodmFyIF9sZW4yID0gYXJndW1lbnRzLmxlbmd0aCwgYXJncyA9IEFycmF5KF9sZW4yID4gMiA/IF9sZW4yIC0gMiA6IDApLCBfa2V5MiA9IDI7IF9rZXkyIDwgX2xlbjI7IF9rZXkyKyspIHtcbiAgICAgICAgYXJnc1tfa2V5MiAtIDJdID0gYXJndW1lbnRzW19rZXkyXTtcbiAgICAgIH1cblxuICAgICAgcHJpbnRXYXJuaW5nLmFwcGx5KHVuZGVmaW5lZCwgW2Zvcm1hdF0uY29uY2F0KGFyZ3MpKTtcbiAgICB9XG4gIH07XG59XG5cbm1vZHVsZS5leHBvcnRzID0gd2FybmluZztcblxuLyoqKi8gfSksXG4vKiA0ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuLyoqXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTMtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqL1xuXG5cblxudmFyIFJlYWN0UHJvcFR5cGVzU2VjcmV0ID0gJ1NFQ1JFVF9ET19OT1RfUEFTU19USElTX09SX1lPVV9XSUxMX0JFX0ZJUkVEJztcblxubW9kdWxlLmV4cG9ydHMgPSBSZWFjdFByb3BUeXBlc1NlY3JldDtcblxuXG4vKioqLyB9KSxcbi8qIDUgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG4vKipcbiAqIENvcHlyaWdodCAoYykgMjAxMy1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICpcbiAqL1xuXG5cblxudmFyIGVtcHR5T2JqZWN0ID0ge307XG5cbmlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gIE9iamVjdC5mcmVlemUoZW1wdHlPYmplY3QpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGVtcHR5T2JqZWN0O1xuXG4vKioqLyB9KSxcbi8qIDYgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG4vKipcbiAqIENvcHlyaWdodCAoYykgMjAxMy1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICovXG5cblxuXG5pZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICB2YXIgaW52YXJpYW50ID0gX193ZWJwYWNrX3JlcXVpcmVfXygwKTtcbiAgdmFyIHdhcm5pbmcgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDMpO1xuICB2YXIgUmVhY3RQcm9wVHlwZXNTZWNyZXQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDQpO1xuICB2YXIgbG9nZ2VkVHlwZUZhaWx1cmVzID0ge307XG59XG5cbi8qKlxuICogQXNzZXJ0IHRoYXQgdGhlIHZhbHVlcyBtYXRjaCB3aXRoIHRoZSB0eXBlIHNwZWNzLlxuICogRXJyb3IgbWVzc2FnZXMgYXJlIG1lbW9yaXplZCBhbmQgd2lsbCBvbmx5IGJlIHNob3duIG9uY2UuXG4gKlxuICogQHBhcmFtIHtvYmplY3R9IHR5cGVTcGVjcyBNYXAgb2YgbmFtZSB0byBhIFJlYWN0UHJvcFR5cGVcbiAqIEBwYXJhbSB7b2JqZWN0fSB2YWx1ZXMgUnVudGltZSB2YWx1ZXMgdGhhdCBuZWVkIHRvIGJlIHR5cGUtY2hlY2tlZFxuICogQHBhcmFtIHtzdHJpbmd9IGxvY2F0aW9uIGUuZy4gXCJwcm9wXCIsIFwiY29udGV4dFwiLCBcImNoaWxkIGNvbnRleHRcIlxuICogQHBhcmFtIHtzdHJpbmd9IGNvbXBvbmVudE5hbWUgTmFtZSBvZiB0aGUgY29tcG9uZW50IGZvciBlcnJvciBtZXNzYWdlcy5cbiAqIEBwYXJhbSB7P0Z1bmN0aW9ufSBnZXRTdGFjayBSZXR1cm5zIHRoZSBjb21wb25lbnQgc3RhY2suXG4gKiBAcHJpdmF0ZVxuICovXG5mdW5jdGlvbiBjaGVja1Byb3BUeXBlcyh0eXBlU3BlY3MsIHZhbHVlcywgbG9jYXRpb24sIGNvbXBvbmVudE5hbWUsIGdldFN0YWNrKSB7XG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgZm9yICh2YXIgdHlwZVNwZWNOYW1lIGluIHR5cGVTcGVjcykge1xuICAgICAgaWYgKHR5cGVTcGVjcy5oYXNPd25Qcm9wZXJ0eSh0eXBlU3BlY05hbWUpKSB7XG4gICAgICAgIHZhciBlcnJvcjtcbiAgICAgICAgLy8gUHJvcCB0eXBlIHZhbGlkYXRpb24gbWF5IHRocm93LiBJbiBjYXNlIHRoZXkgZG8sIHdlIGRvbid0IHdhbnQgdG9cbiAgICAgICAgLy8gZmFpbCB0aGUgcmVuZGVyIHBoYXNlIHdoZXJlIGl0IGRpZG4ndCBmYWlsIGJlZm9yZS4gU28gd2UgbG9nIGl0LlxuICAgICAgICAvLyBBZnRlciB0aGVzZSBoYXZlIGJlZW4gY2xlYW5lZCB1cCwgd2UnbGwgbGV0IHRoZW0gdGhyb3cuXG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgLy8gVGhpcyBpcyBpbnRlbnRpb25hbGx5IGFuIGludmFyaWFudCB0aGF0IGdldHMgY2F1Z2h0LiBJdCdzIHRoZSBzYW1lXG4gICAgICAgICAgLy8gYmVoYXZpb3IgYXMgd2l0aG91dCB0aGlzIHN0YXRlbWVudCBleGNlcHQgd2l0aCBhIGJldHRlciBtZXNzYWdlLlxuICAgICAgICAgIGludmFyaWFudCh0eXBlb2YgdHlwZVNwZWNzW3R5cGVTcGVjTmFtZV0gPT09ICdmdW5jdGlvbicsICclczogJXMgdHlwZSBgJXNgIGlzIGludmFsaWQ7IGl0IG11c3QgYmUgYSBmdW5jdGlvbiwgdXN1YWxseSBmcm9tICcgKyAndGhlIGBwcm9wLXR5cGVzYCBwYWNrYWdlLCBidXQgcmVjZWl2ZWQgYCVzYC4nLCBjb21wb25lbnROYW1lIHx8ICdSZWFjdCBjbGFzcycsIGxvY2F0aW9uLCB0eXBlU3BlY05hbWUsIHR5cGVvZiB0eXBlU3BlY3NbdHlwZVNwZWNOYW1lXSk7XG4gICAgICAgICAgZXJyb3IgPSB0eXBlU3BlY3NbdHlwZVNwZWNOYW1lXSh2YWx1ZXMsIHR5cGVTcGVjTmFtZSwgY29tcG9uZW50TmFtZSwgbG9jYXRpb24sIG51bGwsIFJlYWN0UHJvcFR5cGVzU2VjcmV0KTtcbiAgICAgICAgfSBjYXRjaCAoZXgpIHtcbiAgICAgICAgICBlcnJvciA9IGV4O1xuICAgICAgICB9XG4gICAgICAgIHdhcm5pbmcoIWVycm9yIHx8IGVycm9yIGluc3RhbmNlb2YgRXJyb3IsICclczogdHlwZSBzcGVjaWZpY2F0aW9uIG9mICVzIGAlc2AgaXMgaW52YWxpZDsgdGhlIHR5cGUgY2hlY2tlciAnICsgJ2Z1bmN0aW9uIG11c3QgcmV0dXJuIGBudWxsYCBvciBhbiBgRXJyb3JgIGJ1dCByZXR1cm5lZCBhICVzLiAnICsgJ1lvdSBtYXkgaGF2ZSBmb3Jnb3R0ZW4gdG8gcGFzcyBhbiBhcmd1bWVudCB0byB0aGUgdHlwZSBjaGVja2VyICcgKyAnY3JlYXRvciAoYXJyYXlPZiwgaW5zdGFuY2VPZiwgb2JqZWN0T2YsIG9uZU9mLCBvbmVPZlR5cGUsIGFuZCAnICsgJ3NoYXBlIGFsbCByZXF1aXJlIGFuIGFyZ3VtZW50KS4nLCBjb21wb25lbnROYW1lIHx8ICdSZWFjdCBjbGFzcycsIGxvY2F0aW9uLCB0eXBlU3BlY05hbWUsIHR5cGVvZiBlcnJvcik7XG4gICAgICAgIGlmIChlcnJvciBpbnN0YW5jZW9mIEVycm9yICYmICEoZXJyb3IubWVzc2FnZSBpbiBsb2dnZWRUeXBlRmFpbHVyZXMpKSB7XG4gICAgICAgICAgLy8gT25seSBtb25pdG9yIHRoaXMgZmFpbHVyZSBvbmNlIGJlY2F1c2UgdGhlcmUgdGVuZHMgdG8gYmUgYSBsb3Qgb2YgdGhlXG4gICAgICAgICAgLy8gc2FtZSBlcnJvci5cbiAgICAgICAgICBsb2dnZWRUeXBlRmFpbHVyZXNbZXJyb3IubWVzc2FnZV0gPSB0cnVlO1xuXG4gICAgICAgICAgdmFyIHN0YWNrID0gZ2V0U3RhY2sgPyBnZXRTdGFjaygpIDogJyc7XG5cbiAgICAgICAgICB3YXJuaW5nKGZhbHNlLCAnRmFpbGVkICVzIHR5cGU6ICVzJXMnLCBsb2NhdGlvbiwgZXJyb3IubWVzc2FnZSwgc3RhY2sgIT0gbnVsbCA/IHN0YWNrIDogJycpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0gY2hlY2tQcm9wVHlwZXM7XG5cblxuLyoqKi8gfSksXG4vKiA3ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuXG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5cbnZhciBfZXh0ZW5kcyA9IE9iamVjdC5hc3NpZ24gfHwgZnVuY3Rpb24gKHRhcmdldCkgeyBmb3IgKHZhciBpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykgeyB2YXIgc291cmNlID0gYXJndW1lbnRzW2ldOyBmb3IgKHZhciBrZXkgaW4gc291cmNlKSB7IGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoc291cmNlLCBrZXkpKSB7IHRhcmdldFtrZXldID0gc291cmNlW2tleV07IH0gfSB9IHJldHVybiB0YXJnZXQ7IH07XG5cbnZhciBfY3JlYXRlQ2xhc3MgPSBmdW5jdGlvbiAoKSB7IGZ1bmN0aW9uIGRlZmluZVByb3BlcnRpZXModGFyZ2V0LCBwcm9wcykgeyBmb3IgKHZhciBpID0gMDsgaSA8IHByb3BzLmxlbmd0aDsgaSsrKSB7IHZhciBkZXNjcmlwdG9yID0gcHJvcHNbaV07IGRlc2NyaXB0b3IuZW51bWVyYWJsZSA9IGRlc2NyaXB0b3IuZW51bWVyYWJsZSB8fCBmYWxzZTsgZGVzY3JpcHRvci5jb25maWd1cmFibGUgPSB0cnVlOyBpZiAoXCJ2YWx1ZVwiIGluIGRlc2NyaXB0b3IpIGRlc2NyaXB0b3Iud3JpdGFibGUgPSB0cnVlOyBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBkZXNjcmlwdG9yLmtleSwgZGVzY3JpcHRvcik7IH0gfSByZXR1cm4gZnVuY3Rpb24gKENvbnN0cnVjdG9yLCBwcm90b1Byb3BzLCBzdGF0aWNQcm9wcykgeyBpZiAocHJvdG9Qcm9wcykgZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvci5wcm90b3R5cGUsIHByb3RvUHJvcHMpOyBpZiAoc3RhdGljUHJvcHMpIGRlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IsIHN0YXRpY1Byb3BzKTsgcmV0dXJuIENvbnN0cnVjdG9yOyB9OyB9KCk7XG5cbnZhciBfcmVhY3QgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDgpO1xuXG52YXIgX3JlYWN0MiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX3JlYWN0KTtcblxudmFyIF9wcm9wVHlwZXMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDExKTtcblxudmFyIF9wcm9wVHlwZXMyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfcHJvcFR5cGVzKTtcblxudmFyIF9zdmcgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDE0KTtcblxudmFyIHN2Z1NvdXJjZXMgPSBfaW50ZXJvcFJlcXVpcmVXaWxkY2FyZChfc3ZnKTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlV2lsZGNhcmQob2JqKSB7IGlmIChvYmogJiYgb2JqLl9fZXNNb2R1bGUpIHsgcmV0dXJuIG9iajsgfSBlbHNlIHsgdmFyIG5ld09iaiA9IHt9OyBpZiAob2JqICE9IG51bGwpIHsgZm9yICh2YXIga2V5IGluIG9iaikgeyBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iaiwga2V5KSkgbmV3T2JqW2tleV0gPSBvYmpba2V5XTsgfSB9IG5ld09iai5kZWZhdWx0ID0gb2JqOyByZXR1cm4gbmV3T2JqOyB9IH1cblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cblxuZnVuY3Rpb24gX29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzKG9iaiwga2V5cykgeyB2YXIgdGFyZ2V0ID0ge307IGZvciAodmFyIGkgaW4gb2JqKSB7IGlmIChrZXlzLmluZGV4T2YoaSkgPj0gMCkgY29udGludWU7IGlmICghT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iaiwgaSkpIGNvbnRpbnVlOyB0YXJnZXRbaV0gPSBvYmpbaV07IH0gcmV0dXJuIHRhcmdldDsgfVxuXG5mdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2soaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7IGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIik7IH0gfVxuXG5mdW5jdGlvbiBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybihzZWxmLCBjYWxsKSB7IGlmICghc2VsZikgeyB0aHJvdyBuZXcgUmVmZXJlbmNlRXJyb3IoXCJ0aGlzIGhhc24ndCBiZWVuIGluaXRpYWxpc2VkIC0gc3VwZXIoKSBoYXNuJ3QgYmVlbiBjYWxsZWRcIik7IH0gcmV0dXJuIGNhbGwgJiYgKHR5cGVvZiBjYWxsID09PSBcIm9iamVjdFwiIHx8IHR5cGVvZiBjYWxsID09PSBcImZ1bmN0aW9uXCIpID8gY2FsbCA6IHNlbGY7IH1cblxuZnVuY3Rpb24gX2luaGVyaXRzKHN1YkNsYXNzLCBzdXBlckNsYXNzKSB7IGlmICh0eXBlb2Ygc3VwZXJDbGFzcyAhPT0gXCJmdW5jdGlvblwiICYmIHN1cGVyQ2xhc3MgIT09IG51bGwpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlN1cGVyIGV4cHJlc3Npb24gbXVzdCBlaXRoZXIgYmUgbnVsbCBvciBhIGZ1bmN0aW9uLCBub3QgXCIgKyB0eXBlb2Ygc3VwZXJDbGFzcyk7IH0gc3ViQ2xhc3MucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShzdXBlckNsYXNzICYmIHN1cGVyQ2xhc3MucHJvdG90eXBlLCB7IGNvbnN0cnVjdG9yOiB7IHZhbHVlOiBzdWJDbGFzcywgZW51bWVyYWJsZTogZmFsc2UsIHdyaXRhYmxlOiB0cnVlLCBjb25maWd1cmFibGU6IHRydWUgfSB9KTsgaWYgKHN1cGVyQ2xhc3MpIE9iamVjdC5zZXRQcm90b3R5cGVPZiA/IE9iamVjdC5zZXRQcm90b3R5cGVPZihzdWJDbGFzcywgc3VwZXJDbGFzcykgOiBzdWJDbGFzcy5fX3Byb3RvX18gPSBzdXBlckNsYXNzOyB9XG5cbnZhciBMb2FkaW5nID0gZnVuY3Rpb24gKF9Db21wb25lbnQpIHtcbiAgX2luaGVyaXRzKExvYWRpbmcsIF9Db21wb25lbnQpO1xuXG4gIGZ1bmN0aW9uIExvYWRpbmcoKSB7XG4gICAgdmFyIF9yZWY7XG5cbiAgICB2YXIgX3RlbXAsIF90aGlzLCBfcmV0O1xuXG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIExvYWRpbmcpO1xuXG4gICAgZm9yICh2YXIgX2xlbiA9IGFyZ3VtZW50cy5sZW5ndGgsIGFyZ3MgPSBBcnJheShfbGVuKSwgX2tleSA9IDA7IF9rZXkgPCBfbGVuOyBfa2V5KyspIHtcbiAgICAgIGFyZ3NbX2tleV0gPSBhcmd1bWVudHNbX2tleV07XG4gICAgfVxuXG4gICAgcmV0dXJuIF9yZXQgPSAoX3RlbXAgPSAoX3RoaXMgPSBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybih0aGlzLCAoX3JlZiA9IExvYWRpbmcuX19wcm90b19fIHx8IE9iamVjdC5nZXRQcm90b3R5cGVPZihMb2FkaW5nKSkuY2FsbC5hcHBseShfcmVmLCBbdGhpc10uY29uY2F0KGFyZ3MpKSksIF90aGlzKSwgX3RoaXMuc3RhdGUgPSB7XG4gICAgICBkZWxheWVkOiBfdGhpcy5wcm9wcy5kZWxheSA+IDBcbiAgICB9LCBfdGVtcCksIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKF90aGlzLCBfcmV0KTtcbiAgfVxuXG4gIF9jcmVhdGVDbGFzcyhMb2FkaW5nLCBbe1xuICAgIGtleTogJ2NvbXBvbmVudERpZE1vdW50JyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gY29tcG9uZW50RGlkTW91bnQoKSB7XG4gICAgICB2YXIgX3RoaXMyID0gdGhpcztcblxuICAgICAgdmFyIGRlbGF5ID0gdGhpcy5wcm9wcy5kZWxheTtcbiAgICAgIHZhciBkZWxheWVkID0gdGhpcy5zdGF0ZS5kZWxheWVkO1xuXG5cbiAgICAgIGlmIChkZWxheWVkKSB7XG4gICAgICAgIHRoaXMudGltZW91dCA9IHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgICAgIF90aGlzMi5zZXRTdGF0ZSh7XG4gICAgICAgICAgICBkZWxheWVkOiBmYWxzZVxuICAgICAgICAgIH0pO1xuICAgICAgICB9LCBkZWxheSk7XG4gICAgICB9XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiAnY29tcG9uZW50V2lsbFVubW91bnQnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBjb21wb25lbnRXaWxsVW5tb3VudCgpIHtcbiAgICAgIHZhciB0aW1lb3V0ID0gdGhpcy50aW1lb3V0O1xuXG5cbiAgICAgIGlmICh0aW1lb3V0KSB7XG4gICAgICAgIGNsZWFyVGltZW91dCh0aW1lb3V0KTtcbiAgICAgIH1cbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6ICdyZW5kZXInLFxuICAgIHZhbHVlOiBmdW5jdGlvbiByZW5kZXIoKSB7XG4gICAgICB2YXIgX3Byb3BzID0gdGhpcy5wcm9wcyxcbiAgICAgICAgICBjb2xvciA9IF9wcm9wcy5jb2xvcixcbiAgICAgICAgICBkZWxheSA9IF9wcm9wcy5kZWxheSxcbiAgICAgICAgICB0eXBlID0gX3Byb3BzLnR5cGUsXG4gICAgICAgICAgaGVpZ2h0ID0gX3Byb3BzLmhlaWdodCxcbiAgICAgICAgICB3aWR0aCA9IF9wcm9wcy53aWR0aCxcbiAgICAgICAgICByZXN0UHJvcHMgPSBfb2JqZWN0V2l0aG91dFByb3BlcnRpZXMoX3Byb3BzLCBbJ2NvbG9yJywgJ2RlbGF5JywgJ3R5cGUnLCAnaGVpZ2h0JywgJ3dpZHRoJ10pO1xuXG4gICAgICB2YXIgc2VsZWN0ZWRUeXBlID0gdGhpcy5zdGF0ZS5kZWxheWVkID8gJ2JsYW5rJyA6IHR5cGU7XG4gICAgICB2YXIgc3ZnID0gc3ZnU291cmNlc1tzZWxlY3RlZFR5cGVdO1xuICAgICAgdmFyIHN0eWxlID0ge1xuICAgICAgICBmaWxsOiBjb2xvcixcbiAgICAgICAgaGVpZ2h0OiBoZWlnaHQsXG4gICAgICAgIHdpZHRoOiB3aWR0aFxuICAgICAgfTtcblxuICAgICAgcmV0dXJuIF9yZWFjdDIuZGVmYXVsdC5jcmVhdGVFbGVtZW50KCdkaXYnLCBfZXh0ZW5kcyh7XG4gICAgICAgIHN0eWxlOiBzdHlsZSxcbiAgICAgICAgZGFuZ2Vyb3VzbHlTZXRJbm5lckhUTUw6IHsgX19odG1sOiBzdmcgfVxuICAgICAgfSwgcmVzdFByb3BzKSk7XG4gICAgfVxuICB9XSk7XG5cbiAgcmV0dXJuIExvYWRpbmc7XG59KF9yZWFjdC5Db21wb25lbnQpO1xuXG5Mb2FkaW5nLnByb3BUeXBlcyA9IHtcbiAgY29sb3I6IF9wcm9wVHlwZXMyLmRlZmF1bHQuc3RyaW5nLFxuICBkZWxheTogX3Byb3BUeXBlczIuZGVmYXVsdC5udW1iZXIsXG4gIHR5cGU6IF9wcm9wVHlwZXMyLmRlZmF1bHQuc3RyaW5nLFxuICBoZWlnaHQ6IF9wcm9wVHlwZXMyLmRlZmF1bHQub25lT2ZUeXBlKFtfcHJvcFR5cGVzMi5kZWZhdWx0LnN0cmluZywgX3Byb3BUeXBlczIuZGVmYXVsdC5udW1iZXJdKSxcbiAgd2lkdGg6IF9wcm9wVHlwZXMyLmRlZmF1bHQub25lT2ZUeXBlKFtfcHJvcFR5cGVzMi5kZWZhdWx0LnN0cmluZywgX3Byb3BUeXBlczIuZGVmYXVsdC5udW1iZXJdKVxufTtcbkxvYWRpbmcuZGVmYXVsdFByb3BzID0ge1xuICBjb2xvcjogJyNmZmYnLFxuICBkZWxheTogMCxcbiAgdHlwZTogJ2JhbGxzJyxcbiAgaGVpZ2h0OiA2NCxcbiAgd2lkdGg6IDY0XG59O1xuZXhwb3J0cy5kZWZhdWx0ID0gTG9hZGluZztcblxuLyoqKi8gfSksXG4vKiA4ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuXG5cbmlmIChwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gJ3Byb2R1Y3Rpb24nKSB7XG4gIG1vZHVsZS5leHBvcnRzID0gX193ZWJwYWNrX3JlcXVpcmVfXyg5KTtcbn0gZWxzZSB7XG4gIG1vZHVsZS5leHBvcnRzID0gX193ZWJwYWNrX3JlcXVpcmVfXygxMCk7XG59XG5cblxuLyoqKi8gfSksXG4vKiA5ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuLyoqIEBsaWNlbnNlIFJlYWN0IHYxNi4zLjJcbiAqIHJlYWN0LnByb2R1Y3Rpb24ubWluLmpzXG4gKlxuICogQ29weXJpZ2h0IChjKSAyMDEzLXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKi9cblxudmFyIG09X193ZWJwYWNrX3JlcXVpcmVfXygyKSxuPV9fd2VicGFja19yZXF1aXJlX18oMCkscD1fX3dlYnBhY2tfcmVxdWlyZV9fKDUpLHE9X193ZWJwYWNrX3JlcXVpcmVfXygxKSxyPVwiZnVuY3Rpb25cIj09PXR5cGVvZiBTeW1ib2wmJlN5bWJvbFtcImZvclwiXSx0PXI/U3ltYm9sW1wiZm9yXCJdKFwicmVhY3QuZWxlbWVudFwiKTo2MDEwMyx1PXI/U3ltYm9sW1wiZm9yXCJdKFwicmVhY3QucG9ydGFsXCIpOjYwMTA2LHY9cj9TeW1ib2xbXCJmb3JcIl0oXCJyZWFjdC5mcmFnbWVudFwiKTo2MDEwNyx3PXI/U3ltYm9sW1wiZm9yXCJdKFwicmVhY3Quc3RyaWN0X21vZGVcIik6NjAxMDgseD1yP1N5bWJvbFtcImZvclwiXShcInJlYWN0LnByb3ZpZGVyXCIpOjYwMTA5LHk9cj9TeW1ib2xbXCJmb3JcIl0oXCJyZWFjdC5jb250ZXh0XCIpOjYwMTEwLHo9cj9TeW1ib2xbXCJmb3JcIl0oXCJyZWFjdC5hc3luY19tb2RlXCIpOjYwMTExLEE9cj9TeW1ib2xbXCJmb3JcIl0oXCJyZWFjdC5mb3J3YXJkX3JlZlwiKTpcbjYwMTEyLEI9XCJmdW5jdGlvblwiPT09dHlwZW9mIFN5bWJvbCYmU3ltYm9sLml0ZXJhdG9yO2Z1bmN0aW9uIEMoYSl7Zm9yKHZhciBiPWFyZ3VtZW50cy5sZW5ndGgtMSxlPVwiaHR0cDovL3JlYWN0anMub3JnL2RvY3MvZXJyb3ItZGVjb2Rlci5odG1sP2ludmFyaWFudFxceDNkXCIrYSxjPTA7YzxiO2MrKyllKz1cIlxceDI2YXJnc1tdXFx4M2RcIitlbmNvZGVVUklDb21wb25lbnQoYXJndW1lbnRzW2MrMV0pO24oITEsXCJNaW5pZmllZCBSZWFjdCBlcnJvciAjXCIrYStcIjsgdmlzaXQgJXMgZm9yIHRoZSBmdWxsIG1lc3NhZ2Ugb3IgdXNlIHRoZSBub24tbWluaWZpZWQgZGV2IGVudmlyb25tZW50IGZvciBmdWxsIGVycm9ycyBhbmQgYWRkaXRpb25hbCBoZWxwZnVsIHdhcm5pbmdzLiBcIixlKX12YXIgRD17aXNNb3VudGVkOmZ1bmN0aW9uKCl7cmV0dXJuITF9LGVucXVldWVGb3JjZVVwZGF0ZTpmdW5jdGlvbigpe30sZW5xdWV1ZVJlcGxhY2VTdGF0ZTpmdW5jdGlvbigpe30sZW5xdWV1ZVNldFN0YXRlOmZ1bmN0aW9uKCl7fX07XG5mdW5jdGlvbiBFKGEsYixlKXt0aGlzLnByb3BzPWE7dGhpcy5jb250ZXh0PWI7dGhpcy5yZWZzPXA7dGhpcy51cGRhdGVyPWV8fER9RS5wcm90b3R5cGUuaXNSZWFjdENvbXBvbmVudD17fTtFLnByb3RvdHlwZS5zZXRTdGF0ZT1mdW5jdGlvbihhLGIpe1wib2JqZWN0XCIhPT10eXBlb2YgYSYmXCJmdW5jdGlvblwiIT09dHlwZW9mIGEmJm51bGwhPWE/QyhcIjg1XCIpOnZvaWQgMDt0aGlzLnVwZGF0ZXIuZW5xdWV1ZVNldFN0YXRlKHRoaXMsYSxiLFwic2V0U3RhdGVcIil9O0UucHJvdG90eXBlLmZvcmNlVXBkYXRlPWZ1bmN0aW9uKGEpe3RoaXMudXBkYXRlci5lbnF1ZXVlRm9yY2VVcGRhdGUodGhpcyxhLFwiZm9yY2VVcGRhdGVcIil9O2Z1bmN0aW9uIEYoKXt9Ri5wcm90b3R5cGU9RS5wcm90b3R5cGU7ZnVuY3Rpb24gRyhhLGIsZSl7dGhpcy5wcm9wcz1hO3RoaXMuY29udGV4dD1iO3RoaXMucmVmcz1wO3RoaXMudXBkYXRlcj1lfHxEfXZhciBIPUcucHJvdG90eXBlPW5ldyBGO1xuSC5jb25zdHJ1Y3Rvcj1HO20oSCxFLnByb3RvdHlwZSk7SC5pc1B1cmVSZWFjdENvbXBvbmVudD0hMDt2YXIgST17Y3VycmVudDpudWxsfSxKPU9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHksSz17a2V5OiEwLHJlZjohMCxfX3NlbGY6ITAsX19zb3VyY2U6ITB9O1xuZnVuY3Rpb24gTChhLGIsZSl7dmFyIGM9dm9pZCAwLGQ9e30sZz1udWxsLGg9bnVsbDtpZihudWxsIT1iKWZvcihjIGluIHZvaWQgMCE9PWIucmVmJiYoaD1iLnJlZiksdm9pZCAwIT09Yi5rZXkmJihnPVwiXCIrYi5rZXkpLGIpSi5jYWxsKGIsYykmJiFLLmhhc093blByb3BlcnR5KGMpJiYoZFtjXT1iW2NdKTt2YXIgZj1hcmd1bWVudHMubGVuZ3RoLTI7aWYoMT09PWYpZC5jaGlsZHJlbj1lO2Vsc2UgaWYoMTxmKXtmb3IodmFyIGs9QXJyYXkoZiksbD0wO2w8ZjtsKyspa1tsXT1hcmd1bWVudHNbbCsyXTtkLmNoaWxkcmVuPWt9aWYoYSYmYS5kZWZhdWx0UHJvcHMpZm9yKGMgaW4gZj1hLmRlZmF1bHRQcm9wcyxmKXZvaWQgMD09PWRbY10mJihkW2NdPWZbY10pO3JldHVybnskJHR5cGVvZjp0LHR5cGU6YSxrZXk6ZyxyZWY6aCxwcm9wczpkLF9vd25lcjpJLmN1cnJlbnR9fVxuZnVuY3Rpb24gTShhKXtyZXR1cm5cIm9iamVjdFwiPT09dHlwZW9mIGEmJm51bGwhPT1hJiZhLiQkdHlwZW9mPT09dH1mdW5jdGlvbiBlc2NhcGUoYSl7dmFyIGI9e1wiXFx4M2RcIjpcIlxceDNkMFwiLFwiOlwiOlwiXFx4M2QyXCJ9O3JldHVyblwiJFwiKyhcIlwiK2EpLnJlcGxhY2UoL1s9Ol0vZyxmdW5jdGlvbihhKXtyZXR1cm4gYlthXX0pfXZhciBOPS9cXC8rL2csTz1bXTtmdW5jdGlvbiBQKGEsYixlLGMpe2lmKE8ubGVuZ3RoKXt2YXIgZD1PLnBvcCgpO2QucmVzdWx0PWE7ZC5rZXlQcmVmaXg9YjtkLmZ1bmM9ZTtkLmNvbnRleHQ9YztkLmNvdW50PTA7cmV0dXJuIGR9cmV0dXJue3Jlc3VsdDphLGtleVByZWZpeDpiLGZ1bmM6ZSxjb250ZXh0OmMsY291bnQ6MH19ZnVuY3Rpb24gUShhKXthLnJlc3VsdD1udWxsO2Eua2V5UHJlZml4PW51bGw7YS5mdW5jPW51bGw7YS5jb250ZXh0PW51bGw7YS5jb3VudD0wOzEwPk8ubGVuZ3RoJiZPLnB1c2goYSl9XG5mdW5jdGlvbiBSKGEsYixlLGMpe3ZhciBkPXR5cGVvZiBhO2lmKFwidW5kZWZpbmVkXCI9PT1kfHxcImJvb2xlYW5cIj09PWQpYT1udWxsO3ZhciBnPSExO2lmKG51bGw9PT1hKWc9ITA7ZWxzZSBzd2l0Y2goZCl7Y2FzZSBcInN0cmluZ1wiOmNhc2UgXCJudW1iZXJcIjpnPSEwO2JyZWFrO2Nhc2UgXCJvYmplY3RcIjpzd2l0Y2goYS4kJHR5cGVvZil7Y2FzZSB0OmNhc2UgdTpnPSEwfX1pZihnKXJldHVybiBlKGMsYSxcIlwiPT09Yj9cIi5cIitTKGEsMCk6YiksMTtnPTA7Yj1cIlwiPT09Yj9cIi5cIjpiK1wiOlwiO2lmKEFycmF5LmlzQXJyYXkoYSkpZm9yKHZhciBoPTA7aDxhLmxlbmd0aDtoKyspe2Q9YVtoXTt2YXIgZj1iK1MoZCxoKTtnKz1SKGQsZixlLGMpfWVsc2UgaWYobnVsbD09PWF8fFwidW5kZWZpbmVkXCI9PT10eXBlb2YgYT9mPW51bGw6KGY9QiYmYVtCXXx8YVtcIkBAaXRlcmF0b3JcIl0sZj1cImZ1bmN0aW9uXCI9PT10eXBlb2YgZj9mOm51bGwpLFwiZnVuY3Rpb25cIj09PXR5cGVvZiBmKWZvcihhPWYuY2FsbChhKSxcbmg9MDshKGQ9YS5uZXh0KCkpLmRvbmU7KWQ9ZC52YWx1ZSxmPWIrUyhkLGgrKyksZys9UihkLGYsZSxjKTtlbHNlXCJvYmplY3RcIj09PWQmJihlPVwiXCIrYSxDKFwiMzFcIixcIltvYmplY3QgT2JqZWN0XVwiPT09ZT9cIm9iamVjdCB3aXRoIGtleXMge1wiK09iamVjdC5rZXlzKGEpLmpvaW4oXCIsIFwiKStcIn1cIjplLFwiXCIpKTtyZXR1cm4gZ31mdW5jdGlvbiBTKGEsYil7cmV0dXJuXCJvYmplY3RcIj09PXR5cGVvZiBhJiZudWxsIT09YSYmbnVsbCE9YS5rZXk/ZXNjYXBlKGEua2V5KTpiLnRvU3RyaW5nKDM2KX1mdW5jdGlvbiBUKGEsYil7YS5mdW5jLmNhbGwoYS5jb250ZXh0LGIsYS5jb3VudCsrKX1cbmZ1bmN0aW9uIFUoYSxiLGUpe3ZhciBjPWEucmVzdWx0LGQ9YS5rZXlQcmVmaXg7YT1hLmZ1bmMuY2FsbChhLmNvbnRleHQsYixhLmNvdW50KyspO0FycmF5LmlzQXJyYXkoYSk/VihhLGMsZSxxLnRoYXRSZXR1cm5zQXJndW1lbnQpOm51bGwhPWEmJihNKGEpJiYoYj1kKyghYS5rZXl8fGImJmIua2V5PT09YS5rZXk/XCJcIjooXCJcIithLmtleSkucmVwbGFjZShOLFwiJFxceDI2L1wiKStcIi9cIikrZSxhPXskJHR5cGVvZjp0LHR5cGU6YS50eXBlLGtleTpiLHJlZjphLnJlZixwcm9wczphLnByb3BzLF9vd25lcjphLl9vd25lcn0pLGMucHVzaChhKSl9ZnVuY3Rpb24gVihhLGIsZSxjLGQpe3ZhciBnPVwiXCI7bnVsbCE9ZSYmKGc9KFwiXCIrZSkucmVwbGFjZShOLFwiJFxceDI2L1wiKStcIi9cIik7Yj1QKGIsZyxjLGQpO251bGw9PWF8fFIoYSxcIlwiLFUsYik7UShiKX1cbnZhciBXPXtDaGlsZHJlbjp7bWFwOmZ1bmN0aW9uKGEsYixlKXtpZihudWxsPT1hKXJldHVybiBhO3ZhciBjPVtdO1YoYSxjLG51bGwsYixlKTtyZXR1cm4gY30sZm9yRWFjaDpmdW5jdGlvbihhLGIsZSl7aWYobnVsbD09YSlyZXR1cm4gYTtiPVAobnVsbCxudWxsLGIsZSk7bnVsbD09YXx8UihhLFwiXCIsVCxiKTtRKGIpfSxjb3VudDpmdW5jdGlvbihhKXtyZXR1cm4gbnVsbD09YT8wOlIoYSxcIlwiLHEudGhhdFJldHVybnNOdWxsLG51bGwpfSx0b0FycmF5OmZ1bmN0aW9uKGEpe3ZhciBiPVtdO1YoYSxiLG51bGwscS50aGF0UmV0dXJuc0FyZ3VtZW50KTtyZXR1cm4gYn0sb25seTpmdW5jdGlvbihhKXtNKGEpP3ZvaWQgMDpDKFwiMTQzXCIpO3JldHVybiBhfX0sY3JlYXRlUmVmOmZ1bmN0aW9uKCl7cmV0dXJue2N1cnJlbnQ6bnVsbH19LENvbXBvbmVudDpFLFB1cmVDb21wb25lbnQ6RyxjcmVhdGVDb250ZXh0OmZ1bmN0aW9uKGEsYil7dm9pZCAwPT09YiYmKGI9bnVsbCk7YT17JCR0eXBlb2Y6eSxcbl9jYWxjdWxhdGVDaGFuZ2VkQml0czpiLF9kZWZhdWx0VmFsdWU6YSxfY3VycmVudFZhbHVlOmEsX2NoYW5nZWRCaXRzOjAsUHJvdmlkZXI6bnVsbCxDb25zdW1lcjpudWxsfTthLlByb3ZpZGVyPXskJHR5cGVvZjp4LF9jb250ZXh0OmF9O3JldHVybiBhLkNvbnN1bWVyPWF9LGZvcndhcmRSZWY6ZnVuY3Rpb24oYSl7cmV0dXJueyQkdHlwZW9mOkEscmVuZGVyOmF9fSxGcmFnbWVudDp2LFN0cmljdE1vZGU6dyx1bnN0YWJsZV9Bc3luY01vZGU6eixjcmVhdGVFbGVtZW50OkwsY2xvbmVFbGVtZW50OmZ1bmN0aW9uKGEsYixlKXtudWxsPT09YXx8dm9pZCAwPT09YT9DKFwiMjY3XCIsYSk6dm9pZCAwO3ZhciBjPXZvaWQgMCxkPW0oe30sYS5wcm9wcyksZz1hLmtleSxoPWEucmVmLGY9YS5fb3duZXI7aWYobnVsbCE9Yil7dm9pZCAwIT09Yi5yZWYmJihoPWIucmVmLGY9SS5jdXJyZW50KTt2b2lkIDAhPT1iLmtleSYmKGc9XCJcIitiLmtleSk7dmFyIGs9dm9pZCAwO2EudHlwZSYmYS50eXBlLmRlZmF1bHRQcm9wcyYmXG4oaz1hLnR5cGUuZGVmYXVsdFByb3BzKTtmb3IoYyBpbiBiKUouY2FsbChiLGMpJiYhSy5oYXNPd25Qcm9wZXJ0eShjKSYmKGRbY109dm9pZCAwPT09YltjXSYmdm9pZCAwIT09az9rW2NdOmJbY10pfWM9YXJndW1lbnRzLmxlbmd0aC0yO2lmKDE9PT1jKWQuY2hpbGRyZW49ZTtlbHNlIGlmKDE8Yyl7az1BcnJheShjKTtmb3IodmFyIGw9MDtsPGM7bCsrKWtbbF09YXJndW1lbnRzW2wrMl07ZC5jaGlsZHJlbj1rfXJldHVybnskJHR5cGVvZjp0LHR5cGU6YS50eXBlLGtleTpnLHJlZjpoLHByb3BzOmQsX293bmVyOmZ9fSxjcmVhdGVGYWN0b3J5OmZ1bmN0aW9uKGEpe3ZhciBiPUwuYmluZChudWxsLGEpO2IudHlwZT1hO3JldHVybiBifSxpc1ZhbGlkRWxlbWVudDpNLHZlcnNpb246XCIxNi4zLjJcIixfX1NFQ1JFVF9JTlRFUk5BTFNfRE9fTk9UX1VTRV9PUl9ZT1VfV0lMTF9CRV9GSVJFRDp7UmVhY3RDdXJyZW50T3duZXI6SSxhc3NpZ246bX19LFg9T2JqZWN0LmZyZWV6ZSh7ZGVmYXVsdDpXfSksXG5ZPVgmJld8fFg7bW9kdWxlLmV4cG9ydHM9WVtcImRlZmF1bHRcIl0/WVtcImRlZmF1bHRcIl06WTtcblxuXG4vKioqLyB9KSxcbi8qIDEwICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuLyoqIEBsaWNlbnNlIFJlYWN0IHYxNi4zLjJcbiAqIHJlYWN0LmRldmVsb3BtZW50LmpzXG4gKlxuICogQ29weXJpZ2h0IChjKSAyMDEzLXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKi9cblxuXG5cblxuXG5pZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSB7XG4gIChmdW5jdGlvbigpIHtcbid1c2Ugc3RyaWN0JztcblxudmFyIF9hc3NpZ24gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDIpO1xudmFyIGludmFyaWFudCA9IF9fd2VicGFja19yZXF1aXJlX18oMCk7XG52YXIgZW1wdHlPYmplY3QgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDUpO1xudmFyIHdhcm5pbmcgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDMpO1xudmFyIGVtcHR5RnVuY3Rpb24gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDEpO1xudmFyIGNoZWNrUHJvcFR5cGVzID0gX193ZWJwYWNrX3JlcXVpcmVfXyg2KTtcblxuLy8gVE9ETzogdGhpcyBpcyBzcGVjaWFsIGJlY2F1c2UgaXQgZ2V0cyBpbXBvcnRlZCBkdXJpbmcgYnVpbGQuXG5cbnZhciBSZWFjdFZlcnNpb24gPSAnMTYuMy4yJztcblxuLy8gVGhlIFN5bWJvbCB1c2VkIHRvIHRhZyB0aGUgUmVhY3RFbGVtZW50LWxpa2UgdHlwZXMuIElmIHRoZXJlIGlzIG5vIG5hdGl2ZSBTeW1ib2xcbi8vIG5vciBwb2x5ZmlsbCwgdGhlbiBhIHBsYWluIG51bWJlciBpcyB1c2VkIGZvciBwZXJmb3JtYW5jZS5cbnZhciBoYXNTeW1ib2wgPSB0eXBlb2YgU3ltYm9sID09PSAnZnVuY3Rpb24nICYmIFN5bWJvbFsnZm9yJ107XG5cbnZhciBSRUFDVF9FTEVNRU5UX1RZUEUgPSBoYXNTeW1ib2wgPyBTeW1ib2xbJ2ZvciddKCdyZWFjdC5lbGVtZW50JykgOiAweGVhYzc7XG52YXIgUkVBQ1RfQ0FMTF9UWVBFID0gaGFzU3ltYm9sID8gU3ltYm9sWydmb3InXSgncmVhY3QuY2FsbCcpIDogMHhlYWM4O1xudmFyIFJFQUNUX1JFVFVSTl9UWVBFID0gaGFzU3ltYm9sID8gU3ltYm9sWydmb3InXSgncmVhY3QucmV0dXJuJykgOiAweGVhYzk7XG52YXIgUkVBQ1RfUE9SVEFMX1RZUEUgPSBoYXNTeW1ib2wgPyBTeW1ib2xbJ2ZvciddKCdyZWFjdC5wb3J0YWwnKSA6IDB4ZWFjYTtcbnZhciBSRUFDVF9GUkFHTUVOVF9UWVBFID0gaGFzU3ltYm9sID8gU3ltYm9sWydmb3InXSgncmVhY3QuZnJhZ21lbnQnKSA6IDB4ZWFjYjtcbnZhciBSRUFDVF9TVFJJQ1RfTU9ERV9UWVBFID0gaGFzU3ltYm9sID8gU3ltYm9sWydmb3InXSgncmVhY3Quc3RyaWN0X21vZGUnKSA6IDB4ZWFjYztcbnZhciBSRUFDVF9QUk9WSURFUl9UWVBFID0gaGFzU3ltYm9sID8gU3ltYm9sWydmb3InXSgncmVhY3QucHJvdmlkZXInKSA6IDB4ZWFjZDtcbnZhciBSRUFDVF9DT05URVhUX1RZUEUgPSBoYXNTeW1ib2wgPyBTeW1ib2xbJ2ZvciddKCdyZWFjdC5jb250ZXh0JykgOiAweGVhY2U7XG52YXIgUkVBQ1RfQVNZTkNfTU9ERV9UWVBFID0gaGFzU3ltYm9sID8gU3ltYm9sWydmb3InXSgncmVhY3QuYXN5bmNfbW9kZScpIDogMHhlYWNmO1xudmFyIFJFQUNUX0ZPUldBUkRfUkVGX1RZUEUgPSBoYXNTeW1ib2wgPyBTeW1ib2xbJ2ZvciddKCdyZWFjdC5mb3J3YXJkX3JlZicpIDogMHhlYWQwO1xuXG52YXIgTUFZQkVfSVRFUkFUT1JfU1lNQk9MID0gdHlwZW9mIFN5bWJvbCA9PT0gJ2Z1bmN0aW9uJyAmJiBTeW1ib2wuaXRlcmF0b3I7XG52YXIgRkFVWF9JVEVSQVRPUl9TWU1CT0wgPSAnQEBpdGVyYXRvcic7XG5cbmZ1bmN0aW9uIGdldEl0ZXJhdG9yRm4obWF5YmVJdGVyYWJsZSkge1xuICBpZiAobWF5YmVJdGVyYWJsZSA9PT0gbnVsbCB8fCB0eXBlb2YgbWF5YmVJdGVyYWJsZSA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuICB2YXIgbWF5YmVJdGVyYXRvciA9IE1BWUJFX0lURVJBVE9SX1NZTUJPTCAmJiBtYXliZUl0ZXJhYmxlW01BWUJFX0lURVJBVE9SX1NZTUJPTF0gfHwgbWF5YmVJdGVyYWJsZVtGQVVYX0lURVJBVE9SX1NZTUJPTF07XG4gIGlmICh0eXBlb2YgbWF5YmVJdGVyYXRvciA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIHJldHVybiBtYXliZUl0ZXJhdG9yO1xuICB9XG4gIHJldHVybiBudWxsO1xufVxuXG4vLyBSZWx5aW5nIG9uIHRoZSBgaW52YXJpYW50KClgIGltcGxlbWVudGF0aW9uIGxldHMgdXNcbi8vIGhhdmUgcHJlc2VydmUgdGhlIGZvcm1hdCBhbmQgcGFyYW1zIGluIHRoZSB3d3cgYnVpbGRzLlxuXG4vKipcbiAqIEZvcmtlZCBmcm9tIGZianMvd2FybmluZzpcbiAqIGh0dHBzOi8vZ2l0aHViLmNvbS9mYWNlYm9vay9mYmpzL2Jsb2IvZTY2YmEyMGFkNWJlNDMzZWI1NDQyM2YyYjA5N2Q4MjkzMjRkOWRlNi9wYWNrYWdlcy9mYmpzL3NyYy9fX2ZvcmtzX18vd2FybmluZy5qc1xuICpcbiAqIE9ubHkgY2hhbmdlIGlzIHdlIHVzZSBjb25zb2xlLndhcm4gaW5zdGVhZCBvZiBjb25zb2xlLmVycm9yLFxuICogYW5kIGRvIG5vdGhpbmcgd2hlbiAnY29uc29sZScgaXMgbm90IHN1cHBvcnRlZC5cbiAqIFRoaXMgcmVhbGx5IHNpbXBsaWZpZXMgdGhlIGNvZGUuXG4gKiAtLS1cbiAqIFNpbWlsYXIgdG8gaW52YXJpYW50IGJ1dCBvbmx5IGxvZ3MgYSB3YXJuaW5nIGlmIHRoZSBjb25kaXRpb24gaXMgbm90IG1ldC5cbiAqIFRoaXMgY2FuIGJlIHVzZWQgdG8gbG9nIGlzc3VlcyBpbiBkZXZlbG9wbWVudCBlbnZpcm9ubWVudHMgaW4gY3JpdGljYWxcbiAqIHBhdGhzLiBSZW1vdmluZyB0aGUgbG9nZ2luZyBjb2RlIGZvciBwcm9kdWN0aW9uIGVudmlyb25tZW50cyB3aWxsIGtlZXAgdGhlXG4gKiBzYW1lIGxvZ2ljIGFuZCBmb2xsb3cgdGhlIHNhbWUgY29kZSBwYXRocy5cbiAqL1xuXG52YXIgbG93UHJpb3JpdHlXYXJuaW5nID0gZnVuY3Rpb24gKCkge307XG5cbntcbiAgdmFyIHByaW50V2FybmluZyA9IGZ1bmN0aW9uIChmb3JtYXQpIHtcbiAgICBmb3IgKHZhciBfbGVuID0gYXJndW1lbnRzLmxlbmd0aCwgYXJncyA9IEFycmF5KF9sZW4gPiAxID8gX2xlbiAtIDEgOiAwKSwgX2tleSA9IDE7IF9rZXkgPCBfbGVuOyBfa2V5KyspIHtcbiAgICAgIGFyZ3NbX2tleSAtIDFdID0gYXJndW1lbnRzW19rZXldO1xuICAgIH1cblxuICAgIHZhciBhcmdJbmRleCA9IDA7XG4gICAgdmFyIG1lc3NhZ2UgPSAnV2FybmluZzogJyArIGZvcm1hdC5yZXBsYWNlKC8lcy9nLCBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gYXJnc1thcmdJbmRleCsrXTtcbiAgICB9KTtcbiAgICBpZiAodHlwZW9mIGNvbnNvbGUgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICBjb25zb2xlLndhcm4obWVzc2FnZSk7XG4gICAgfVxuICAgIHRyeSB7XG4gICAgICAvLyAtLS0gV2VsY29tZSB0byBkZWJ1Z2dpbmcgUmVhY3QgLS0tXG4gICAgICAvLyBUaGlzIGVycm9yIHdhcyB0aHJvd24gYXMgYSBjb252ZW5pZW5jZSBzbyB0aGF0IHlvdSBjYW4gdXNlIHRoaXMgc3RhY2tcbiAgICAgIC8vIHRvIGZpbmQgdGhlIGNhbGxzaXRlIHRoYXQgY2F1c2VkIHRoaXMgd2FybmluZyB0byBmaXJlLlxuICAgICAgdGhyb3cgbmV3IEVycm9yKG1lc3NhZ2UpO1xuICAgIH0gY2F0Y2ggKHgpIHt9XG4gIH07XG5cbiAgbG93UHJpb3JpdHlXYXJuaW5nID0gZnVuY3Rpb24gKGNvbmRpdGlvbiwgZm9ybWF0KSB7XG4gICAgaWYgKGZvcm1hdCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ2B3YXJuaW5nKGNvbmRpdGlvbiwgZm9ybWF0LCAuLi5hcmdzKWAgcmVxdWlyZXMgYSB3YXJuaW5nICcgKyAnbWVzc2FnZSBhcmd1bWVudCcpO1xuICAgIH1cbiAgICBpZiAoIWNvbmRpdGlvbikge1xuICAgICAgZm9yICh2YXIgX2xlbjIgPSBhcmd1bWVudHMubGVuZ3RoLCBhcmdzID0gQXJyYXkoX2xlbjIgPiAyID8gX2xlbjIgLSAyIDogMCksIF9rZXkyID0gMjsgX2tleTIgPCBfbGVuMjsgX2tleTIrKykge1xuICAgICAgICBhcmdzW19rZXkyIC0gMl0gPSBhcmd1bWVudHNbX2tleTJdO1xuICAgICAgfVxuXG4gICAgICBwcmludFdhcm5pbmcuYXBwbHkodW5kZWZpbmVkLCBbZm9ybWF0XS5jb25jYXQoYXJncykpO1xuICAgIH1cbiAgfTtcbn1cblxudmFyIGxvd1ByaW9yaXR5V2FybmluZyQxID0gbG93UHJpb3JpdHlXYXJuaW5nO1xuXG52YXIgZGlkV2FyblN0YXRlVXBkYXRlRm9yVW5tb3VudGVkQ29tcG9uZW50ID0ge307XG5cbmZ1bmN0aW9uIHdhcm5Ob29wKHB1YmxpY0luc3RhbmNlLCBjYWxsZXJOYW1lKSB7XG4gIHtcbiAgICB2YXIgX2NvbnN0cnVjdG9yID0gcHVibGljSW5zdGFuY2UuY29uc3RydWN0b3I7XG4gICAgdmFyIGNvbXBvbmVudE5hbWUgPSBfY29uc3RydWN0b3IgJiYgKF9jb25zdHJ1Y3Rvci5kaXNwbGF5TmFtZSB8fCBfY29uc3RydWN0b3IubmFtZSkgfHwgJ1JlYWN0Q2xhc3MnO1xuICAgIHZhciB3YXJuaW5nS2V5ID0gY29tcG9uZW50TmFtZSArICcuJyArIGNhbGxlck5hbWU7XG4gICAgaWYgKGRpZFdhcm5TdGF0ZVVwZGF0ZUZvclVubW91bnRlZENvbXBvbmVudFt3YXJuaW5nS2V5XSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB3YXJuaW5nKGZhbHNlLCBcIkNhbid0IGNhbGwgJXMgb24gYSBjb21wb25lbnQgdGhhdCBpcyBub3QgeWV0IG1vdW50ZWQuIFwiICsgJ1RoaXMgaXMgYSBuby1vcCwgYnV0IGl0IG1pZ2h0IGluZGljYXRlIGEgYnVnIGluIHlvdXIgYXBwbGljYXRpb24uICcgKyAnSW5zdGVhZCwgYXNzaWduIHRvIGB0aGlzLnN0YXRlYCBkaXJlY3RseSBvciBkZWZpbmUgYSBgc3RhdGUgPSB7fTtgICcgKyAnY2xhc3MgcHJvcGVydHkgd2l0aCB0aGUgZGVzaXJlZCBzdGF0ZSBpbiB0aGUgJXMgY29tcG9uZW50LicsIGNhbGxlck5hbWUsIGNvbXBvbmVudE5hbWUpO1xuICAgIGRpZFdhcm5TdGF0ZVVwZGF0ZUZvclVubW91bnRlZENvbXBvbmVudFt3YXJuaW5nS2V5XSA9IHRydWU7XG4gIH1cbn1cblxuLyoqXG4gKiBUaGlzIGlzIHRoZSBhYnN0cmFjdCBBUEkgZm9yIGFuIHVwZGF0ZSBxdWV1ZS5cbiAqL1xudmFyIFJlYWN0Tm9vcFVwZGF0ZVF1ZXVlID0ge1xuICAvKipcbiAgICogQ2hlY2tzIHdoZXRoZXIgb3Igbm90IHRoaXMgY29tcG9zaXRlIGNvbXBvbmVudCBpcyBtb3VudGVkLlxuICAgKiBAcGFyYW0ge1JlYWN0Q2xhc3N9IHB1YmxpY0luc3RhbmNlIFRoZSBpbnN0YW5jZSB3ZSB3YW50IHRvIHRlc3QuXG4gICAqIEByZXR1cm4ge2Jvb2xlYW59IFRydWUgaWYgbW91bnRlZCwgZmFsc2Ugb3RoZXJ3aXNlLlxuICAgKiBAcHJvdGVjdGVkXG4gICAqIEBmaW5hbFxuICAgKi9cbiAgaXNNb3VudGVkOiBmdW5jdGlvbiAocHVibGljSW5zdGFuY2UpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH0sXG5cbiAgLyoqXG4gICAqIEZvcmNlcyBhbiB1cGRhdGUuIFRoaXMgc2hvdWxkIG9ubHkgYmUgaW52b2tlZCB3aGVuIGl0IGlzIGtub3duIHdpdGhcbiAgICogY2VydGFpbnR5IHRoYXQgd2UgYXJlICoqbm90KiogaW4gYSBET00gdHJhbnNhY3Rpb24uXG4gICAqXG4gICAqIFlvdSBtYXkgd2FudCB0byBjYWxsIHRoaXMgd2hlbiB5b3Uga25vdyB0aGF0IHNvbWUgZGVlcGVyIGFzcGVjdCBvZiB0aGVcbiAgICogY29tcG9uZW50J3Mgc3RhdGUgaGFzIGNoYW5nZWQgYnV0IGBzZXRTdGF0ZWAgd2FzIG5vdCBjYWxsZWQuXG4gICAqXG4gICAqIFRoaXMgd2lsbCBub3QgaW52b2tlIGBzaG91bGRDb21wb25lbnRVcGRhdGVgLCBidXQgaXQgd2lsbCBpbnZva2VcbiAgICogYGNvbXBvbmVudFdpbGxVcGRhdGVgIGFuZCBgY29tcG9uZW50RGlkVXBkYXRlYC5cbiAgICpcbiAgICogQHBhcmFtIHtSZWFjdENsYXNzfSBwdWJsaWNJbnN0YW5jZSBUaGUgaW5zdGFuY2UgdGhhdCBzaG91bGQgcmVyZW5kZXIuXG4gICAqIEBwYXJhbSB7P2Z1bmN0aW9ufSBjYWxsYmFjayBDYWxsZWQgYWZ0ZXIgY29tcG9uZW50IGlzIHVwZGF0ZWQuXG4gICAqIEBwYXJhbSB7P3N0cmluZ30gY2FsbGVyTmFtZSBuYW1lIG9mIHRoZSBjYWxsaW5nIGZ1bmN0aW9uIGluIHRoZSBwdWJsaWMgQVBJLlxuICAgKiBAaW50ZXJuYWxcbiAgICovXG4gIGVucXVldWVGb3JjZVVwZGF0ZTogZnVuY3Rpb24gKHB1YmxpY0luc3RhbmNlLCBjYWxsYmFjaywgY2FsbGVyTmFtZSkge1xuICAgIHdhcm5Ob29wKHB1YmxpY0luc3RhbmNlLCAnZm9yY2VVcGRhdGUnKTtcbiAgfSxcblxuICAvKipcbiAgICogUmVwbGFjZXMgYWxsIG9mIHRoZSBzdGF0ZS4gQWx3YXlzIHVzZSB0aGlzIG9yIGBzZXRTdGF0ZWAgdG8gbXV0YXRlIHN0YXRlLlxuICAgKiBZb3Ugc2hvdWxkIHRyZWF0IGB0aGlzLnN0YXRlYCBhcyBpbW11dGFibGUuXG4gICAqXG4gICAqIFRoZXJlIGlzIG5vIGd1YXJhbnRlZSB0aGF0IGB0aGlzLnN0YXRlYCB3aWxsIGJlIGltbWVkaWF0ZWx5IHVwZGF0ZWQsIHNvXG4gICAqIGFjY2Vzc2luZyBgdGhpcy5zdGF0ZWAgYWZ0ZXIgY2FsbGluZyB0aGlzIG1ldGhvZCBtYXkgcmV0dXJuIHRoZSBvbGQgdmFsdWUuXG4gICAqXG4gICAqIEBwYXJhbSB7UmVhY3RDbGFzc30gcHVibGljSW5zdGFuY2UgVGhlIGluc3RhbmNlIHRoYXQgc2hvdWxkIHJlcmVuZGVyLlxuICAgKiBAcGFyYW0ge29iamVjdH0gY29tcGxldGVTdGF0ZSBOZXh0IHN0YXRlLlxuICAgKiBAcGFyYW0gez9mdW5jdGlvbn0gY2FsbGJhY2sgQ2FsbGVkIGFmdGVyIGNvbXBvbmVudCBpcyB1cGRhdGVkLlxuICAgKiBAcGFyYW0gez9zdHJpbmd9IGNhbGxlck5hbWUgbmFtZSBvZiB0aGUgY2FsbGluZyBmdW5jdGlvbiBpbiB0aGUgcHVibGljIEFQSS5cbiAgICogQGludGVybmFsXG4gICAqL1xuICBlbnF1ZXVlUmVwbGFjZVN0YXRlOiBmdW5jdGlvbiAocHVibGljSW5zdGFuY2UsIGNvbXBsZXRlU3RhdGUsIGNhbGxiYWNrLCBjYWxsZXJOYW1lKSB7XG4gICAgd2Fybk5vb3AocHVibGljSW5zdGFuY2UsICdyZXBsYWNlU3RhdGUnKTtcbiAgfSxcblxuICAvKipcbiAgICogU2V0cyBhIHN1YnNldCBvZiB0aGUgc3RhdGUuIFRoaXMgb25seSBleGlzdHMgYmVjYXVzZSBfcGVuZGluZ1N0YXRlIGlzXG4gICAqIGludGVybmFsLiBUaGlzIHByb3ZpZGVzIGEgbWVyZ2luZyBzdHJhdGVneSB0aGF0IGlzIG5vdCBhdmFpbGFibGUgdG8gZGVlcFxuICAgKiBwcm9wZXJ0aWVzIHdoaWNoIGlzIGNvbmZ1c2luZy4gVE9ETzogRXhwb3NlIHBlbmRpbmdTdGF0ZSBvciBkb24ndCB1c2UgaXRcbiAgICogZHVyaW5nIHRoZSBtZXJnZS5cbiAgICpcbiAgICogQHBhcmFtIHtSZWFjdENsYXNzfSBwdWJsaWNJbnN0YW5jZSBUaGUgaW5zdGFuY2UgdGhhdCBzaG91bGQgcmVyZW5kZXIuXG4gICAqIEBwYXJhbSB7b2JqZWN0fSBwYXJ0aWFsU3RhdGUgTmV4dCBwYXJ0aWFsIHN0YXRlIHRvIGJlIG1lcmdlZCB3aXRoIHN0YXRlLlxuICAgKiBAcGFyYW0gez9mdW5jdGlvbn0gY2FsbGJhY2sgQ2FsbGVkIGFmdGVyIGNvbXBvbmVudCBpcyB1cGRhdGVkLlxuICAgKiBAcGFyYW0gez9zdHJpbmd9IE5hbWUgb2YgdGhlIGNhbGxpbmcgZnVuY3Rpb24gaW4gdGhlIHB1YmxpYyBBUEkuXG4gICAqIEBpbnRlcm5hbFxuICAgKi9cbiAgZW5xdWV1ZVNldFN0YXRlOiBmdW5jdGlvbiAocHVibGljSW5zdGFuY2UsIHBhcnRpYWxTdGF0ZSwgY2FsbGJhY2ssIGNhbGxlck5hbWUpIHtcbiAgICB3YXJuTm9vcChwdWJsaWNJbnN0YW5jZSwgJ3NldFN0YXRlJyk7XG4gIH1cbn07XG5cbi8qKlxuICogQmFzZSBjbGFzcyBoZWxwZXJzIGZvciB0aGUgdXBkYXRpbmcgc3RhdGUgb2YgYSBjb21wb25lbnQuXG4gKi9cbmZ1bmN0aW9uIENvbXBvbmVudChwcm9wcywgY29udGV4dCwgdXBkYXRlcikge1xuICB0aGlzLnByb3BzID0gcHJvcHM7XG4gIHRoaXMuY29udGV4dCA9IGNvbnRleHQ7XG4gIHRoaXMucmVmcyA9IGVtcHR5T2JqZWN0O1xuICAvLyBXZSBpbml0aWFsaXplIHRoZSBkZWZhdWx0IHVwZGF0ZXIgYnV0IHRoZSByZWFsIG9uZSBnZXRzIGluamVjdGVkIGJ5IHRoZVxuICAvLyByZW5kZXJlci5cbiAgdGhpcy51cGRhdGVyID0gdXBkYXRlciB8fCBSZWFjdE5vb3BVcGRhdGVRdWV1ZTtcbn1cblxuQ29tcG9uZW50LnByb3RvdHlwZS5pc1JlYWN0Q29tcG9uZW50ID0ge307XG5cbi8qKlxuICogU2V0cyBhIHN1YnNldCBvZiB0aGUgc3RhdGUuIEFsd2F5cyB1c2UgdGhpcyB0byBtdXRhdGVcbiAqIHN0YXRlLiBZb3Ugc2hvdWxkIHRyZWF0IGB0aGlzLnN0YXRlYCBhcyBpbW11dGFibGUuXG4gKlxuICogVGhlcmUgaXMgbm8gZ3VhcmFudGVlIHRoYXQgYHRoaXMuc3RhdGVgIHdpbGwgYmUgaW1tZWRpYXRlbHkgdXBkYXRlZCwgc29cbiAqIGFjY2Vzc2luZyBgdGhpcy5zdGF0ZWAgYWZ0ZXIgY2FsbGluZyB0aGlzIG1ldGhvZCBtYXkgcmV0dXJuIHRoZSBvbGQgdmFsdWUuXG4gKlxuICogVGhlcmUgaXMgbm8gZ3VhcmFudGVlIHRoYXQgY2FsbHMgdG8gYHNldFN0YXRlYCB3aWxsIHJ1biBzeW5jaHJvbm91c2x5LFxuICogYXMgdGhleSBtYXkgZXZlbnR1YWxseSBiZSBiYXRjaGVkIHRvZ2V0aGVyLiAgWW91IGNhbiBwcm92aWRlIGFuIG9wdGlvbmFsXG4gKiBjYWxsYmFjayB0aGF0IHdpbGwgYmUgZXhlY3V0ZWQgd2hlbiB0aGUgY2FsbCB0byBzZXRTdGF0ZSBpcyBhY3R1YWxseVxuICogY29tcGxldGVkLlxuICpcbiAqIFdoZW4gYSBmdW5jdGlvbiBpcyBwcm92aWRlZCB0byBzZXRTdGF0ZSwgaXQgd2lsbCBiZSBjYWxsZWQgYXQgc29tZSBwb2ludCBpblxuICogdGhlIGZ1dHVyZSAobm90IHN5bmNocm9ub3VzbHkpLiBJdCB3aWxsIGJlIGNhbGxlZCB3aXRoIHRoZSB1cCB0byBkYXRlXG4gKiBjb21wb25lbnQgYXJndW1lbnRzIChzdGF0ZSwgcHJvcHMsIGNvbnRleHQpLiBUaGVzZSB2YWx1ZXMgY2FuIGJlIGRpZmZlcmVudFxuICogZnJvbSB0aGlzLiogYmVjYXVzZSB5b3VyIGZ1bmN0aW9uIG1heSBiZSBjYWxsZWQgYWZ0ZXIgcmVjZWl2ZVByb3BzIGJ1dCBiZWZvcmVcbiAqIHNob3VsZENvbXBvbmVudFVwZGF0ZSwgYW5kIHRoaXMgbmV3IHN0YXRlLCBwcm9wcywgYW5kIGNvbnRleHQgd2lsbCBub3QgeWV0IGJlXG4gKiBhc3NpZ25lZCB0byB0aGlzLlxuICpcbiAqIEBwYXJhbSB7b2JqZWN0fGZ1bmN0aW9ufSBwYXJ0aWFsU3RhdGUgTmV4dCBwYXJ0aWFsIHN0YXRlIG9yIGZ1bmN0aW9uIHRvXG4gKiAgICAgICAgcHJvZHVjZSBuZXh0IHBhcnRpYWwgc3RhdGUgdG8gYmUgbWVyZ2VkIHdpdGggY3VycmVudCBzdGF0ZS5cbiAqIEBwYXJhbSB7P2Z1bmN0aW9ufSBjYWxsYmFjayBDYWxsZWQgYWZ0ZXIgc3RhdGUgaXMgdXBkYXRlZC5cbiAqIEBmaW5hbFxuICogQHByb3RlY3RlZFxuICovXG5Db21wb25lbnQucHJvdG90eXBlLnNldFN0YXRlID0gZnVuY3Rpb24gKHBhcnRpYWxTdGF0ZSwgY2FsbGJhY2spIHtcbiAgISh0eXBlb2YgcGFydGlhbFN0YXRlID09PSAnb2JqZWN0JyB8fCB0eXBlb2YgcGFydGlhbFN0YXRlID09PSAnZnVuY3Rpb24nIHx8IHBhcnRpYWxTdGF0ZSA9PSBudWxsKSA/IGludmFyaWFudChmYWxzZSwgJ3NldFN0YXRlKC4uLik6IHRha2VzIGFuIG9iamVjdCBvZiBzdGF0ZSB2YXJpYWJsZXMgdG8gdXBkYXRlIG9yIGEgZnVuY3Rpb24gd2hpY2ggcmV0dXJucyBhbiBvYmplY3Qgb2Ygc3RhdGUgdmFyaWFibGVzLicpIDogdm9pZCAwO1xuICB0aGlzLnVwZGF0ZXIuZW5xdWV1ZVNldFN0YXRlKHRoaXMsIHBhcnRpYWxTdGF0ZSwgY2FsbGJhY2ssICdzZXRTdGF0ZScpO1xufTtcblxuLyoqXG4gKiBGb3JjZXMgYW4gdXBkYXRlLiBUaGlzIHNob3VsZCBvbmx5IGJlIGludm9rZWQgd2hlbiBpdCBpcyBrbm93biB3aXRoXG4gKiBjZXJ0YWludHkgdGhhdCB3ZSBhcmUgKipub3QqKiBpbiBhIERPTSB0cmFuc2FjdGlvbi5cbiAqXG4gKiBZb3UgbWF5IHdhbnQgdG8gY2FsbCB0aGlzIHdoZW4geW91IGtub3cgdGhhdCBzb21lIGRlZXBlciBhc3BlY3Qgb2YgdGhlXG4gKiBjb21wb25lbnQncyBzdGF0ZSBoYXMgY2hhbmdlZCBidXQgYHNldFN0YXRlYCB3YXMgbm90IGNhbGxlZC5cbiAqXG4gKiBUaGlzIHdpbGwgbm90IGludm9rZSBgc2hvdWxkQ29tcG9uZW50VXBkYXRlYCwgYnV0IGl0IHdpbGwgaW52b2tlXG4gKiBgY29tcG9uZW50V2lsbFVwZGF0ZWAgYW5kIGBjb21wb25lbnREaWRVcGRhdGVgLlxuICpcbiAqIEBwYXJhbSB7P2Z1bmN0aW9ufSBjYWxsYmFjayBDYWxsZWQgYWZ0ZXIgdXBkYXRlIGlzIGNvbXBsZXRlLlxuICogQGZpbmFsXG4gKiBAcHJvdGVjdGVkXG4gKi9cbkNvbXBvbmVudC5wcm90b3R5cGUuZm9yY2VVcGRhdGUgPSBmdW5jdGlvbiAoY2FsbGJhY2spIHtcbiAgdGhpcy51cGRhdGVyLmVucXVldWVGb3JjZVVwZGF0ZSh0aGlzLCBjYWxsYmFjaywgJ2ZvcmNlVXBkYXRlJyk7XG59O1xuXG4vKipcbiAqIERlcHJlY2F0ZWQgQVBJcy4gVGhlc2UgQVBJcyB1c2VkIHRvIGV4aXN0IG9uIGNsYXNzaWMgUmVhY3QgY2xhc3NlcyBidXQgc2luY2VcbiAqIHdlIHdvdWxkIGxpa2UgdG8gZGVwcmVjYXRlIHRoZW0sIHdlJ3JlIG5vdCBnb2luZyB0byBtb3ZlIHRoZW0gb3ZlciB0byB0aGlzXG4gKiBtb2Rlcm4gYmFzZSBjbGFzcy4gSW5zdGVhZCwgd2UgZGVmaW5lIGEgZ2V0dGVyIHRoYXQgd2FybnMgaWYgaXQncyBhY2Nlc3NlZC5cbiAqL1xue1xuICB2YXIgZGVwcmVjYXRlZEFQSXMgPSB7XG4gICAgaXNNb3VudGVkOiBbJ2lzTW91bnRlZCcsICdJbnN0ZWFkLCBtYWtlIHN1cmUgdG8gY2xlYW4gdXAgc3Vic2NyaXB0aW9ucyBhbmQgcGVuZGluZyByZXF1ZXN0cyBpbiAnICsgJ2NvbXBvbmVudFdpbGxVbm1vdW50IHRvIHByZXZlbnQgbWVtb3J5IGxlYWtzLiddLFxuICAgIHJlcGxhY2VTdGF0ZTogWydyZXBsYWNlU3RhdGUnLCAnUmVmYWN0b3IgeW91ciBjb2RlIHRvIHVzZSBzZXRTdGF0ZSBpbnN0ZWFkIChzZWUgJyArICdodHRwczovL2dpdGh1Yi5jb20vZmFjZWJvb2svcmVhY3QvaXNzdWVzLzMyMzYpLiddXG4gIH07XG4gIHZhciBkZWZpbmVEZXByZWNhdGlvbldhcm5pbmcgPSBmdW5jdGlvbiAobWV0aG9kTmFtZSwgaW5mbykge1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShDb21wb25lbnQucHJvdG90eXBlLCBtZXRob2ROYW1lLCB7XG4gICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgbG93UHJpb3JpdHlXYXJuaW5nJDEoZmFsc2UsICclcyguLi4pIGlzIGRlcHJlY2F0ZWQgaW4gcGxhaW4gSmF2YVNjcmlwdCBSZWFjdCBjbGFzc2VzLiAlcycsIGluZm9bMF0sIGluZm9bMV0pO1xuICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgfVxuICAgIH0pO1xuICB9O1xuICBmb3IgKHZhciBmbk5hbWUgaW4gZGVwcmVjYXRlZEFQSXMpIHtcbiAgICBpZiAoZGVwcmVjYXRlZEFQSXMuaGFzT3duUHJvcGVydHkoZm5OYW1lKSkge1xuICAgICAgZGVmaW5lRGVwcmVjYXRpb25XYXJuaW5nKGZuTmFtZSwgZGVwcmVjYXRlZEFQSXNbZm5OYW1lXSk7XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIENvbXBvbmVudER1bW15KCkge31cbkNvbXBvbmVudER1bW15LnByb3RvdHlwZSA9IENvbXBvbmVudC5wcm90b3R5cGU7XG5cbi8qKlxuICogQ29udmVuaWVuY2UgY29tcG9uZW50IHdpdGggZGVmYXVsdCBzaGFsbG93IGVxdWFsaXR5IGNoZWNrIGZvciBzQ1UuXG4gKi9cbmZ1bmN0aW9uIFB1cmVDb21wb25lbnQocHJvcHMsIGNvbnRleHQsIHVwZGF0ZXIpIHtcbiAgdGhpcy5wcm9wcyA9IHByb3BzO1xuICB0aGlzLmNvbnRleHQgPSBjb250ZXh0O1xuICB0aGlzLnJlZnMgPSBlbXB0eU9iamVjdDtcbiAgdGhpcy51cGRhdGVyID0gdXBkYXRlciB8fCBSZWFjdE5vb3BVcGRhdGVRdWV1ZTtcbn1cblxudmFyIHB1cmVDb21wb25lbnRQcm90b3R5cGUgPSBQdXJlQ29tcG9uZW50LnByb3RvdHlwZSA9IG5ldyBDb21wb25lbnREdW1teSgpO1xucHVyZUNvbXBvbmVudFByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IFB1cmVDb21wb25lbnQ7XG4vLyBBdm9pZCBhbiBleHRyYSBwcm90b3R5cGUganVtcCBmb3IgdGhlc2UgbWV0aG9kcy5cbl9hc3NpZ24ocHVyZUNvbXBvbmVudFByb3RvdHlwZSwgQ29tcG9uZW50LnByb3RvdHlwZSk7XG5wdXJlQ29tcG9uZW50UHJvdG90eXBlLmlzUHVyZVJlYWN0Q29tcG9uZW50ID0gdHJ1ZTtcblxuLy8gYW4gaW1tdXRhYmxlIG9iamVjdCB3aXRoIGEgc2luZ2xlIG11dGFibGUgdmFsdWVcbmZ1bmN0aW9uIGNyZWF0ZVJlZigpIHtcbiAgdmFyIHJlZk9iamVjdCA9IHtcbiAgICBjdXJyZW50OiBudWxsXG4gIH07XG4gIHtcbiAgICBPYmplY3Quc2VhbChyZWZPYmplY3QpO1xuICB9XG4gIHJldHVybiByZWZPYmplY3Q7XG59XG5cbi8qKlxuICogS2VlcHMgdHJhY2sgb2YgdGhlIGN1cnJlbnQgb3duZXIuXG4gKlxuICogVGhlIGN1cnJlbnQgb3duZXIgaXMgdGhlIGNvbXBvbmVudCB3aG8gc2hvdWxkIG93biBhbnkgY29tcG9uZW50cyB0aGF0IGFyZVxuICogY3VycmVudGx5IGJlaW5nIGNvbnN0cnVjdGVkLlxuICovXG52YXIgUmVhY3RDdXJyZW50T3duZXIgPSB7XG4gIC8qKlxuICAgKiBAaW50ZXJuYWxcbiAgICogQHR5cGUge1JlYWN0Q29tcG9uZW50fVxuICAgKi9cbiAgY3VycmVudDogbnVsbFxufTtcblxudmFyIGhhc093blByb3BlcnR5ID0gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eTtcblxudmFyIFJFU0VSVkVEX1BST1BTID0ge1xuICBrZXk6IHRydWUsXG4gIHJlZjogdHJ1ZSxcbiAgX19zZWxmOiB0cnVlLFxuICBfX3NvdXJjZTogdHJ1ZVxufTtcblxudmFyIHNwZWNpYWxQcm9wS2V5V2FybmluZ1Nob3duID0gdm9pZCAwO1xudmFyIHNwZWNpYWxQcm9wUmVmV2FybmluZ1Nob3duID0gdm9pZCAwO1xuXG5mdW5jdGlvbiBoYXNWYWxpZFJlZihjb25maWcpIHtcbiAge1xuICAgIGlmIChoYXNPd25Qcm9wZXJ0eS5jYWxsKGNvbmZpZywgJ3JlZicpKSB7XG4gICAgICB2YXIgZ2V0dGVyID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihjb25maWcsICdyZWYnKS5nZXQ7XG4gICAgICBpZiAoZ2V0dGVyICYmIGdldHRlci5pc1JlYWN0V2FybmluZykge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIHJldHVybiBjb25maWcucmVmICE9PSB1bmRlZmluZWQ7XG59XG5cbmZ1bmN0aW9uIGhhc1ZhbGlkS2V5KGNvbmZpZykge1xuICB7XG4gICAgaWYgKGhhc093blByb3BlcnR5LmNhbGwoY29uZmlnLCAna2V5JykpIHtcbiAgICAgIHZhciBnZXR0ZXIgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKGNvbmZpZywgJ2tleScpLmdldDtcbiAgICAgIGlmIChnZXR0ZXIgJiYgZ2V0dGVyLmlzUmVhY3RXYXJuaW5nKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgcmV0dXJuIGNvbmZpZy5rZXkgIT09IHVuZGVmaW5lZDtcbn1cblxuZnVuY3Rpb24gZGVmaW5lS2V5UHJvcFdhcm5pbmdHZXR0ZXIocHJvcHMsIGRpc3BsYXlOYW1lKSB7XG4gIHZhciB3YXJuQWJvdXRBY2Nlc3NpbmdLZXkgPSBmdW5jdGlvbiAoKSB7XG4gICAgaWYgKCFzcGVjaWFsUHJvcEtleVdhcm5pbmdTaG93bikge1xuICAgICAgc3BlY2lhbFByb3BLZXlXYXJuaW5nU2hvd24gPSB0cnVlO1xuICAgICAgd2FybmluZyhmYWxzZSwgJyVzOiBga2V5YCBpcyBub3QgYSBwcm9wLiBUcnlpbmcgdG8gYWNjZXNzIGl0IHdpbGwgcmVzdWx0ICcgKyAnaW4gYHVuZGVmaW5lZGAgYmVpbmcgcmV0dXJuZWQuIElmIHlvdSBuZWVkIHRvIGFjY2VzcyB0aGUgc2FtZSAnICsgJ3ZhbHVlIHdpdGhpbiB0aGUgY2hpbGQgY29tcG9uZW50LCB5b3Ugc2hvdWxkIHBhc3MgaXQgYXMgYSBkaWZmZXJlbnQgJyArICdwcm9wLiAoaHR0cHM6Ly9mYi5tZS9yZWFjdC1zcGVjaWFsLXByb3BzKScsIGRpc3BsYXlOYW1lKTtcbiAgICB9XG4gIH07XG4gIHdhcm5BYm91dEFjY2Vzc2luZ0tleS5pc1JlYWN0V2FybmluZyA9IHRydWU7XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShwcm9wcywgJ2tleScsIHtcbiAgICBnZXQ6IHdhcm5BYm91dEFjY2Vzc2luZ0tleSxcbiAgICBjb25maWd1cmFibGU6IHRydWVcbiAgfSk7XG59XG5cbmZ1bmN0aW9uIGRlZmluZVJlZlByb3BXYXJuaW5nR2V0dGVyKHByb3BzLCBkaXNwbGF5TmFtZSkge1xuICB2YXIgd2FybkFib3V0QWNjZXNzaW5nUmVmID0gZnVuY3Rpb24gKCkge1xuICAgIGlmICghc3BlY2lhbFByb3BSZWZXYXJuaW5nU2hvd24pIHtcbiAgICAgIHNwZWNpYWxQcm9wUmVmV2FybmluZ1Nob3duID0gdHJ1ZTtcbiAgICAgIHdhcm5pbmcoZmFsc2UsICclczogYHJlZmAgaXMgbm90IGEgcHJvcC4gVHJ5aW5nIHRvIGFjY2VzcyBpdCB3aWxsIHJlc3VsdCAnICsgJ2luIGB1bmRlZmluZWRgIGJlaW5nIHJldHVybmVkLiBJZiB5b3UgbmVlZCB0byBhY2Nlc3MgdGhlIHNhbWUgJyArICd2YWx1ZSB3aXRoaW4gdGhlIGNoaWxkIGNvbXBvbmVudCwgeW91IHNob3VsZCBwYXNzIGl0IGFzIGEgZGlmZmVyZW50ICcgKyAncHJvcC4gKGh0dHBzOi8vZmIubWUvcmVhY3Qtc3BlY2lhbC1wcm9wcyknLCBkaXNwbGF5TmFtZSk7XG4gICAgfVxuICB9O1xuICB3YXJuQWJvdXRBY2Nlc3NpbmdSZWYuaXNSZWFjdFdhcm5pbmcgPSB0cnVlO1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkocHJvcHMsICdyZWYnLCB7XG4gICAgZ2V0OiB3YXJuQWJvdXRBY2Nlc3NpbmdSZWYsXG4gICAgY29uZmlndXJhYmxlOiB0cnVlXG4gIH0pO1xufVxuXG4vKipcbiAqIEZhY3RvcnkgbWV0aG9kIHRvIGNyZWF0ZSBhIG5ldyBSZWFjdCBlbGVtZW50LiBUaGlzIG5vIGxvbmdlciBhZGhlcmVzIHRvXG4gKiB0aGUgY2xhc3MgcGF0dGVybiwgc28gZG8gbm90IHVzZSBuZXcgdG8gY2FsbCBpdC4gQWxzbywgbm8gaW5zdGFuY2VvZiBjaGVja1xuICogd2lsbCB3b3JrLiBJbnN0ZWFkIHRlc3QgJCR0eXBlb2YgZmllbGQgYWdhaW5zdCBTeW1ib2wuZm9yKCdyZWFjdC5lbGVtZW50JykgdG8gY2hlY2tcbiAqIGlmIHNvbWV0aGluZyBpcyBhIFJlYWN0IEVsZW1lbnQuXG4gKlxuICogQHBhcmFtIHsqfSB0eXBlXG4gKiBAcGFyYW0geyp9IGtleVxuICogQHBhcmFtIHtzdHJpbmd8b2JqZWN0fSByZWZcbiAqIEBwYXJhbSB7Kn0gc2VsZiBBICp0ZW1wb3JhcnkqIGhlbHBlciB0byBkZXRlY3QgcGxhY2VzIHdoZXJlIGB0aGlzYCBpc1xuICogZGlmZmVyZW50IGZyb20gdGhlIGBvd25lcmAgd2hlbiBSZWFjdC5jcmVhdGVFbGVtZW50IGlzIGNhbGxlZCwgc28gdGhhdCB3ZVxuICogY2FuIHdhcm4uIFdlIHdhbnQgdG8gZ2V0IHJpZCBvZiBvd25lciBhbmQgcmVwbGFjZSBzdHJpbmcgYHJlZmBzIHdpdGggYXJyb3dcbiAqIGZ1bmN0aW9ucywgYW5kIGFzIGxvbmcgYXMgYHRoaXNgIGFuZCBvd25lciBhcmUgdGhlIHNhbWUsIHRoZXJlIHdpbGwgYmUgbm9cbiAqIGNoYW5nZSBpbiBiZWhhdmlvci5cbiAqIEBwYXJhbSB7Kn0gc291cmNlIEFuIGFubm90YXRpb24gb2JqZWN0IChhZGRlZCBieSBhIHRyYW5zcGlsZXIgb3Igb3RoZXJ3aXNlKVxuICogaW5kaWNhdGluZyBmaWxlbmFtZSwgbGluZSBudW1iZXIsIGFuZC9vciBvdGhlciBpbmZvcm1hdGlvbi5cbiAqIEBwYXJhbSB7Kn0gb3duZXJcbiAqIEBwYXJhbSB7Kn0gcHJvcHNcbiAqIEBpbnRlcm5hbFxuICovXG52YXIgUmVhY3RFbGVtZW50ID0gZnVuY3Rpb24gKHR5cGUsIGtleSwgcmVmLCBzZWxmLCBzb3VyY2UsIG93bmVyLCBwcm9wcykge1xuICB2YXIgZWxlbWVudCA9IHtcbiAgICAvLyBUaGlzIHRhZyBhbGxvd3MgdXMgdG8gdW5pcXVlbHkgaWRlbnRpZnkgdGhpcyBhcyBhIFJlYWN0IEVsZW1lbnRcbiAgICAkJHR5cGVvZjogUkVBQ1RfRUxFTUVOVF9UWVBFLFxuXG4gICAgLy8gQnVpbHQtaW4gcHJvcGVydGllcyB0aGF0IGJlbG9uZyBvbiB0aGUgZWxlbWVudFxuICAgIHR5cGU6IHR5cGUsXG4gICAga2V5OiBrZXksXG4gICAgcmVmOiByZWYsXG4gICAgcHJvcHM6IHByb3BzLFxuXG4gICAgLy8gUmVjb3JkIHRoZSBjb21wb25lbnQgcmVzcG9uc2libGUgZm9yIGNyZWF0aW5nIHRoaXMgZWxlbWVudC5cbiAgICBfb3duZXI6IG93bmVyXG4gIH07XG5cbiAge1xuICAgIC8vIFRoZSB2YWxpZGF0aW9uIGZsYWcgaXMgY3VycmVudGx5IG11dGF0aXZlLiBXZSBwdXQgaXQgb25cbiAgICAvLyBhbiBleHRlcm5hbCBiYWNraW5nIHN0b3JlIHNvIHRoYXQgd2UgY2FuIGZyZWV6ZSB0aGUgd2hvbGUgb2JqZWN0LlxuICAgIC8vIFRoaXMgY2FuIGJlIHJlcGxhY2VkIHdpdGggYSBXZWFrTWFwIG9uY2UgdGhleSBhcmUgaW1wbGVtZW50ZWQgaW5cbiAgICAvLyBjb21tb25seSB1c2VkIGRldmVsb3BtZW50IGVudmlyb25tZW50cy5cbiAgICBlbGVtZW50Ll9zdG9yZSA9IHt9O1xuXG4gICAgLy8gVG8gbWFrZSBjb21wYXJpbmcgUmVhY3RFbGVtZW50cyBlYXNpZXIgZm9yIHRlc3RpbmcgcHVycG9zZXMsIHdlIG1ha2VcbiAgICAvLyB0aGUgdmFsaWRhdGlvbiBmbGFnIG5vbi1lbnVtZXJhYmxlICh3aGVyZSBwb3NzaWJsZSwgd2hpY2ggc2hvdWxkXG4gICAgLy8gaW5jbHVkZSBldmVyeSBlbnZpcm9ubWVudCB3ZSBydW4gdGVzdHMgaW4pLCBzbyB0aGUgdGVzdCBmcmFtZXdvcmtcbiAgICAvLyBpZ25vcmVzIGl0LlxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShlbGVtZW50Ll9zdG9yZSwgJ3ZhbGlkYXRlZCcsIHtcbiAgICAgIGNvbmZpZ3VyYWJsZTogZmFsc2UsXG4gICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgdmFsdWU6IGZhbHNlXG4gICAgfSk7XG4gICAgLy8gc2VsZiBhbmQgc291cmNlIGFyZSBERVYgb25seSBwcm9wZXJ0aWVzLlxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShlbGVtZW50LCAnX3NlbGYnLCB7XG4gICAgICBjb25maWd1cmFibGU6IGZhbHNlLFxuICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICB3cml0YWJsZTogZmFsc2UsXG4gICAgICB2YWx1ZTogc2VsZlxuICAgIH0pO1xuICAgIC8vIFR3byBlbGVtZW50cyBjcmVhdGVkIGluIHR3byBkaWZmZXJlbnQgcGxhY2VzIHNob3VsZCBiZSBjb25zaWRlcmVkXG4gICAgLy8gZXF1YWwgZm9yIHRlc3RpbmcgcHVycG9zZXMgYW5kIHRoZXJlZm9yZSB3ZSBoaWRlIGl0IGZyb20gZW51bWVyYXRpb24uXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGVsZW1lbnQsICdfc291cmNlJywge1xuICAgICAgY29uZmlndXJhYmxlOiBmYWxzZSxcbiAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgd3JpdGFibGU6IGZhbHNlLFxuICAgICAgdmFsdWU6IHNvdXJjZVxuICAgIH0pO1xuICAgIGlmIChPYmplY3QuZnJlZXplKSB7XG4gICAgICBPYmplY3QuZnJlZXplKGVsZW1lbnQucHJvcHMpO1xuICAgICAgT2JqZWN0LmZyZWV6ZShlbGVtZW50KTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gZWxlbWVudDtcbn07XG5cbi8qKlxuICogQ3JlYXRlIGFuZCByZXR1cm4gYSBuZXcgUmVhY3RFbGVtZW50IG9mIHRoZSBnaXZlbiB0eXBlLlxuICogU2VlIGh0dHBzOi8vcmVhY3Rqcy5vcmcvZG9jcy9yZWFjdC1hcGkuaHRtbCNjcmVhdGVlbGVtZW50XG4gKi9cbmZ1bmN0aW9uIGNyZWF0ZUVsZW1lbnQodHlwZSwgY29uZmlnLCBjaGlsZHJlbikge1xuICB2YXIgcHJvcE5hbWUgPSB2b2lkIDA7XG5cbiAgLy8gUmVzZXJ2ZWQgbmFtZXMgYXJlIGV4dHJhY3RlZFxuICB2YXIgcHJvcHMgPSB7fTtcblxuICB2YXIga2V5ID0gbnVsbDtcbiAgdmFyIHJlZiA9IG51bGw7XG4gIHZhciBzZWxmID0gbnVsbDtcbiAgdmFyIHNvdXJjZSA9IG51bGw7XG5cbiAgaWYgKGNvbmZpZyAhPSBudWxsKSB7XG4gICAgaWYgKGhhc1ZhbGlkUmVmKGNvbmZpZykpIHtcbiAgICAgIHJlZiA9IGNvbmZpZy5yZWY7XG4gICAgfVxuICAgIGlmIChoYXNWYWxpZEtleShjb25maWcpKSB7XG4gICAgICBrZXkgPSAnJyArIGNvbmZpZy5rZXk7XG4gICAgfVxuXG4gICAgc2VsZiA9IGNvbmZpZy5fX3NlbGYgPT09IHVuZGVmaW5lZCA/IG51bGwgOiBjb25maWcuX19zZWxmO1xuICAgIHNvdXJjZSA9IGNvbmZpZy5fX3NvdXJjZSA9PT0gdW5kZWZpbmVkID8gbnVsbCA6IGNvbmZpZy5fX3NvdXJjZTtcbiAgICAvLyBSZW1haW5pbmcgcHJvcGVydGllcyBhcmUgYWRkZWQgdG8gYSBuZXcgcHJvcHMgb2JqZWN0XG4gICAgZm9yIChwcm9wTmFtZSBpbiBjb25maWcpIHtcbiAgICAgIGlmIChoYXNPd25Qcm9wZXJ0eS5jYWxsKGNvbmZpZywgcHJvcE5hbWUpICYmICFSRVNFUlZFRF9QUk9QUy5oYXNPd25Qcm9wZXJ0eShwcm9wTmFtZSkpIHtcbiAgICAgICAgcHJvcHNbcHJvcE5hbWVdID0gY29uZmlnW3Byb3BOYW1lXTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICAvLyBDaGlsZHJlbiBjYW4gYmUgbW9yZSB0aGFuIG9uZSBhcmd1bWVudCwgYW5kIHRob3NlIGFyZSB0cmFuc2ZlcnJlZCBvbnRvXG4gIC8vIHRoZSBuZXdseSBhbGxvY2F0ZWQgcHJvcHMgb2JqZWN0LlxuICB2YXIgY2hpbGRyZW5MZW5ndGggPSBhcmd1bWVudHMubGVuZ3RoIC0gMjtcbiAgaWYgKGNoaWxkcmVuTGVuZ3RoID09PSAxKSB7XG4gICAgcHJvcHMuY2hpbGRyZW4gPSBjaGlsZHJlbjtcbiAgfSBlbHNlIGlmIChjaGlsZHJlbkxlbmd0aCA+IDEpIHtcbiAgICB2YXIgY2hpbGRBcnJheSA9IEFycmF5KGNoaWxkcmVuTGVuZ3RoKTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNoaWxkcmVuTGVuZ3RoOyBpKyspIHtcbiAgICAgIGNoaWxkQXJyYXlbaV0gPSBhcmd1bWVudHNbaSArIDJdO1xuICAgIH1cbiAgICB7XG4gICAgICBpZiAoT2JqZWN0LmZyZWV6ZSkge1xuICAgICAgICBPYmplY3QuZnJlZXplKGNoaWxkQXJyYXkpO1xuICAgICAgfVxuICAgIH1cbiAgICBwcm9wcy5jaGlsZHJlbiA9IGNoaWxkQXJyYXk7XG4gIH1cblxuICAvLyBSZXNvbHZlIGRlZmF1bHQgcHJvcHNcbiAgaWYgKHR5cGUgJiYgdHlwZS5kZWZhdWx0UHJvcHMpIHtcbiAgICB2YXIgZGVmYXVsdFByb3BzID0gdHlwZS5kZWZhdWx0UHJvcHM7XG4gICAgZm9yIChwcm9wTmFtZSBpbiBkZWZhdWx0UHJvcHMpIHtcbiAgICAgIGlmIChwcm9wc1twcm9wTmFtZV0gPT09IHVuZGVmaW5lZCkge1xuICAgICAgICBwcm9wc1twcm9wTmFtZV0gPSBkZWZhdWx0UHJvcHNbcHJvcE5hbWVdO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICB7XG4gICAgaWYgKGtleSB8fCByZWYpIHtcbiAgICAgIGlmICh0eXBlb2YgcHJvcHMuJCR0eXBlb2YgPT09ICd1bmRlZmluZWQnIHx8IHByb3BzLiQkdHlwZW9mICE9PSBSRUFDVF9FTEVNRU5UX1RZUEUpIHtcbiAgICAgICAgdmFyIGRpc3BsYXlOYW1lID0gdHlwZW9mIHR5cGUgPT09ICdmdW5jdGlvbicgPyB0eXBlLmRpc3BsYXlOYW1lIHx8IHR5cGUubmFtZSB8fCAnVW5rbm93bicgOiB0eXBlO1xuICAgICAgICBpZiAoa2V5KSB7XG4gICAgICAgICAgZGVmaW5lS2V5UHJvcFdhcm5pbmdHZXR0ZXIocHJvcHMsIGRpc3BsYXlOYW1lKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAocmVmKSB7XG4gICAgICAgICAgZGVmaW5lUmVmUHJvcFdhcm5pbmdHZXR0ZXIocHJvcHMsIGRpc3BsYXlOYW1lKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuICByZXR1cm4gUmVhY3RFbGVtZW50KHR5cGUsIGtleSwgcmVmLCBzZWxmLCBzb3VyY2UsIFJlYWN0Q3VycmVudE93bmVyLmN1cnJlbnQsIHByb3BzKTtcbn1cblxuLyoqXG4gKiBSZXR1cm4gYSBmdW5jdGlvbiB0aGF0IHByb2R1Y2VzIFJlYWN0RWxlbWVudHMgb2YgYSBnaXZlbiB0eXBlLlxuICogU2VlIGh0dHBzOi8vcmVhY3Rqcy5vcmcvZG9jcy9yZWFjdC1hcGkuaHRtbCNjcmVhdGVmYWN0b3J5XG4gKi9cblxuXG5mdW5jdGlvbiBjbG9uZUFuZFJlcGxhY2VLZXkob2xkRWxlbWVudCwgbmV3S2V5KSB7XG4gIHZhciBuZXdFbGVtZW50ID0gUmVhY3RFbGVtZW50KG9sZEVsZW1lbnQudHlwZSwgbmV3S2V5LCBvbGRFbGVtZW50LnJlZiwgb2xkRWxlbWVudC5fc2VsZiwgb2xkRWxlbWVudC5fc291cmNlLCBvbGRFbGVtZW50Ll9vd25lciwgb2xkRWxlbWVudC5wcm9wcyk7XG5cbiAgcmV0dXJuIG5ld0VsZW1lbnQ7XG59XG5cbi8qKlxuICogQ2xvbmUgYW5kIHJldHVybiBhIG5ldyBSZWFjdEVsZW1lbnQgdXNpbmcgZWxlbWVudCBhcyB0aGUgc3RhcnRpbmcgcG9pbnQuXG4gKiBTZWUgaHR0cHM6Ly9yZWFjdGpzLm9yZy9kb2NzL3JlYWN0LWFwaS5odG1sI2Nsb25lZWxlbWVudFxuICovXG5mdW5jdGlvbiBjbG9uZUVsZW1lbnQoZWxlbWVudCwgY29uZmlnLCBjaGlsZHJlbikge1xuICAhIShlbGVtZW50ID09PSBudWxsIHx8IGVsZW1lbnQgPT09IHVuZGVmaW5lZCkgPyBpbnZhcmlhbnQoZmFsc2UsICdSZWFjdC5jbG9uZUVsZW1lbnQoLi4uKTogVGhlIGFyZ3VtZW50IG11c3QgYmUgYSBSZWFjdCBlbGVtZW50LCBidXQgeW91IHBhc3NlZCAlcy4nLCBlbGVtZW50KSA6IHZvaWQgMDtcblxuICB2YXIgcHJvcE5hbWUgPSB2b2lkIDA7XG5cbiAgLy8gT3JpZ2luYWwgcHJvcHMgYXJlIGNvcGllZFxuICB2YXIgcHJvcHMgPSBfYXNzaWduKHt9LCBlbGVtZW50LnByb3BzKTtcblxuICAvLyBSZXNlcnZlZCBuYW1lcyBhcmUgZXh0cmFjdGVkXG4gIHZhciBrZXkgPSBlbGVtZW50LmtleTtcbiAgdmFyIHJlZiA9IGVsZW1lbnQucmVmO1xuICAvLyBTZWxmIGlzIHByZXNlcnZlZCBzaW5jZSB0aGUgb3duZXIgaXMgcHJlc2VydmVkLlxuICB2YXIgc2VsZiA9IGVsZW1lbnQuX3NlbGY7XG4gIC8vIFNvdXJjZSBpcyBwcmVzZXJ2ZWQgc2luY2UgY2xvbmVFbGVtZW50IGlzIHVubGlrZWx5IHRvIGJlIHRhcmdldGVkIGJ5IGFcbiAgLy8gdHJhbnNwaWxlciwgYW5kIHRoZSBvcmlnaW5hbCBzb3VyY2UgaXMgcHJvYmFibHkgYSBiZXR0ZXIgaW5kaWNhdG9yIG9mIHRoZVxuICAvLyB0cnVlIG93bmVyLlxuICB2YXIgc291cmNlID0gZWxlbWVudC5fc291cmNlO1xuXG4gIC8vIE93bmVyIHdpbGwgYmUgcHJlc2VydmVkLCB1bmxlc3MgcmVmIGlzIG92ZXJyaWRkZW5cbiAgdmFyIG93bmVyID0gZWxlbWVudC5fb3duZXI7XG5cbiAgaWYgKGNvbmZpZyAhPSBudWxsKSB7XG4gICAgaWYgKGhhc1ZhbGlkUmVmKGNvbmZpZykpIHtcbiAgICAgIC8vIFNpbGVudGx5IHN0ZWFsIHRoZSByZWYgZnJvbSB0aGUgcGFyZW50LlxuICAgICAgcmVmID0gY29uZmlnLnJlZjtcbiAgICAgIG93bmVyID0gUmVhY3RDdXJyZW50T3duZXIuY3VycmVudDtcbiAgICB9XG4gICAgaWYgKGhhc1ZhbGlkS2V5KGNvbmZpZykpIHtcbiAgICAgIGtleSA9ICcnICsgY29uZmlnLmtleTtcbiAgICB9XG5cbiAgICAvLyBSZW1haW5pbmcgcHJvcGVydGllcyBvdmVycmlkZSBleGlzdGluZyBwcm9wc1xuICAgIHZhciBkZWZhdWx0UHJvcHMgPSB2b2lkIDA7XG4gICAgaWYgKGVsZW1lbnQudHlwZSAmJiBlbGVtZW50LnR5cGUuZGVmYXVsdFByb3BzKSB7XG4gICAgICBkZWZhdWx0UHJvcHMgPSBlbGVtZW50LnR5cGUuZGVmYXVsdFByb3BzO1xuICAgIH1cbiAgICBmb3IgKHByb3BOYW1lIGluIGNvbmZpZykge1xuICAgICAgaWYgKGhhc093blByb3BlcnR5LmNhbGwoY29uZmlnLCBwcm9wTmFtZSkgJiYgIVJFU0VSVkVEX1BST1BTLmhhc093blByb3BlcnR5KHByb3BOYW1lKSkge1xuICAgICAgICBpZiAoY29uZmlnW3Byb3BOYW1lXSA9PT0gdW5kZWZpbmVkICYmIGRlZmF1bHRQcm9wcyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgLy8gUmVzb2x2ZSBkZWZhdWx0IHByb3BzXG4gICAgICAgICAgcHJvcHNbcHJvcE5hbWVdID0gZGVmYXVsdFByb3BzW3Byb3BOYW1lXTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBwcm9wc1twcm9wTmFtZV0gPSBjb25maWdbcHJvcE5hbWVdO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgLy8gQ2hpbGRyZW4gY2FuIGJlIG1vcmUgdGhhbiBvbmUgYXJndW1lbnQsIGFuZCB0aG9zZSBhcmUgdHJhbnNmZXJyZWQgb250b1xuICAvLyB0aGUgbmV3bHkgYWxsb2NhdGVkIHByb3BzIG9iamVjdC5cbiAgdmFyIGNoaWxkcmVuTGVuZ3RoID0gYXJndW1lbnRzLmxlbmd0aCAtIDI7XG4gIGlmIChjaGlsZHJlbkxlbmd0aCA9PT0gMSkge1xuICAgIHByb3BzLmNoaWxkcmVuID0gY2hpbGRyZW47XG4gIH0gZWxzZSBpZiAoY2hpbGRyZW5MZW5ndGggPiAxKSB7XG4gICAgdmFyIGNoaWxkQXJyYXkgPSBBcnJheShjaGlsZHJlbkxlbmd0aCk7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjaGlsZHJlbkxlbmd0aDsgaSsrKSB7XG4gICAgICBjaGlsZEFycmF5W2ldID0gYXJndW1lbnRzW2kgKyAyXTtcbiAgICB9XG4gICAgcHJvcHMuY2hpbGRyZW4gPSBjaGlsZEFycmF5O1xuICB9XG5cbiAgcmV0dXJuIFJlYWN0RWxlbWVudChlbGVtZW50LnR5cGUsIGtleSwgcmVmLCBzZWxmLCBzb3VyY2UsIG93bmVyLCBwcm9wcyk7XG59XG5cbi8qKlxuICogVmVyaWZpZXMgdGhlIG9iamVjdCBpcyBhIFJlYWN0RWxlbWVudC5cbiAqIFNlZSBodHRwczovL3JlYWN0anMub3JnL2RvY3MvcmVhY3QtYXBpLmh0bWwjaXN2YWxpZGVsZW1lbnRcbiAqIEBwYXJhbSB7P29iamVjdH0gb2JqZWN0XG4gKiBAcmV0dXJuIHtib29sZWFufSBUcnVlIGlmIGBvYmplY3RgIGlzIGEgdmFsaWQgY29tcG9uZW50LlxuICogQGZpbmFsXG4gKi9cbmZ1bmN0aW9uIGlzVmFsaWRFbGVtZW50KG9iamVjdCkge1xuICByZXR1cm4gdHlwZW9mIG9iamVjdCA9PT0gJ29iamVjdCcgJiYgb2JqZWN0ICE9PSBudWxsICYmIG9iamVjdC4kJHR5cGVvZiA9PT0gUkVBQ1RfRUxFTUVOVF9UWVBFO1xufVxuXG52YXIgUmVhY3REZWJ1Z0N1cnJlbnRGcmFtZSA9IHt9O1xuXG57XG4gIC8vIENvbXBvbmVudCB0aGF0IGlzIGJlaW5nIHdvcmtlZCBvblxuICBSZWFjdERlYnVnQ3VycmVudEZyYW1lLmdldEN1cnJlbnRTdGFjayA9IG51bGw7XG5cbiAgUmVhY3REZWJ1Z0N1cnJlbnRGcmFtZS5nZXRTdGFja0FkZGVuZHVtID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciBpbXBsID0gUmVhY3REZWJ1Z0N1cnJlbnRGcmFtZS5nZXRDdXJyZW50U3RhY2s7XG4gICAgaWYgKGltcGwpIHtcbiAgICAgIHJldHVybiBpbXBsKCk7XG4gICAgfVxuICAgIHJldHVybiBudWxsO1xuICB9O1xufVxuXG52YXIgU0VQQVJBVE9SID0gJy4nO1xudmFyIFNVQlNFUEFSQVRPUiA9ICc6JztcblxuLyoqXG4gKiBFc2NhcGUgYW5kIHdyYXAga2V5IHNvIGl0IGlzIHNhZmUgdG8gdXNlIGFzIGEgcmVhY3RpZFxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgdG8gYmUgZXNjYXBlZC5cbiAqIEByZXR1cm4ge3N0cmluZ30gdGhlIGVzY2FwZWQga2V5LlxuICovXG5mdW5jdGlvbiBlc2NhcGUoa2V5KSB7XG4gIHZhciBlc2NhcGVSZWdleCA9IC9bPTpdL2c7XG4gIHZhciBlc2NhcGVyTG9va3VwID0ge1xuICAgICc9JzogJz0wJyxcbiAgICAnOic6ICc9MidcbiAgfTtcbiAgdmFyIGVzY2FwZWRTdHJpbmcgPSAoJycgKyBrZXkpLnJlcGxhY2UoZXNjYXBlUmVnZXgsIGZ1bmN0aW9uIChtYXRjaCkge1xuICAgIHJldHVybiBlc2NhcGVyTG9va3VwW21hdGNoXTtcbiAgfSk7XG5cbiAgcmV0dXJuICckJyArIGVzY2FwZWRTdHJpbmc7XG59XG5cbi8qKlxuICogVE9ETzogVGVzdCB0aGF0IGEgc2luZ2xlIGNoaWxkIGFuZCBhbiBhcnJheSB3aXRoIG9uZSBpdGVtIGhhdmUgdGhlIHNhbWUga2V5XG4gKiBwYXR0ZXJuLlxuICovXG5cbnZhciBkaWRXYXJuQWJvdXRNYXBzID0gZmFsc2U7XG5cbnZhciB1c2VyUHJvdmlkZWRLZXlFc2NhcGVSZWdleCA9IC9cXC8rL2c7XG5mdW5jdGlvbiBlc2NhcGVVc2VyUHJvdmlkZWRLZXkodGV4dCkge1xuICByZXR1cm4gKCcnICsgdGV4dCkucmVwbGFjZSh1c2VyUHJvdmlkZWRLZXlFc2NhcGVSZWdleCwgJyQmLycpO1xufVxuXG52YXIgUE9PTF9TSVpFID0gMTA7XG52YXIgdHJhdmVyc2VDb250ZXh0UG9vbCA9IFtdO1xuZnVuY3Rpb24gZ2V0UG9vbGVkVHJhdmVyc2VDb250ZXh0KG1hcFJlc3VsdCwga2V5UHJlZml4LCBtYXBGdW5jdGlvbiwgbWFwQ29udGV4dCkge1xuICBpZiAodHJhdmVyc2VDb250ZXh0UG9vbC5sZW5ndGgpIHtcbiAgICB2YXIgdHJhdmVyc2VDb250ZXh0ID0gdHJhdmVyc2VDb250ZXh0UG9vbC5wb3AoKTtcbiAgICB0cmF2ZXJzZUNvbnRleHQucmVzdWx0ID0gbWFwUmVzdWx0O1xuICAgIHRyYXZlcnNlQ29udGV4dC5rZXlQcmVmaXggPSBrZXlQcmVmaXg7XG4gICAgdHJhdmVyc2VDb250ZXh0LmZ1bmMgPSBtYXBGdW5jdGlvbjtcbiAgICB0cmF2ZXJzZUNvbnRleHQuY29udGV4dCA9IG1hcENvbnRleHQ7XG4gICAgdHJhdmVyc2VDb250ZXh0LmNvdW50ID0gMDtcbiAgICByZXR1cm4gdHJhdmVyc2VDb250ZXh0O1xuICB9IGVsc2Uge1xuICAgIHJldHVybiB7XG4gICAgICByZXN1bHQ6IG1hcFJlc3VsdCxcbiAgICAgIGtleVByZWZpeDoga2V5UHJlZml4LFxuICAgICAgZnVuYzogbWFwRnVuY3Rpb24sXG4gICAgICBjb250ZXh0OiBtYXBDb250ZXh0LFxuICAgICAgY291bnQ6IDBcbiAgICB9O1xuICB9XG59XG5cbmZ1bmN0aW9uIHJlbGVhc2VUcmF2ZXJzZUNvbnRleHQodHJhdmVyc2VDb250ZXh0KSB7XG4gIHRyYXZlcnNlQ29udGV4dC5yZXN1bHQgPSBudWxsO1xuICB0cmF2ZXJzZUNvbnRleHQua2V5UHJlZml4ID0gbnVsbDtcbiAgdHJhdmVyc2VDb250ZXh0LmZ1bmMgPSBudWxsO1xuICB0cmF2ZXJzZUNvbnRleHQuY29udGV4dCA9IG51bGw7XG4gIHRyYXZlcnNlQ29udGV4dC5jb3VudCA9IDA7XG4gIGlmICh0cmF2ZXJzZUNvbnRleHRQb29sLmxlbmd0aCA8IFBPT0xfU0laRSkge1xuICAgIHRyYXZlcnNlQ29udGV4dFBvb2wucHVzaCh0cmF2ZXJzZUNvbnRleHQpO1xuICB9XG59XG5cbi8qKlxuICogQHBhcmFtIHs/Kn0gY2hpbGRyZW4gQ2hpbGRyZW4gdHJlZSBjb250YWluZXIuXG4gKiBAcGFyYW0geyFzdHJpbmd9IG5hbWVTb0ZhciBOYW1lIG9mIHRoZSBrZXkgcGF0aCBzbyBmYXIuXG4gKiBAcGFyYW0geyFmdW5jdGlvbn0gY2FsbGJhY2sgQ2FsbGJhY2sgdG8gaW52b2tlIHdpdGggZWFjaCBjaGlsZCBmb3VuZC5cbiAqIEBwYXJhbSB7Pyp9IHRyYXZlcnNlQ29udGV4dCBVc2VkIHRvIHBhc3MgaW5mb3JtYXRpb24gdGhyb3VnaG91dCB0aGUgdHJhdmVyc2FsXG4gKiBwcm9jZXNzLlxuICogQHJldHVybiB7IW51bWJlcn0gVGhlIG51bWJlciBvZiBjaGlsZHJlbiBpbiB0aGlzIHN1YnRyZWUuXG4gKi9cbmZ1bmN0aW9uIHRyYXZlcnNlQWxsQ2hpbGRyZW5JbXBsKGNoaWxkcmVuLCBuYW1lU29GYXIsIGNhbGxiYWNrLCB0cmF2ZXJzZUNvbnRleHQpIHtcbiAgdmFyIHR5cGUgPSB0eXBlb2YgY2hpbGRyZW47XG5cbiAgaWYgKHR5cGUgPT09ICd1bmRlZmluZWQnIHx8IHR5cGUgPT09ICdib29sZWFuJykge1xuICAgIC8vIEFsbCBvZiB0aGUgYWJvdmUgYXJlIHBlcmNlaXZlZCBhcyBudWxsLlxuICAgIGNoaWxkcmVuID0gbnVsbDtcbiAgfVxuXG4gIHZhciBpbnZva2VDYWxsYmFjayA9IGZhbHNlO1xuXG4gIGlmIChjaGlsZHJlbiA9PT0gbnVsbCkge1xuICAgIGludm9rZUNhbGxiYWNrID0gdHJ1ZTtcbiAgfSBlbHNlIHtcbiAgICBzd2l0Y2ggKHR5cGUpIHtcbiAgICAgIGNhc2UgJ3N0cmluZyc6XG4gICAgICBjYXNlICdudW1iZXInOlxuICAgICAgICBpbnZva2VDYWxsYmFjayA9IHRydWU7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAnb2JqZWN0JzpcbiAgICAgICAgc3dpdGNoIChjaGlsZHJlbi4kJHR5cGVvZikge1xuICAgICAgICAgIGNhc2UgUkVBQ1RfRUxFTUVOVF9UWVBFOlxuICAgICAgICAgIGNhc2UgUkVBQ1RfUE9SVEFMX1RZUEU6XG4gICAgICAgICAgICBpbnZva2VDYWxsYmFjayA9IHRydWU7XG4gICAgICAgIH1cbiAgICB9XG4gIH1cblxuICBpZiAoaW52b2tlQ2FsbGJhY2spIHtcbiAgICBjYWxsYmFjayh0cmF2ZXJzZUNvbnRleHQsIGNoaWxkcmVuLFxuICAgIC8vIElmIGl0J3MgdGhlIG9ubHkgY2hpbGQsIHRyZWF0IHRoZSBuYW1lIGFzIGlmIGl0IHdhcyB3cmFwcGVkIGluIGFuIGFycmF5XG4gICAgLy8gc28gdGhhdCBpdCdzIGNvbnNpc3RlbnQgaWYgdGhlIG51bWJlciBvZiBjaGlsZHJlbiBncm93cy5cbiAgICBuYW1lU29GYXIgPT09ICcnID8gU0VQQVJBVE9SICsgZ2V0Q29tcG9uZW50S2V5KGNoaWxkcmVuLCAwKSA6IG5hbWVTb0Zhcik7XG4gICAgcmV0dXJuIDE7XG4gIH1cblxuICB2YXIgY2hpbGQgPSB2b2lkIDA7XG4gIHZhciBuZXh0TmFtZSA9IHZvaWQgMDtcbiAgdmFyIHN1YnRyZWVDb3VudCA9IDA7IC8vIENvdW50IG9mIGNoaWxkcmVuIGZvdW5kIGluIHRoZSBjdXJyZW50IHN1YnRyZWUuXG4gIHZhciBuZXh0TmFtZVByZWZpeCA9IG5hbWVTb0ZhciA9PT0gJycgPyBTRVBBUkFUT1IgOiBuYW1lU29GYXIgKyBTVUJTRVBBUkFUT1I7XG5cbiAgaWYgKEFycmF5LmlzQXJyYXkoY2hpbGRyZW4pKSB7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjaGlsZHJlbi5sZW5ndGg7IGkrKykge1xuICAgICAgY2hpbGQgPSBjaGlsZHJlbltpXTtcbiAgICAgIG5leHROYW1lID0gbmV4dE5hbWVQcmVmaXggKyBnZXRDb21wb25lbnRLZXkoY2hpbGQsIGkpO1xuICAgICAgc3VidHJlZUNvdW50ICs9IHRyYXZlcnNlQWxsQ2hpbGRyZW5JbXBsKGNoaWxkLCBuZXh0TmFtZSwgY2FsbGJhY2ssIHRyYXZlcnNlQ29udGV4dCk7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIHZhciBpdGVyYXRvckZuID0gZ2V0SXRlcmF0b3JGbihjaGlsZHJlbik7XG4gICAgaWYgKHR5cGVvZiBpdGVyYXRvckZuID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICB7XG4gICAgICAgIC8vIFdhcm4gYWJvdXQgdXNpbmcgTWFwcyBhcyBjaGlsZHJlblxuICAgICAgICBpZiAoaXRlcmF0b3JGbiA9PT0gY2hpbGRyZW4uZW50cmllcykge1xuICAgICAgICAgICFkaWRXYXJuQWJvdXRNYXBzID8gd2FybmluZyhmYWxzZSwgJ1VzaW5nIE1hcHMgYXMgY2hpbGRyZW4gaXMgdW5zdXBwb3J0ZWQgYW5kIHdpbGwgbGlrZWx5IHlpZWxkICcgKyAndW5leHBlY3RlZCByZXN1bHRzLiBDb252ZXJ0IGl0IHRvIGEgc2VxdWVuY2UvaXRlcmFibGUgb2Yga2V5ZWQgJyArICdSZWFjdEVsZW1lbnRzIGluc3RlYWQuJXMnLCBSZWFjdERlYnVnQ3VycmVudEZyYW1lLmdldFN0YWNrQWRkZW5kdW0oKSkgOiB2b2lkIDA7XG4gICAgICAgICAgZGlkV2FybkFib3V0TWFwcyA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgdmFyIGl0ZXJhdG9yID0gaXRlcmF0b3JGbi5jYWxsKGNoaWxkcmVuKTtcbiAgICAgIHZhciBzdGVwID0gdm9pZCAwO1xuICAgICAgdmFyIGlpID0gMDtcbiAgICAgIHdoaWxlICghKHN0ZXAgPSBpdGVyYXRvci5uZXh0KCkpLmRvbmUpIHtcbiAgICAgICAgY2hpbGQgPSBzdGVwLnZhbHVlO1xuICAgICAgICBuZXh0TmFtZSA9IG5leHROYW1lUHJlZml4ICsgZ2V0Q29tcG9uZW50S2V5KGNoaWxkLCBpaSsrKTtcbiAgICAgICAgc3VidHJlZUNvdW50ICs9IHRyYXZlcnNlQWxsQ2hpbGRyZW5JbXBsKGNoaWxkLCBuZXh0TmFtZSwgY2FsbGJhY2ssIHRyYXZlcnNlQ29udGV4dCk7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmICh0eXBlID09PSAnb2JqZWN0Jykge1xuICAgICAgdmFyIGFkZGVuZHVtID0gJyc7XG4gICAgICB7XG4gICAgICAgIGFkZGVuZHVtID0gJyBJZiB5b3UgbWVhbnQgdG8gcmVuZGVyIGEgY29sbGVjdGlvbiBvZiBjaGlsZHJlbiwgdXNlIGFuIGFycmF5ICcgKyAnaW5zdGVhZC4nICsgUmVhY3REZWJ1Z0N1cnJlbnRGcmFtZS5nZXRTdGFja0FkZGVuZHVtKCk7XG4gICAgICB9XG4gICAgICB2YXIgY2hpbGRyZW5TdHJpbmcgPSAnJyArIGNoaWxkcmVuO1xuICAgICAgaW52YXJpYW50KGZhbHNlLCAnT2JqZWN0cyBhcmUgbm90IHZhbGlkIGFzIGEgUmVhY3QgY2hpbGQgKGZvdW5kOiAlcykuJXMnLCBjaGlsZHJlblN0cmluZyA9PT0gJ1tvYmplY3QgT2JqZWN0XScgPyAnb2JqZWN0IHdpdGgga2V5cyB7JyArIE9iamVjdC5rZXlzKGNoaWxkcmVuKS5qb2luKCcsICcpICsgJ30nIDogY2hpbGRyZW5TdHJpbmcsIGFkZGVuZHVtKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gc3VidHJlZUNvdW50O1xufVxuXG4vKipcbiAqIFRyYXZlcnNlcyBjaGlsZHJlbiB0aGF0IGFyZSB0eXBpY2FsbHkgc3BlY2lmaWVkIGFzIGBwcm9wcy5jaGlsZHJlbmAsIGJ1dFxuICogbWlnaHQgYWxzbyBiZSBzcGVjaWZpZWQgdGhyb3VnaCBhdHRyaWJ1dGVzOlxuICpcbiAqIC0gYHRyYXZlcnNlQWxsQ2hpbGRyZW4odGhpcy5wcm9wcy5jaGlsZHJlbiwgLi4uKWBcbiAqIC0gYHRyYXZlcnNlQWxsQ2hpbGRyZW4odGhpcy5wcm9wcy5sZWZ0UGFuZWxDaGlsZHJlbiwgLi4uKWBcbiAqXG4gKiBUaGUgYHRyYXZlcnNlQ29udGV4dGAgaXMgYW4gb3B0aW9uYWwgYXJndW1lbnQgdGhhdCBpcyBwYXNzZWQgdGhyb3VnaCB0aGVcbiAqIGVudGlyZSB0cmF2ZXJzYWwuIEl0IGNhbiBiZSB1c2VkIHRvIHN0b3JlIGFjY3VtdWxhdGlvbnMgb3IgYW55dGhpbmcgZWxzZSB0aGF0XG4gKiB0aGUgY2FsbGJhY2sgbWlnaHQgZmluZCByZWxldmFudC5cbiAqXG4gKiBAcGFyYW0gez8qfSBjaGlsZHJlbiBDaGlsZHJlbiB0cmVlIG9iamVjdC5cbiAqIEBwYXJhbSB7IWZ1bmN0aW9ufSBjYWxsYmFjayBUbyBpbnZva2UgdXBvbiB0cmF2ZXJzaW5nIGVhY2ggY2hpbGQuXG4gKiBAcGFyYW0gez8qfSB0cmF2ZXJzZUNvbnRleHQgQ29udGV4dCBmb3IgdHJhdmVyc2FsLlxuICogQHJldHVybiB7IW51bWJlcn0gVGhlIG51bWJlciBvZiBjaGlsZHJlbiBpbiB0aGlzIHN1YnRyZWUuXG4gKi9cbmZ1bmN0aW9uIHRyYXZlcnNlQWxsQ2hpbGRyZW4oY2hpbGRyZW4sIGNhbGxiYWNrLCB0cmF2ZXJzZUNvbnRleHQpIHtcbiAgaWYgKGNoaWxkcmVuID09IG51bGwpIHtcbiAgICByZXR1cm4gMDtcbiAgfVxuXG4gIHJldHVybiB0cmF2ZXJzZUFsbENoaWxkcmVuSW1wbChjaGlsZHJlbiwgJycsIGNhbGxiYWNrLCB0cmF2ZXJzZUNvbnRleHQpO1xufVxuXG4vKipcbiAqIEdlbmVyYXRlIGEga2V5IHN0cmluZyB0aGF0IGlkZW50aWZpZXMgYSBjb21wb25lbnQgd2l0aGluIGEgc2V0LlxuICpcbiAqIEBwYXJhbSB7Kn0gY29tcG9uZW50IEEgY29tcG9uZW50IHRoYXQgY291bGQgY29udGFpbiBhIG1hbnVhbCBrZXkuXG4gKiBAcGFyYW0ge251bWJlcn0gaW5kZXggSW5kZXggdGhhdCBpcyB1c2VkIGlmIGEgbWFudWFsIGtleSBpcyBub3QgcHJvdmlkZWQuXG4gKiBAcmV0dXJuIHtzdHJpbmd9XG4gKi9cbmZ1bmN0aW9uIGdldENvbXBvbmVudEtleShjb21wb25lbnQsIGluZGV4KSB7XG4gIC8vIERvIHNvbWUgdHlwZWNoZWNraW5nIGhlcmUgc2luY2Ugd2UgY2FsbCB0aGlzIGJsaW5kbHkuIFdlIHdhbnQgdG8gZW5zdXJlXG4gIC8vIHRoYXQgd2UgZG9uJ3QgYmxvY2sgcG90ZW50aWFsIGZ1dHVyZSBFUyBBUElzLlxuICBpZiAodHlwZW9mIGNvbXBvbmVudCA9PT0gJ29iamVjdCcgJiYgY29tcG9uZW50ICE9PSBudWxsICYmIGNvbXBvbmVudC5rZXkgIT0gbnVsbCkge1xuICAgIC8vIEV4cGxpY2l0IGtleVxuICAgIHJldHVybiBlc2NhcGUoY29tcG9uZW50LmtleSk7XG4gIH1cbiAgLy8gSW1wbGljaXQga2V5IGRldGVybWluZWQgYnkgdGhlIGluZGV4IGluIHRoZSBzZXRcbiAgcmV0dXJuIGluZGV4LnRvU3RyaW5nKDM2KTtcbn1cblxuZnVuY3Rpb24gZm9yRWFjaFNpbmdsZUNoaWxkKGJvb2tLZWVwaW5nLCBjaGlsZCwgbmFtZSkge1xuICB2YXIgZnVuYyA9IGJvb2tLZWVwaW5nLmZ1bmMsXG4gICAgICBjb250ZXh0ID0gYm9va0tlZXBpbmcuY29udGV4dDtcblxuICBmdW5jLmNhbGwoY29udGV4dCwgY2hpbGQsIGJvb2tLZWVwaW5nLmNvdW50KyspO1xufVxuXG4vKipcbiAqIEl0ZXJhdGVzIHRocm91Z2ggY2hpbGRyZW4gdGhhdCBhcmUgdHlwaWNhbGx5IHNwZWNpZmllZCBhcyBgcHJvcHMuY2hpbGRyZW5gLlxuICpcbiAqIFNlZSBodHRwczovL3JlYWN0anMub3JnL2RvY3MvcmVhY3QtYXBpLmh0bWwjcmVhY3QuY2hpbGRyZW4uZm9yZWFjaFxuICpcbiAqIFRoZSBwcm92aWRlZCBmb3JFYWNoRnVuYyhjaGlsZCwgaW5kZXgpIHdpbGwgYmUgY2FsbGVkIGZvciBlYWNoXG4gKiBsZWFmIGNoaWxkLlxuICpcbiAqIEBwYXJhbSB7Pyp9IGNoaWxkcmVuIENoaWxkcmVuIHRyZWUgY29udGFpbmVyLlxuICogQHBhcmFtIHtmdW5jdGlvbigqLCBpbnQpfSBmb3JFYWNoRnVuY1xuICogQHBhcmFtIHsqfSBmb3JFYWNoQ29udGV4dCBDb250ZXh0IGZvciBmb3JFYWNoQ29udGV4dC5cbiAqL1xuZnVuY3Rpb24gZm9yRWFjaENoaWxkcmVuKGNoaWxkcmVuLCBmb3JFYWNoRnVuYywgZm9yRWFjaENvbnRleHQpIHtcbiAgaWYgKGNoaWxkcmVuID09IG51bGwpIHtcbiAgICByZXR1cm4gY2hpbGRyZW47XG4gIH1cbiAgdmFyIHRyYXZlcnNlQ29udGV4dCA9IGdldFBvb2xlZFRyYXZlcnNlQ29udGV4dChudWxsLCBudWxsLCBmb3JFYWNoRnVuYywgZm9yRWFjaENvbnRleHQpO1xuICB0cmF2ZXJzZUFsbENoaWxkcmVuKGNoaWxkcmVuLCBmb3JFYWNoU2luZ2xlQ2hpbGQsIHRyYXZlcnNlQ29udGV4dCk7XG4gIHJlbGVhc2VUcmF2ZXJzZUNvbnRleHQodHJhdmVyc2VDb250ZXh0KTtcbn1cblxuZnVuY3Rpb24gbWFwU2luZ2xlQ2hpbGRJbnRvQ29udGV4dChib29rS2VlcGluZywgY2hpbGQsIGNoaWxkS2V5KSB7XG4gIHZhciByZXN1bHQgPSBib29rS2VlcGluZy5yZXN1bHQsXG4gICAgICBrZXlQcmVmaXggPSBib29rS2VlcGluZy5rZXlQcmVmaXgsXG4gICAgICBmdW5jID0gYm9va0tlZXBpbmcuZnVuYyxcbiAgICAgIGNvbnRleHQgPSBib29rS2VlcGluZy5jb250ZXh0O1xuXG5cbiAgdmFyIG1hcHBlZENoaWxkID0gZnVuYy5jYWxsKGNvbnRleHQsIGNoaWxkLCBib29rS2VlcGluZy5jb3VudCsrKTtcbiAgaWYgKEFycmF5LmlzQXJyYXkobWFwcGVkQ2hpbGQpKSB7XG4gICAgbWFwSW50b1dpdGhLZXlQcmVmaXhJbnRlcm5hbChtYXBwZWRDaGlsZCwgcmVzdWx0LCBjaGlsZEtleSwgZW1wdHlGdW5jdGlvbi50aGF0UmV0dXJuc0FyZ3VtZW50KTtcbiAgfSBlbHNlIGlmIChtYXBwZWRDaGlsZCAhPSBudWxsKSB7XG4gICAgaWYgKGlzVmFsaWRFbGVtZW50KG1hcHBlZENoaWxkKSkge1xuICAgICAgbWFwcGVkQ2hpbGQgPSBjbG9uZUFuZFJlcGxhY2VLZXkobWFwcGVkQ2hpbGQsXG4gICAgICAvLyBLZWVwIGJvdGggdGhlIChtYXBwZWQpIGFuZCBvbGQga2V5cyBpZiB0aGV5IGRpZmZlciwganVzdCBhc1xuICAgICAgLy8gdHJhdmVyc2VBbGxDaGlsZHJlbiB1c2VkIHRvIGRvIGZvciBvYmplY3RzIGFzIGNoaWxkcmVuXG4gICAgICBrZXlQcmVmaXggKyAobWFwcGVkQ2hpbGQua2V5ICYmICghY2hpbGQgfHwgY2hpbGQua2V5ICE9PSBtYXBwZWRDaGlsZC5rZXkpID8gZXNjYXBlVXNlclByb3ZpZGVkS2V5KG1hcHBlZENoaWxkLmtleSkgKyAnLycgOiAnJykgKyBjaGlsZEtleSk7XG4gICAgfVxuICAgIHJlc3VsdC5wdXNoKG1hcHBlZENoaWxkKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBtYXBJbnRvV2l0aEtleVByZWZpeEludGVybmFsKGNoaWxkcmVuLCBhcnJheSwgcHJlZml4LCBmdW5jLCBjb250ZXh0KSB7XG4gIHZhciBlc2NhcGVkUHJlZml4ID0gJyc7XG4gIGlmIChwcmVmaXggIT0gbnVsbCkge1xuICAgIGVzY2FwZWRQcmVmaXggPSBlc2NhcGVVc2VyUHJvdmlkZWRLZXkocHJlZml4KSArICcvJztcbiAgfVxuICB2YXIgdHJhdmVyc2VDb250ZXh0ID0gZ2V0UG9vbGVkVHJhdmVyc2VDb250ZXh0KGFycmF5LCBlc2NhcGVkUHJlZml4LCBmdW5jLCBjb250ZXh0KTtcbiAgdHJhdmVyc2VBbGxDaGlsZHJlbihjaGlsZHJlbiwgbWFwU2luZ2xlQ2hpbGRJbnRvQ29udGV4dCwgdHJhdmVyc2VDb250ZXh0KTtcbiAgcmVsZWFzZVRyYXZlcnNlQ29udGV4dCh0cmF2ZXJzZUNvbnRleHQpO1xufVxuXG4vKipcbiAqIE1hcHMgY2hpbGRyZW4gdGhhdCBhcmUgdHlwaWNhbGx5IHNwZWNpZmllZCBhcyBgcHJvcHMuY2hpbGRyZW5gLlxuICpcbiAqIFNlZSBodHRwczovL3JlYWN0anMub3JnL2RvY3MvcmVhY3QtYXBpLmh0bWwjcmVhY3QuY2hpbGRyZW4ubWFwXG4gKlxuICogVGhlIHByb3ZpZGVkIG1hcEZ1bmN0aW9uKGNoaWxkLCBrZXksIGluZGV4KSB3aWxsIGJlIGNhbGxlZCBmb3IgZWFjaFxuICogbGVhZiBjaGlsZC5cbiAqXG4gKiBAcGFyYW0gez8qfSBjaGlsZHJlbiBDaGlsZHJlbiB0cmVlIGNvbnRhaW5lci5cbiAqIEBwYXJhbSB7ZnVuY3Rpb24oKiwgaW50KX0gZnVuYyBUaGUgbWFwIGZ1bmN0aW9uLlxuICogQHBhcmFtIHsqfSBjb250ZXh0IENvbnRleHQgZm9yIG1hcEZ1bmN0aW9uLlxuICogQHJldHVybiB7b2JqZWN0fSBPYmplY3QgY29udGFpbmluZyB0aGUgb3JkZXJlZCBtYXAgb2YgcmVzdWx0cy5cbiAqL1xuZnVuY3Rpb24gbWFwQ2hpbGRyZW4oY2hpbGRyZW4sIGZ1bmMsIGNvbnRleHQpIHtcbiAgaWYgKGNoaWxkcmVuID09IG51bGwpIHtcbiAgICByZXR1cm4gY2hpbGRyZW47XG4gIH1cbiAgdmFyIHJlc3VsdCA9IFtdO1xuICBtYXBJbnRvV2l0aEtleVByZWZpeEludGVybmFsKGNoaWxkcmVuLCByZXN1bHQsIG51bGwsIGZ1bmMsIGNvbnRleHQpO1xuICByZXR1cm4gcmVzdWx0O1xufVxuXG4vKipcbiAqIENvdW50IHRoZSBudW1iZXIgb2YgY2hpbGRyZW4gdGhhdCBhcmUgdHlwaWNhbGx5IHNwZWNpZmllZCBhc1xuICogYHByb3BzLmNoaWxkcmVuYC5cbiAqXG4gKiBTZWUgaHR0cHM6Ly9yZWFjdGpzLm9yZy9kb2NzL3JlYWN0LWFwaS5odG1sI3JlYWN0LmNoaWxkcmVuLmNvdW50XG4gKlxuICogQHBhcmFtIHs/Kn0gY2hpbGRyZW4gQ2hpbGRyZW4gdHJlZSBjb250YWluZXIuXG4gKiBAcmV0dXJuIHtudW1iZXJ9IFRoZSBudW1iZXIgb2YgY2hpbGRyZW4uXG4gKi9cbmZ1bmN0aW9uIGNvdW50Q2hpbGRyZW4oY2hpbGRyZW4sIGNvbnRleHQpIHtcbiAgcmV0dXJuIHRyYXZlcnNlQWxsQ2hpbGRyZW4oY2hpbGRyZW4sIGVtcHR5RnVuY3Rpb24udGhhdFJldHVybnNOdWxsLCBudWxsKTtcbn1cblxuLyoqXG4gKiBGbGF0dGVuIGEgY2hpbGRyZW4gb2JqZWN0ICh0eXBpY2FsbHkgc3BlY2lmaWVkIGFzIGBwcm9wcy5jaGlsZHJlbmApIGFuZFxuICogcmV0dXJuIGFuIGFycmF5IHdpdGggYXBwcm9wcmlhdGVseSByZS1rZXllZCBjaGlsZHJlbi5cbiAqXG4gKiBTZWUgaHR0cHM6Ly9yZWFjdGpzLm9yZy9kb2NzL3JlYWN0LWFwaS5odG1sI3JlYWN0LmNoaWxkcmVuLnRvYXJyYXlcbiAqL1xuZnVuY3Rpb24gdG9BcnJheShjaGlsZHJlbikge1xuICB2YXIgcmVzdWx0ID0gW107XG4gIG1hcEludG9XaXRoS2V5UHJlZml4SW50ZXJuYWwoY2hpbGRyZW4sIHJlc3VsdCwgbnVsbCwgZW1wdHlGdW5jdGlvbi50aGF0UmV0dXJuc0FyZ3VtZW50KTtcbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxuLyoqXG4gKiBSZXR1cm5zIHRoZSBmaXJzdCBjaGlsZCBpbiBhIGNvbGxlY3Rpb24gb2YgY2hpbGRyZW4gYW5kIHZlcmlmaWVzIHRoYXQgdGhlcmVcbiAqIGlzIG9ubHkgb25lIGNoaWxkIGluIHRoZSBjb2xsZWN0aW9uLlxuICpcbiAqIFNlZSBodHRwczovL3JlYWN0anMub3JnL2RvY3MvcmVhY3QtYXBpLmh0bWwjcmVhY3QuY2hpbGRyZW4ub25seVxuICpcbiAqIFRoZSBjdXJyZW50IGltcGxlbWVudGF0aW9uIG9mIHRoaXMgZnVuY3Rpb24gYXNzdW1lcyB0aGF0IGEgc2luZ2xlIGNoaWxkIGdldHNcbiAqIHBhc3NlZCB3aXRob3V0IGEgd3JhcHBlciwgYnV0IHRoZSBwdXJwb3NlIG9mIHRoaXMgaGVscGVyIGZ1bmN0aW9uIGlzIHRvXG4gKiBhYnN0cmFjdCBhd2F5IHRoZSBwYXJ0aWN1bGFyIHN0cnVjdHVyZSBvZiBjaGlsZHJlbi5cbiAqXG4gKiBAcGFyYW0gez9vYmplY3R9IGNoaWxkcmVuIENoaWxkIGNvbGxlY3Rpb24gc3RydWN0dXJlLlxuICogQHJldHVybiB7UmVhY3RFbGVtZW50fSBUaGUgZmlyc3QgYW5kIG9ubHkgYFJlYWN0RWxlbWVudGAgY29udGFpbmVkIGluIHRoZVxuICogc3RydWN0dXJlLlxuICovXG5mdW5jdGlvbiBvbmx5Q2hpbGQoY2hpbGRyZW4pIHtcbiAgIWlzVmFsaWRFbGVtZW50KGNoaWxkcmVuKSA/IGludmFyaWFudChmYWxzZSwgJ1JlYWN0LkNoaWxkcmVuLm9ubHkgZXhwZWN0ZWQgdG8gcmVjZWl2ZSBhIHNpbmdsZSBSZWFjdCBlbGVtZW50IGNoaWxkLicpIDogdm9pZCAwO1xuICByZXR1cm4gY2hpbGRyZW47XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZUNvbnRleHQoZGVmYXVsdFZhbHVlLCBjYWxjdWxhdGVDaGFuZ2VkQml0cykge1xuICBpZiAoY2FsY3VsYXRlQ2hhbmdlZEJpdHMgPT09IHVuZGVmaW5lZCkge1xuICAgIGNhbGN1bGF0ZUNoYW5nZWRCaXRzID0gbnVsbDtcbiAgfSBlbHNlIHtcbiAgICB7XG4gICAgICAhKGNhbGN1bGF0ZUNoYW5nZWRCaXRzID09PSBudWxsIHx8IHR5cGVvZiBjYWxjdWxhdGVDaGFuZ2VkQml0cyA9PT0gJ2Z1bmN0aW9uJykgPyB3YXJuaW5nKGZhbHNlLCAnY3JlYXRlQ29udGV4dDogRXhwZWN0ZWQgdGhlIG9wdGlvbmFsIHNlY29uZCBhcmd1bWVudCB0byBiZSBhICcgKyAnZnVuY3Rpb24uIEluc3RlYWQgcmVjZWl2ZWQ6ICVzJywgY2FsY3VsYXRlQ2hhbmdlZEJpdHMpIDogdm9pZCAwO1xuICAgIH1cbiAgfVxuXG4gIHZhciBjb250ZXh0ID0ge1xuICAgICQkdHlwZW9mOiBSRUFDVF9DT05URVhUX1RZUEUsXG4gICAgX2NhbGN1bGF0ZUNoYW5nZWRCaXRzOiBjYWxjdWxhdGVDaGFuZ2VkQml0cyxcbiAgICBfZGVmYXVsdFZhbHVlOiBkZWZhdWx0VmFsdWUsXG4gICAgX2N1cnJlbnRWYWx1ZTogZGVmYXVsdFZhbHVlLFxuICAgIF9jaGFuZ2VkQml0czogMCxcbiAgICAvLyBUaGVzZSBhcmUgY2lyY3VsYXJcbiAgICBQcm92aWRlcjogbnVsbCxcbiAgICBDb25zdW1lcjogbnVsbFxuICB9O1xuXG4gIGNvbnRleHQuUHJvdmlkZXIgPSB7XG4gICAgJCR0eXBlb2Y6IFJFQUNUX1BST1ZJREVSX1RZUEUsXG4gICAgX2NvbnRleHQ6IGNvbnRleHRcbiAgfTtcbiAgY29udGV4dC5Db25zdW1lciA9IGNvbnRleHQ7XG5cbiAge1xuICAgIGNvbnRleHQuX2N1cnJlbnRSZW5kZXJlciA9IG51bGw7XG4gIH1cblxuICByZXR1cm4gY29udGV4dDtcbn1cblxuZnVuY3Rpb24gZm9yd2FyZFJlZihyZW5kZXIpIHtcbiAge1xuICAgICEodHlwZW9mIHJlbmRlciA9PT0gJ2Z1bmN0aW9uJykgPyB3YXJuaW5nKGZhbHNlLCAnZm9yd2FyZFJlZiByZXF1aXJlcyBhIHJlbmRlciBmdW5jdGlvbiBidXQgd2FzIGdpdmVuICVzLicsIHJlbmRlciA9PT0gbnVsbCA/ICdudWxsJyA6IHR5cGVvZiByZW5kZXIpIDogdm9pZCAwO1xuICB9XG5cbiAgcmV0dXJuIHtcbiAgICAkJHR5cGVvZjogUkVBQ1RfRk9SV0FSRF9SRUZfVFlQRSxcbiAgICByZW5kZXI6IHJlbmRlclxuICB9O1xufVxuXG52YXIgZGVzY3JpYmVDb21wb25lbnRGcmFtZSA9IGZ1bmN0aW9uIChuYW1lLCBzb3VyY2UsIG93bmVyTmFtZSkge1xuICByZXR1cm4gJ1xcbiAgICBpbiAnICsgKG5hbWUgfHwgJ1Vua25vd24nKSArIChzb3VyY2UgPyAnIChhdCAnICsgc291cmNlLmZpbGVOYW1lLnJlcGxhY2UoL14uKltcXFxcXFwvXS8sICcnKSArICc6JyArIHNvdXJjZS5saW5lTnVtYmVyICsgJyknIDogb3duZXJOYW1lID8gJyAoY3JlYXRlZCBieSAnICsgb3duZXJOYW1lICsgJyknIDogJycpO1xufTtcblxuZnVuY3Rpb24gaXNWYWxpZEVsZW1lbnRUeXBlKHR5cGUpIHtcbiAgcmV0dXJuIHR5cGVvZiB0eXBlID09PSAnc3RyaW5nJyB8fCB0eXBlb2YgdHlwZSA9PT0gJ2Z1bmN0aW9uJyB8fFxuICAvLyBOb3RlOiBpdHMgdHlwZW9mIG1pZ2h0IGJlIG90aGVyIHRoYW4gJ3N5bWJvbCcgb3IgJ251bWJlcicgaWYgaXQncyBhIHBvbHlmaWxsLlxuICB0eXBlID09PSBSRUFDVF9GUkFHTUVOVF9UWVBFIHx8IHR5cGUgPT09IFJFQUNUX0FTWU5DX01PREVfVFlQRSB8fCB0eXBlID09PSBSRUFDVF9TVFJJQ1RfTU9ERV9UWVBFIHx8IHR5cGVvZiB0eXBlID09PSAnb2JqZWN0JyAmJiB0eXBlICE9PSBudWxsICYmICh0eXBlLiQkdHlwZW9mID09PSBSRUFDVF9QUk9WSURFUl9UWVBFIHx8IHR5cGUuJCR0eXBlb2YgPT09IFJFQUNUX0NPTlRFWFRfVFlQRSB8fCB0eXBlLiQkdHlwZW9mID09PSBSRUFDVF9GT1JXQVJEX1JFRl9UWVBFKTtcbn1cblxuZnVuY3Rpb24gZ2V0Q29tcG9uZW50TmFtZShmaWJlcikge1xuICB2YXIgdHlwZSA9IGZpYmVyLnR5cGU7XG5cbiAgaWYgKHR5cGVvZiB0eXBlID09PSAnZnVuY3Rpb24nKSB7XG4gICAgcmV0dXJuIHR5cGUuZGlzcGxheU5hbWUgfHwgdHlwZS5uYW1lO1xuICB9XG4gIGlmICh0eXBlb2YgdHlwZSA9PT0gJ3N0cmluZycpIHtcbiAgICByZXR1cm4gdHlwZTtcbiAgfVxuICBzd2l0Y2ggKHR5cGUpIHtcbiAgICBjYXNlIFJFQUNUX0ZSQUdNRU5UX1RZUEU6XG4gICAgICByZXR1cm4gJ1JlYWN0RnJhZ21lbnQnO1xuICAgIGNhc2UgUkVBQ1RfUE9SVEFMX1RZUEU6XG4gICAgICByZXR1cm4gJ1JlYWN0UG9ydGFsJztcbiAgICBjYXNlIFJFQUNUX0NBTExfVFlQRTpcbiAgICAgIHJldHVybiAnUmVhY3RDYWxsJztcbiAgICBjYXNlIFJFQUNUX1JFVFVSTl9UWVBFOlxuICAgICAgcmV0dXJuICdSZWFjdFJldHVybic7XG4gIH1cbiAgaWYgKHR5cGVvZiB0eXBlID09PSAnb2JqZWN0JyAmJiB0eXBlICE9PSBudWxsKSB7XG4gICAgc3dpdGNoICh0eXBlLiQkdHlwZW9mKSB7XG4gICAgICBjYXNlIFJFQUNUX0ZPUldBUkRfUkVGX1RZUEU6XG4gICAgICAgIHZhciBmdW5jdGlvbk5hbWUgPSB0eXBlLnJlbmRlci5kaXNwbGF5TmFtZSB8fCB0eXBlLnJlbmRlci5uYW1lIHx8ICcnO1xuICAgICAgICByZXR1cm4gZnVuY3Rpb25OYW1lICE9PSAnJyA/ICdGb3J3YXJkUmVmKCcgKyBmdW5jdGlvbk5hbWUgKyAnKScgOiAnRm9yd2FyZFJlZic7XG4gICAgfVxuICB9XG4gIHJldHVybiBudWxsO1xufVxuXG4vKipcbiAqIFJlYWN0RWxlbWVudFZhbGlkYXRvciBwcm92aWRlcyBhIHdyYXBwZXIgYXJvdW5kIGEgZWxlbWVudCBmYWN0b3J5XG4gKiB3aGljaCB2YWxpZGF0ZXMgdGhlIHByb3BzIHBhc3NlZCB0byB0aGUgZWxlbWVudC4gVGhpcyBpcyBpbnRlbmRlZCB0byBiZVxuICogdXNlZCBvbmx5IGluIERFViBhbmQgY291bGQgYmUgcmVwbGFjZWQgYnkgYSBzdGF0aWMgdHlwZSBjaGVja2VyIGZvciBsYW5ndWFnZXNcbiAqIHRoYXQgc3VwcG9ydCBpdC5cbiAqL1xuXG52YXIgY3VycmVudGx5VmFsaWRhdGluZ0VsZW1lbnQgPSB2b2lkIDA7XG52YXIgcHJvcFR5cGVzTWlzc3BlbGxXYXJuaW5nU2hvd24gPSB2b2lkIDA7XG5cbnZhciBnZXREaXNwbGF5TmFtZSA9IGZ1bmN0aW9uICgpIHt9O1xudmFyIGdldFN0YWNrQWRkZW5kdW0gPSBmdW5jdGlvbiAoKSB7fTtcblxue1xuICBjdXJyZW50bHlWYWxpZGF0aW5nRWxlbWVudCA9IG51bGw7XG5cbiAgcHJvcFR5cGVzTWlzc3BlbGxXYXJuaW5nU2hvd24gPSBmYWxzZTtcblxuICBnZXREaXNwbGF5TmFtZSA9IGZ1bmN0aW9uIChlbGVtZW50KSB7XG4gICAgaWYgKGVsZW1lbnQgPT0gbnVsbCkge1xuICAgICAgcmV0dXJuICcjZW1wdHknO1xuICAgIH0gZWxzZSBpZiAodHlwZW9mIGVsZW1lbnQgPT09ICdzdHJpbmcnIHx8IHR5cGVvZiBlbGVtZW50ID09PSAnbnVtYmVyJykge1xuICAgICAgcmV0dXJuICcjdGV4dCc7XG4gICAgfSBlbHNlIGlmICh0eXBlb2YgZWxlbWVudC50eXBlID09PSAnc3RyaW5nJykge1xuICAgICAgcmV0dXJuIGVsZW1lbnQudHlwZTtcbiAgICB9IGVsc2UgaWYgKGVsZW1lbnQudHlwZSA9PT0gUkVBQ1RfRlJBR01FTlRfVFlQRSkge1xuICAgICAgcmV0dXJuICdSZWFjdC5GcmFnbWVudCc7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBlbGVtZW50LnR5cGUuZGlzcGxheU5hbWUgfHwgZWxlbWVudC50eXBlLm5hbWUgfHwgJ1Vua25vd24nO1xuICAgIH1cbiAgfTtcblxuICBnZXRTdGFja0FkZGVuZHVtID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciBzdGFjayA9ICcnO1xuICAgIGlmIChjdXJyZW50bHlWYWxpZGF0aW5nRWxlbWVudCkge1xuICAgICAgdmFyIG5hbWUgPSBnZXREaXNwbGF5TmFtZShjdXJyZW50bHlWYWxpZGF0aW5nRWxlbWVudCk7XG4gICAgICB2YXIgb3duZXIgPSBjdXJyZW50bHlWYWxpZGF0aW5nRWxlbWVudC5fb3duZXI7XG4gICAgICBzdGFjayArPSBkZXNjcmliZUNvbXBvbmVudEZyYW1lKG5hbWUsIGN1cnJlbnRseVZhbGlkYXRpbmdFbGVtZW50Ll9zb3VyY2UsIG93bmVyICYmIGdldENvbXBvbmVudE5hbWUob3duZXIpKTtcbiAgICB9XG4gICAgc3RhY2sgKz0gUmVhY3REZWJ1Z0N1cnJlbnRGcmFtZS5nZXRTdGFja0FkZGVuZHVtKCkgfHwgJyc7XG4gICAgcmV0dXJuIHN0YWNrO1xuICB9O1xufVxuXG5mdW5jdGlvbiBnZXREZWNsYXJhdGlvbkVycm9yQWRkZW5kdW0oKSB7XG4gIGlmIChSZWFjdEN1cnJlbnRPd25lci5jdXJyZW50KSB7XG4gICAgdmFyIG5hbWUgPSBnZXRDb21wb25lbnROYW1lKFJlYWN0Q3VycmVudE93bmVyLmN1cnJlbnQpO1xuICAgIGlmIChuYW1lKSB7XG4gICAgICByZXR1cm4gJ1xcblxcbkNoZWNrIHRoZSByZW5kZXIgbWV0aG9kIG9mIGAnICsgbmFtZSArICdgLic7XG4gICAgfVxuICB9XG4gIHJldHVybiAnJztcbn1cblxuZnVuY3Rpb24gZ2V0U291cmNlSW5mb0Vycm9yQWRkZW5kdW0oZWxlbWVudFByb3BzKSB7XG4gIGlmIChlbGVtZW50UHJvcHMgIT09IG51bGwgJiYgZWxlbWVudFByb3BzICE9PSB1bmRlZmluZWQgJiYgZWxlbWVudFByb3BzLl9fc291cmNlICE9PSB1bmRlZmluZWQpIHtcbiAgICB2YXIgc291cmNlID0gZWxlbWVudFByb3BzLl9fc291cmNlO1xuICAgIHZhciBmaWxlTmFtZSA9IHNvdXJjZS5maWxlTmFtZS5yZXBsYWNlKC9eLipbXFxcXFxcL10vLCAnJyk7XG4gICAgdmFyIGxpbmVOdW1iZXIgPSBzb3VyY2UubGluZU51bWJlcjtcbiAgICByZXR1cm4gJ1xcblxcbkNoZWNrIHlvdXIgY29kZSBhdCAnICsgZmlsZU5hbWUgKyAnOicgKyBsaW5lTnVtYmVyICsgJy4nO1xuICB9XG4gIHJldHVybiAnJztcbn1cblxuLyoqXG4gKiBXYXJuIGlmIHRoZXJlJ3Mgbm8ga2V5IGV4cGxpY2l0bHkgc2V0IG9uIGR5bmFtaWMgYXJyYXlzIG9mIGNoaWxkcmVuIG9yXG4gKiBvYmplY3Qga2V5cyBhcmUgbm90IHZhbGlkLiBUaGlzIGFsbG93cyB1cyB0byBrZWVwIHRyYWNrIG9mIGNoaWxkcmVuIGJldHdlZW5cbiAqIHVwZGF0ZXMuXG4gKi9cbnZhciBvd25lckhhc0tleVVzZVdhcm5pbmcgPSB7fTtcblxuZnVuY3Rpb24gZ2V0Q3VycmVudENvbXBvbmVudEVycm9ySW5mbyhwYXJlbnRUeXBlKSB7XG4gIHZhciBpbmZvID0gZ2V0RGVjbGFyYXRpb25FcnJvckFkZGVuZHVtKCk7XG5cbiAgaWYgKCFpbmZvKSB7XG4gICAgdmFyIHBhcmVudE5hbWUgPSB0eXBlb2YgcGFyZW50VHlwZSA9PT0gJ3N0cmluZycgPyBwYXJlbnRUeXBlIDogcGFyZW50VHlwZS5kaXNwbGF5TmFtZSB8fCBwYXJlbnRUeXBlLm5hbWU7XG4gICAgaWYgKHBhcmVudE5hbWUpIHtcbiAgICAgIGluZm8gPSAnXFxuXFxuQ2hlY2sgdGhlIHRvcC1sZXZlbCByZW5kZXIgY2FsbCB1c2luZyA8JyArIHBhcmVudE5hbWUgKyAnPi4nO1xuICAgIH1cbiAgfVxuICByZXR1cm4gaW5mbztcbn1cblxuLyoqXG4gKiBXYXJuIGlmIHRoZSBlbGVtZW50IGRvZXNuJ3QgaGF2ZSBhbiBleHBsaWNpdCBrZXkgYXNzaWduZWQgdG8gaXQuXG4gKiBUaGlzIGVsZW1lbnQgaXMgaW4gYW4gYXJyYXkuIFRoZSBhcnJheSBjb3VsZCBncm93IGFuZCBzaHJpbmsgb3IgYmVcbiAqIHJlb3JkZXJlZC4gQWxsIGNoaWxkcmVuIHRoYXQgaGF2ZW4ndCBhbHJlYWR5IGJlZW4gdmFsaWRhdGVkIGFyZSByZXF1aXJlZCB0b1xuICogaGF2ZSBhIFwia2V5XCIgcHJvcGVydHkgYXNzaWduZWQgdG8gaXQuIEVycm9yIHN0YXR1c2VzIGFyZSBjYWNoZWQgc28gYSB3YXJuaW5nXG4gKiB3aWxsIG9ubHkgYmUgc2hvd24gb25jZS5cbiAqXG4gKiBAaW50ZXJuYWxcbiAqIEBwYXJhbSB7UmVhY3RFbGVtZW50fSBlbGVtZW50IEVsZW1lbnQgdGhhdCByZXF1aXJlcyBhIGtleS5cbiAqIEBwYXJhbSB7Kn0gcGFyZW50VHlwZSBlbGVtZW50J3MgcGFyZW50J3MgdHlwZS5cbiAqL1xuZnVuY3Rpb24gdmFsaWRhdGVFeHBsaWNpdEtleShlbGVtZW50LCBwYXJlbnRUeXBlKSB7XG4gIGlmICghZWxlbWVudC5fc3RvcmUgfHwgZWxlbWVudC5fc3RvcmUudmFsaWRhdGVkIHx8IGVsZW1lbnQua2V5ICE9IG51bGwpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgZWxlbWVudC5fc3RvcmUudmFsaWRhdGVkID0gdHJ1ZTtcblxuICB2YXIgY3VycmVudENvbXBvbmVudEVycm9ySW5mbyA9IGdldEN1cnJlbnRDb21wb25lbnRFcnJvckluZm8ocGFyZW50VHlwZSk7XG4gIGlmIChvd25lckhhc0tleVVzZVdhcm5pbmdbY3VycmVudENvbXBvbmVudEVycm9ySW5mb10pIHtcbiAgICByZXR1cm47XG4gIH1cbiAgb3duZXJIYXNLZXlVc2VXYXJuaW5nW2N1cnJlbnRDb21wb25lbnRFcnJvckluZm9dID0gdHJ1ZTtcblxuICAvLyBVc3VhbGx5IHRoZSBjdXJyZW50IG93bmVyIGlzIHRoZSBvZmZlbmRlciwgYnV0IGlmIGl0IGFjY2VwdHMgY2hpbGRyZW4gYXMgYVxuICAvLyBwcm9wZXJ0eSwgaXQgbWF5IGJlIHRoZSBjcmVhdG9yIG9mIHRoZSBjaGlsZCB0aGF0J3MgcmVzcG9uc2libGUgZm9yXG4gIC8vIGFzc2lnbmluZyBpdCBhIGtleS5cbiAgdmFyIGNoaWxkT3duZXIgPSAnJztcbiAgaWYgKGVsZW1lbnQgJiYgZWxlbWVudC5fb3duZXIgJiYgZWxlbWVudC5fb3duZXIgIT09IFJlYWN0Q3VycmVudE93bmVyLmN1cnJlbnQpIHtcbiAgICAvLyBHaXZlIHRoZSBjb21wb25lbnQgdGhhdCBvcmlnaW5hbGx5IGNyZWF0ZWQgdGhpcyBjaGlsZC5cbiAgICBjaGlsZE93bmVyID0gJyBJdCB3YXMgcGFzc2VkIGEgY2hpbGQgZnJvbSAnICsgZ2V0Q29tcG9uZW50TmFtZShlbGVtZW50Ll9vd25lcikgKyAnLic7XG4gIH1cblxuICBjdXJyZW50bHlWYWxpZGF0aW5nRWxlbWVudCA9IGVsZW1lbnQ7XG4gIHtcbiAgICB3YXJuaW5nKGZhbHNlLCAnRWFjaCBjaGlsZCBpbiBhbiBhcnJheSBvciBpdGVyYXRvciBzaG91bGQgaGF2ZSBhIHVuaXF1ZSBcImtleVwiIHByb3AuJyArICclcyVzIFNlZSBodHRwczovL2ZiLm1lL3JlYWN0LXdhcm5pbmcta2V5cyBmb3IgbW9yZSBpbmZvcm1hdGlvbi4lcycsIGN1cnJlbnRDb21wb25lbnRFcnJvckluZm8sIGNoaWxkT3duZXIsIGdldFN0YWNrQWRkZW5kdW0oKSk7XG4gIH1cbiAgY3VycmVudGx5VmFsaWRhdGluZ0VsZW1lbnQgPSBudWxsO1xufVxuXG4vKipcbiAqIEVuc3VyZSB0aGF0IGV2ZXJ5IGVsZW1lbnQgZWl0aGVyIGlzIHBhc3NlZCBpbiBhIHN0YXRpYyBsb2NhdGlvbiwgaW4gYW5cbiAqIGFycmF5IHdpdGggYW4gZXhwbGljaXQga2V5cyBwcm9wZXJ0eSBkZWZpbmVkLCBvciBpbiBhbiBvYmplY3QgbGl0ZXJhbFxuICogd2l0aCB2YWxpZCBrZXkgcHJvcGVydHkuXG4gKlxuICogQGludGVybmFsXG4gKiBAcGFyYW0ge1JlYWN0Tm9kZX0gbm9kZSBTdGF0aWNhbGx5IHBhc3NlZCBjaGlsZCBvZiBhbnkgdHlwZS5cbiAqIEBwYXJhbSB7Kn0gcGFyZW50VHlwZSBub2RlJ3MgcGFyZW50J3MgdHlwZS5cbiAqL1xuZnVuY3Rpb24gdmFsaWRhdGVDaGlsZEtleXMobm9kZSwgcGFyZW50VHlwZSkge1xuICBpZiAodHlwZW9mIG5vZGUgIT09ICdvYmplY3QnKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIGlmIChBcnJheS5pc0FycmF5KG5vZGUpKSB7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBub2RlLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgY2hpbGQgPSBub2RlW2ldO1xuICAgICAgaWYgKGlzVmFsaWRFbGVtZW50KGNoaWxkKSkge1xuICAgICAgICB2YWxpZGF0ZUV4cGxpY2l0S2V5KGNoaWxkLCBwYXJlbnRUeXBlKTtcbiAgICAgIH1cbiAgICB9XG4gIH0gZWxzZSBpZiAoaXNWYWxpZEVsZW1lbnQobm9kZSkpIHtcbiAgICAvLyBUaGlzIGVsZW1lbnQgd2FzIHBhc3NlZCBpbiBhIHZhbGlkIGxvY2F0aW9uLlxuICAgIGlmIChub2RlLl9zdG9yZSkge1xuICAgICAgbm9kZS5fc3RvcmUudmFsaWRhdGVkID0gdHJ1ZTtcbiAgICB9XG4gIH0gZWxzZSBpZiAobm9kZSkge1xuICAgIHZhciBpdGVyYXRvckZuID0gZ2V0SXRlcmF0b3JGbihub2RlKTtcbiAgICBpZiAodHlwZW9mIGl0ZXJhdG9yRm4gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIC8vIEVudHJ5IGl0ZXJhdG9ycyB1c2VkIHRvIHByb3ZpZGUgaW1wbGljaXQga2V5cyxcbiAgICAgIC8vIGJ1dCBub3cgd2UgcHJpbnQgYSBzZXBhcmF0ZSB3YXJuaW5nIGZvciB0aGVtIGxhdGVyLlxuICAgICAgaWYgKGl0ZXJhdG9yRm4gIT09IG5vZGUuZW50cmllcykge1xuICAgICAgICB2YXIgaXRlcmF0b3IgPSBpdGVyYXRvckZuLmNhbGwobm9kZSk7XG4gICAgICAgIHZhciBzdGVwID0gdm9pZCAwO1xuICAgICAgICB3aGlsZSAoIShzdGVwID0gaXRlcmF0b3IubmV4dCgpKS5kb25lKSB7XG4gICAgICAgICAgaWYgKGlzVmFsaWRFbGVtZW50KHN0ZXAudmFsdWUpKSB7XG4gICAgICAgICAgICB2YWxpZGF0ZUV4cGxpY2l0S2V5KHN0ZXAudmFsdWUsIHBhcmVudFR5cGUpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxufVxuXG4vKipcbiAqIEdpdmVuIGFuIGVsZW1lbnQsIHZhbGlkYXRlIHRoYXQgaXRzIHByb3BzIGZvbGxvdyB0aGUgcHJvcFR5cGVzIGRlZmluaXRpb24sXG4gKiBwcm92aWRlZCBieSB0aGUgdHlwZS5cbiAqXG4gKiBAcGFyYW0ge1JlYWN0RWxlbWVudH0gZWxlbWVudFxuICovXG5mdW5jdGlvbiB2YWxpZGF0ZVByb3BUeXBlcyhlbGVtZW50KSB7XG4gIHZhciBjb21wb25lbnRDbGFzcyA9IGVsZW1lbnQudHlwZTtcbiAgaWYgKHR5cGVvZiBjb21wb25lbnRDbGFzcyAhPT0gJ2Z1bmN0aW9uJykge1xuICAgIHJldHVybjtcbiAgfVxuICB2YXIgbmFtZSA9IGNvbXBvbmVudENsYXNzLmRpc3BsYXlOYW1lIHx8IGNvbXBvbmVudENsYXNzLm5hbWU7XG4gIHZhciBwcm9wVHlwZXMgPSBjb21wb25lbnRDbGFzcy5wcm9wVHlwZXM7XG4gIGlmIChwcm9wVHlwZXMpIHtcbiAgICBjdXJyZW50bHlWYWxpZGF0aW5nRWxlbWVudCA9IGVsZW1lbnQ7XG4gICAgY2hlY2tQcm9wVHlwZXMocHJvcFR5cGVzLCBlbGVtZW50LnByb3BzLCAncHJvcCcsIG5hbWUsIGdldFN0YWNrQWRkZW5kdW0pO1xuICAgIGN1cnJlbnRseVZhbGlkYXRpbmdFbGVtZW50ID0gbnVsbDtcbiAgfSBlbHNlIGlmIChjb21wb25lbnRDbGFzcy5Qcm9wVHlwZXMgIT09IHVuZGVmaW5lZCAmJiAhcHJvcFR5cGVzTWlzc3BlbGxXYXJuaW5nU2hvd24pIHtcbiAgICBwcm9wVHlwZXNNaXNzcGVsbFdhcm5pbmdTaG93biA9IHRydWU7XG4gICAgd2FybmluZyhmYWxzZSwgJ0NvbXBvbmVudCAlcyBkZWNsYXJlZCBgUHJvcFR5cGVzYCBpbnN0ZWFkIG9mIGBwcm9wVHlwZXNgLiBEaWQgeW91IG1pc3NwZWxsIHRoZSBwcm9wZXJ0eSBhc3NpZ25tZW50PycsIG5hbWUgfHwgJ1Vua25vd24nKTtcbiAgfVxuICBpZiAodHlwZW9mIGNvbXBvbmVudENsYXNzLmdldERlZmF1bHRQcm9wcyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICFjb21wb25lbnRDbGFzcy5nZXREZWZhdWx0UHJvcHMuaXNSZWFjdENsYXNzQXBwcm92ZWQgPyB3YXJuaW5nKGZhbHNlLCAnZ2V0RGVmYXVsdFByb3BzIGlzIG9ubHkgdXNlZCBvbiBjbGFzc2ljIFJlYWN0LmNyZWF0ZUNsYXNzICcgKyAnZGVmaW5pdGlvbnMuIFVzZSBhIHN0YXRpYyBwcm9wZXJ0eSBuYW1lZCBgZGVmYXVsdFByb3BzYCBpbnN0ZWFkLicpIDogdm9pZCAwO1xuICB9XG59XG5cbi8qKlxuICogR2l2ZW4gYSBmcmFnbWVudCwgdmFsaWRhdGUgdGhhdCBpdCBjYW4gb25seSBiZSBwcm92aWRlZCB3aXRoIGZyYWdtZW50IHByb3BzXG4gKiBAcGFyYW0ge1JlYWN0RWxlbWVudH0gZnJhZ21lbnRcbiAqL1xuZnVuY3Rpb24gdmFsaWRhdGVGcmFnbWVudFByb3BzKGZyYWdtZW50KSB7XG4gIGN1cnJlbnRseVZhbGlkYXRpbmdFbGVtZW50ID0gZnJhZ21lbnQ7XG5cbiAgdmFyIGtleXMgPSBPYmplY3Qua2V5cyhmcmFnbWVudC5wcm9wcyk7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwga2V5cy5sZW5ndGg7IGkrKykge1xuICAgIHZhciBrZXkgPSBrZXlzW2ldO1xuICAgIGlmIChrZXkgIT09ICdjaGlsZHJlbicgJiYga2V5ICE9PSAna2V5Jykge1xuICAgICAgd2FybmluZyhmYWxzZSwgJ0ludmFsaWQgcHJvcCBgJXNgIHN1cHBsaWVkIHRvIGBSZWFjdC5GcmFnbWVudGAuICcgKyAnUmVhY3QuRnJhZ21lbnQgY2FuIG9ubHkgaGF2ZSBga2V5YCBhbmQgYGNoaWxkcmVuYCBwcm9wcy4lcycsIGtleSwgZ2V0U3RhY2tBZGRlbmR1bSgpKTtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgfVxuXG4gIGlmIChmcmFnbWVudC5yZWYgIT09IG51bGwpIHtcbiAgICB3YXJuaW5nKGZhbHNlLCAnSW52YWxpZCBhdHRyaWJ1dGUgYHJlZmAgc3VwcGxpZWQgdG8gYFJlYWN0LkZyYWdtZW50YC4lcycsIGdldFN0YWNrQWRkZW5kdW0oKSk7XG4gIH1cblxuICBjdXJyZW50bHlWYWxpZGF0aW5nRWxlbWVudCA9IG51bGw7XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZUVsZW1lbnRXaXRoVmFsaWRhdGlvbih0eXBlLCBwcm9wcywgY2hpbGRyZW4pIHtcbiAgdmFyIHZhbGlkVHlwZSA9IGlzVmFsaWRFbGVtZW50VHlwZSh0eXBlKTtcblxuICAvLyBXZSB3YXJuIGluIHRoaXMgY2FzZSBidXQgZG9uJ3QgdGhyb3cuIFdlIGV4cGVjdCB0aGUgZWxlbWVudCBjcmVhdGlvbiB0b1xuICAvLyBzdWNjZWVkIGFuZCB0aGVyZSB3aWxsIGxpa2VseSBiZSBlcnJvcnMgaW4gcmVuZGVyLlxuICBpZiAoIXZhbGlkVHlwZSkge1xuICAgIHZhciBpbmZvID0gJyc7XG4gICAgaWYgKHR5cGUgPT09IHVuZGVmaW5lZCB8fCB0eXBlb2YgdHlwZSA9PT0gJ29iamVjdCcgJiYgdHlwZSAhPT0gbnVsbCAmJiBPYmplY3Qua2V5cyh0eXBlKS5sZW5ndGggPT09IDApIHtcbiAgICAgIGluZm8gKz0gJyBZb3UgbGlrZWx5IGZvcmdvdCB0byBleHBvcnQgeW91ciBjb21wb25lbnQgZnJvbSB0aGUgZmlsZSAnICsgXCJpdCdzIGRlZmluZWQgaW4sIG9yIHlvdSBtaWdodCBoYXZlIG1peGVkIHVwIGRlZmF1bHQgYW5kIG5hbWVkIGltcG9ydHMuXCI7XG4gICAgfVxuXG4gICAgdmFyIHNvdXJjZUluZm8gPSBnZXRTb3VyY2VJbmZvRXJyb3JBZGRlbmR1bShwcm9wcyk7XG4gICAgaWYgKHNvdXJjZUluZm8pIHtcbiAgICAgIGluZm8gKz0gc291cmNlSW5mbztcbiAgICB9IGVsc2Uge1xuICAgICAgaW5mbyArPSBnZXREZWNsYXJhdGlvbkVycm9yQWRkZW5kdW0oKTtcbiAgICB9XG5cbiAgICBpbmZvICs9IGdldFN0YWNrQWRkZW5kdW0oKSB8fCAnJztcblxuICAgIHZhciB0eXBlU3RyaW5nID0gdm9pZCAwO1xuICAgIGlmICh0eXBlID09PSBudWxsKSB7XG4gICAgICB0eXBlU3RyaW5nID0gJ251bGwnO1xuICAgIH0gZWxzZSBpZiAoQXJyYXkuaXNBcnJheSh0eXBlKSkge1xuICAgICAgdHlwZVN0cmluZyA9ICdhcnJheSc7XG4gICAgfSBlbHNlIHtcbiAgICAgIHR5cGVTdHJpbmcgPSB0eXBlb2YgdHlwZTtcbiAgICB9XG5cbiAgICB3YXJuaW5nKGZhbHNlLCAnUmVhY3QuY3JlYXRlRWxlbWVudDogdHlwZSBpcyBpbnZhbGlkIC0tIGV4cGVjdGVkIGEgc3RyaW5nIChmb3IgJyArICdidWlsdC1pbiBjb21wb25lbnRzKSBvciBhIGNsYXNzL2Z1bmN0aW9uIChmb3IgY29tcG9zaXRlICcgKyAnY29tcG9uZW50cykgYnV0IGdvdDogJXMuJXMnLCB0eXBlU3RyaW5nLCBpbmZvKTtcbiAgfVxuXG4gIHZhciBlbGVtZW50ID0gY3JlYXRlRWxlbWVudC5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuXG4gIC8vIFRoZSByZXN1bHQgY2FuIGJlIG51bGxpc2ggaWYgYSBtb2NrIG9yIGEgY3VzdG9tIGZ1bmN0aW9uIGlzIHVzZWQuXG4gIC8vIFRPRE86IERyb3AgdGhpcyB3aGVuIHRoZXNlIGFyZSBubyBsb25nZXIgYWxsb3dlZCBhcyB0aGUgdHlwZSBhcmd1bWVudC5cbiAgaWYgKGVsZW1lbnQgPT0gbnVsbCkge1xuICAgIHJldHVybiBlbGVtZW50O1xuICB9XG5cbiAgLy8gU2tpcCBrZXkgd2FybmluZyBpZiB0aGUgdHlwZSBpc24ndCB2YWxpZCBzaW5jZSBvdXIga2V5IHZhbGlkYXRpb24gbG9naWNcbiAgLy8gZG9lc24ndCBleHBlY3QgYSBub24tc3RyaW5nL2Z1bmN0aW9uIHR5cGUgYW5kIGNhbiB0aHJvdyBjb25mdXNpbmcgZXJyb3JzLlxuICAvLyBXZSBkb24ndCB3YW50IGV4Y2VwdGlvbiBiZWhhdmlvciB0byBkaWZmZXIgYmV0d2VlbiBkZXYgYW5kIHByb2QuXG4gIC8vIChSZW5kZXJpbmcgd2lsbCB0aHJvdyB3aXRoIGEgaGVscGZ1bCBtZXNzYWdlIGFuZCBhcyBzb29uIGFzIHRoZSB0eXBlIGlzXG4gIC8vIGZpeGVkLCB0aGUga2V5IHdhcm5pbmdzIHdpbGwgYXBwZWFyLilcbiAgaWYgKHZhbGlkVHlwZSkge1xuICAgIGZvciAodmFyIGkgPSAyOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YWxpZGF0ZUNoaWxkS2V5cyhhcmd1bWVudHNbaV0sIHR5cGUpO1xuICAgIH1cbiAgfVxuXG4gIGlmICh0eXBlID09PSBSRUFDVF9GUkFHTUVOVF9UWVBFKSB7XG4gICAgdmFsaWRhdGVGcmFnbWVudFByb3BzKGVsZW1lbnQpO1xuICB9IGVsc2Uge1xuICAgIHZhbGlkYXRlUHJvcFR5cGVzKGVsZW1lbnQpO1xuICB9XG5cbiAgcmV0dXJuIGVsZW1lbnQ7XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZUZhY3RvcnlXaXRoVmFsaWRhdGlvbih0eXBlKSB7XG4gIHZhciB2YWxpZGF0ZWRGYWN0b3J5ID0gY3JlYXRlRWxlbWVudFdpdGhWYWxpZGF0aW9uLmJpbmQobnVsbCwgdHlwZSk7XG4gIHZhbGlkYXRlZEZhY3RvcnkudHlwZSA9IHR5cGU7XG4gIC8vIExlZ2FjeSBob29rOiByZW1vdmUgaXRcbiAge1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh2YWxpZGF0ZWRGYWN0b3J5LCAndHlwZScsIHtcbiAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGxvd1ByaW9yaXR5V2FybmluZyQxKGZhbHNlLCAnRmFjdG9yeS50eXBlIGlzIGRlcHJlY2F0ZWQuIEFjY2VzcyB0aGUgY2xhc3MgZGlyZWN0bHkgJyArICdiZWZvcmUgcGFzc2luZyBpdCB0byBjcmVhdGVGYWN0b3J5LicpO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgJ3R5cGUnLCB7XG4gICAgICAgICAgdmFsdWU6IHR5cGVcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiB0eXBlO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG5cbiAgcmV0dXJuIHZhbGlkYXRlZEZhY3Rvcnk7XG59XG5cbmZ1bmN0aW9uIGNsb25lRWxlbWVudFdpdGhWYWxpZGF0aW9uKGVsZW1lbnQsIHByb3BzLCBjaGlsZHJlbikge1xuICB2YXIgbmV3RWxlbWVudCA9IGNsb25lRWxlbWVudC5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICBmb3IgKHZhciBpID0gMjsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykge1xuICAgIHZhbGlkYXRlQ2hpbGRLZXlzKGFyZ3VtZW50c1tpXSwgbmV3RWxlbWVudC50eXBlKTtcbiAgfVxuICB2YWxpZGF0ZVByb3BUeXBlcyhuZXdFbGVtZW50KTtcbiAgcmV0dXJuIG5ld0VsZW1lbnQ7XG59XG5cbnZhciBSZWFjdCA9IHtcbiAgQ2hpbGRyZW46IHtcbiAgICBtYXA6IG1hcENoaWxkcmVuLFxuICAgIGZvckVhY2g6IGZvckVhY2hDaGlsZHJlbixcbiAgICBjb3VudDogY291bnRDaGlsZHJlbixcbiAgICB0b0FycmF5OiB0b0FycmF5LFxuICAgIG9ubHk6IG9ubHlDaGlsZFxuICB9LFxuXG4gIGNyZWF0ZVJlZjogY3JlYXRlUmVmLFxuICBDb21wb25lbnQ6IENvbXBvbmVudCxcbiAgUHVyZUNvbXBvbmVudDogUHVyZUNvbXBvbmVudCxcblxuICBjcmVhdGVDb250ZXh0OiBjcmVhdGVDb250ZXh0LFxuICBmb3J3YXJkUmVmOiBmb3J3YXJkUmVmLFxuXG4gIEZyYWdtZW50OiBSRUFDVF9GUkFHTUVOVF9UWVBFLFxuICBTdHJpY3RNb2RlOiBSRUFDVF9TVFJJQ1RfTU9ERV9UWVBFLFxuICB1bnN0YWJsZV9Bc3luY01vZGU6IFJFQUNUX0FTWU5DX01PREVfVFlQRSxcblxuICBjcmVhdGVFbGVtZW50OiBjcmVhdGVFbGVtZW50V2l0aFZhbGlkYXRpb24sXG4gIGNsb25lRWxlbWVudDogY2xvbmVFbGVtZW50V2l0aFZhbGlkYXRpb24sXG4gIGNyZWF0ZUZhY3Rvcnk6IGNyZWF0ZUZhY3RvcnlXaXRoVmFsaWRhdGlvbixcbiAgaXNWYWxpZEVsZW1lbnQ6IGlzVmFsaWRFbGVtZW50LFxuXG4gIHZlcnNpb246IFJlYWN0VmVyc2lvbixcblxuICBfX1NFQ1JFVF9JTlRFUk5BTFNfRE9fTk9UX1VTRV9PUl9ZT1VfV0lMTF9CRV9GSVJFRDoge1xuICAgIFJlYWN0Q3VycmVudE93bmVyOiBSZWFjdEN1cnJlbnRPd25lcixcbiAgICAvLyBVc2VkIGJ5IHJlbmRlcmVycyB0byBhdm9pZCBidW5kbGluZyBvYmplY3QtYXNzaWduIHR3aWNlIGluIFVNRCBidW5kbGVzOlxuICAgIGFzc2lnbjogX2Fzc2lnblxuICB9XG59O1xuXG57XG4gIF9hc3NpZ24oUmVhY3QuX19TRUNSRVRfSU5URVJOQUxTX0RPX05PVF9VU0VfT1JfWU9VX1dJTExfQkVfRklSRUQsIHtcbiAgICAvLyBUaGVzZSBzaG91bGQgbm90IGJlIGluY2x1ZGVkIGluIHByb2R1Y3Rpb24uXG4gICAgUmVhY3REZWJ1Z0N1cnJlbnRGcmFtZTogUmVhY3REZWJ1Z0N1cnJlbnRGcmFtZSxcbiAgICAvLyBTaGltIGZvciBSZWFjdCBET00gMTYuMC4wIHdoaWNoIHN0aWxsIGRlc3RydWN0dXJlZCAoYnV0IG5vdCB1c2VkKSB0aGlzLlxuICAgIC8vIFRPRE86IHJlbW92ZSBpbiBSZWFjdCAxNy4wLlxuICAgIFJlYWN0Q29tcG9uZW50VHJlZUhvb2s6IHt9XG4gIH0pO1xufVxuXG5cblxudmFyIFJlYWN0JDIgPSBPYmplY3QuZnJlZXplKHtcblx0ZGVmYXVsdDogUmVhY3Rcbn0pO1xuXG52YXIgUmVhY3QkMyA9ICggUmVhY3QkMiAmJiBSZWFjdCApIHx8IFJlYWN0JDI7XG5cbi8vIFRPRE86IGRlY2lkZSBvbiB0aGUgdG9wLWxldmVsIGV4cG9ydCBmb3JtLlxuLy8gVGhpcyBpcyBoYWNreSBidXQgbWFrZXMgaXQgd29yayB3aXRoIGJvdGggUm9sbHVwIGFuZCBKZXN0LlxudmFyIHJlYWN0ID0gUmVhY3QkM1snZGVmYXVsdCddID8gUmVhY3QkM1snZGVmYXVsdCddIDogUmVhY3QkMztcblxubW9kdWxlLmV4cG9ydHMgPSByZWFjdDtcbiAgfSkoKTtcbn1cblxuXG4vKioqLyB9KSxcbi8qIDExICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbi8qKlxuICogQ29weXJpZ2h0IChjKSAyMDEzLXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKi9cblxuaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgdmFyIFJFQUNUX0VMRU1FTlRfVFlQRSA9ICh0eXBlb2YgU3ltYm9sID09PSAnZnVuY3Rpb24nICYmXG4gICAgU3ltYm9sLmZvciAmJlxuICAgIFN5bWJvbC5mb3IoJ3JlYWN0LmVsZW1lbnQnKSkgfHxcbiAgICAweGVhYzc7XG5cbiAgdmFyIGlzVmFsaWRFbGVtZW50ID0gZnVuY3Rpb24ob2JqZWN0KSB7XG4gICAgcmV0dXJuIHR5cGVvZiBvYmplY3QgPT09ICdvYmplY3QnICYmXG4gICAgICBvYmplY3QgIT09IG51bGwgJiZcbiAgICAgIG9iamVjdC4kJHR5cGVvZiA9PT0gUkVBQ1RfRUxFTUVOVF9UWVBFO1xuICB9O1xuXG4gIC8vIEJ5IGV4cGxpY2l0bHkgdXNpbmcgYHByb3AtdHlwZXNgIHlvdSBhcmUgb3B0aW5nIGludG8gbmV3IGRldmVsb3BtZW50IGJlaGF2aW9yLlxuICAvLyBodHRwOi8vZmIubWUvcHJvcC10eXBlcy1pbi1wcm9kXG4gIHZhciB0aHJvd09uRGlyZWN0QWNjZXNzID0gdHJ1ZTtcbiAgbW9kdWxlLmV4cG9ydHMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDEyKShpc1ZhbGlkRWxlbWVudCwgdGhyb3dPbkRpcmVjdEFjY2Vzcyk7XG59IGVsc2Uge1xuICAvLyBCeSBleHBsaWNpdGx5IHVzaW5nIGBwcm9wLXR5cGVzYCB5b3UgYXJlIG9wdGluZyBpbnRvIG5ldyBwcm9kdWN0aW9uIGJlaGF2aW9yLlxuICAvLyBodHRwOi8vZmIubWUvcHJvcC10eXBlcy1pbi1wcm9kXG4gIG1vZHVsZS5leHBvcnRzID0gX193ZWJwYWNrX3JlcXVpcmVfXygxMykoKTtcbn1cblxuXG4vKioqLyB9KSxcbi8qIDEyICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuLyoqXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTMtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqL1xuXG5cblxudmFyIGVtcHR5RnVuY3Rpb24gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDEpO1xudmFyIGludmFyaWFudCA9IF9fd2VicGFja19yZXF1aXJlX18oMCk7XG52YXIgd2FybmluZyA9IF9fd2VicGFja19yZXF1aXJlX18oMyk7XG52YXIgYXNzaWduID0gX193ZWJwYWNrX3JlcXVpcmVfXygyKTtcblxudmFyIFJlYWN0UHJvcFR5cGVzU2VjcmV0ID0gX193ZWJwYWNrX3JlcXVpcmVfXyg0KTtcbnZhciBjaGVja1Byb3BUeXBlcyA9IF9fd2VicGFja19yZXF1aXJlX18oNik7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oaXNWYWxpZEVsZW1lbnQsIHRocm93T25EaXJlY3RBY2Nlc3MpIHtcbiAgLyogZ2xvYmFsIFN5bWJvbCAqL1xuICB2YXIgSVRFUkFUT1JfU1lNQk9MID0gdHlwZW9mIFN5bWJvbCA9PT0gJ2Z1bmN0aW9uJyAmJiBTeW1ib2wuaXRlcmF0b3I7XG4gIHZhciBGQVVYX0lURVJBVE9SX1NZTUJPTCA9ICdAQGl0ZXJhdG9yJzsgLy8gQmVmb3JlIFN5bWJvbCBzcGVjLlxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBpdGVyYXRvciBtZXRob2QgZnVuY3Rpb24gY29udGFpbmVkIG9uIHRoZSBpdGVyYWJsZSBvYmplY3QuXG4gICAqXG4gICAqIEJlIHN1cmUgdG8gaW52b2tlIHRoZSBmdW5jdGlvbiB3aXRoIHRoZSBpdGVyYWJsZSBhcyBjb250ZXh0OlxuICAgKlxuICAgKiAgICAgdmFyIGl0ZXJhdG9yRm4gPSBnZXRJdGVyYXRvckZuKG15SXRlcmFibGUpO1xuICAgKiAgICAgaWYgKGl0ZXJhdG9yRm4pIHtcbiAgICogICAgICAgdmFyIGl0ZXJhdG9yID0gaXRlcmF0b3JGbi5jYWxsKG15SXRlcmFibGUpO1xuICAgKiAgICAgICAuLi5cbiAgICogICAgIH1cbiAgICpcbiAgICogQHBhcmFtIHs/b2JqZWN0fSBtYXliZUl0ZXJhYmxlXG4gICAqIEByZXR1cm4gez9mdW5jdGlvbn1cbiAgICovXG4gIGZ1bmN0aW9uIGdldEl0ZXJhdG9yRm4obWF5YmVJdGVyYWJsZSkge1xuICAgIHZhciBpdGVyYXRvckZuID0gbWF5YmVJdGVyYWJsZSAmJiAoSVRFUkFUT1JfU1lNQk9MICYmIG1heWJlSXRlcmFibGVbSVRFUkFUT1JfU1lNQk9MXSB8fCBtYXliZUl0ZXJhYmxlW0ZBVVhfSVRFUkFUT1JfU1lNQk9MXSk7XG4gICAgaWYgKHR5cGVvZiBpdGVyYXRvckZuID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICByZXR1cm4gaXRlcmF0b3JGbjtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQ29sbGVjdGlvbiBvZiBtZXRob2RzIHRoYXQgYWxsb3cgZGVjbGFyYXRpb24gYW5kIHZhbGlkYXRpb24gb2YgcHJvcHMgdGhhdCBhcmVcbiAgICogc3VwcGxpZWQgdG8gUmVhY3QgY29tcG9uZW50cy4gRXhhbXBsZSB1c2FnZTpcbiAgICpcbiAgICogICB2YXIgUHJvcHMgPSByZXF1aXJlKCdSZWFjdFByb3BUeXBlcycpO1xuICAgKiAgIHZhciBNeUFydGljbGUgPSBSZWFjdC5jcmVhdGVDbGFzcyh7XG4gICAqICAgICBwcm9wVHlwZXM6IHtcbiAgICogICAgICAgLy8gQW4gb3B0aW9uYWwgc3RyaW5nIHByb3AgbmFtZWQgXCJkZXNjcmlwdGlvblwiLlxuICAgKiAgICAgICBkZXNjcmlwdGlvbjogUHJvcHMuc3RyaW5nLFxuICAgKlxuICAgKiAgICAgICAvLyBBIHJlcXVpcmVkIGVudW0gcHJvcCBuYW1lZCBcImNhdGVnb3J5XCIuXG4gICAqICAgICAgIGNhdGVnb3J5OiBQcm9wcy5vbmVPZihbJ05ld3MnLCdQaG90b3MnXSkuaXNSZXF1aXJlZCxcbiAgICpcbiAgICogICAgICAgLy8gQSBwcm9wIG5hbWVkIFwiZGlhbG9nXCIgdGhhdCByZXF1aXJlcyBhbiBpbnN0YW5jZSBvZiBEaWFsb2cuXG4gICAqICAgICAgIGRpYWxvZzogUHJvcHMuaW5zdGFuY2VPZihEaWFsb2cpLmlzUmVxdWlyZWRcbiAgICogICAgIH0sXG4gICAqICAgICByZW5kZXI6IGZ1bmN0aW9uKCkgeyAuLi4gfVxuICAgKiAgIH0pO1xuICAgKlxuICAgKiBBIG1vcmUgZm9ybWFsIHNwZWNpZmljYXRpb24gb2YgaG93IHRoZXNlIG1ldGhvZHMgYXJlIHVzZWQ6XG4gICAqXG4gICAqICAgdHlwZSA6PSBhcnJheXxib29sfGZ1bmN8b2JqZWN0fG51bWJlcnxzdHJpbmd8b25lT2YoWy4uLl0pfGluc3RhbmNlT2YoLi4uKVxuICAgKiAgIGRlY2wgOj0gUmVhY3RQcm9wVHlwZXMue3R5cGV9KC5pc1JlcXVpcmVkKT9cbiAgICpcbiAgICogRWFjaCBhbmQgZXZlcnkgZGVjbGFyYXRpb24gcHJvZHVjZXMgYSBmdW5jdGlvbiB3aXRoIHRoZSBzYW1lIHNpZ25hdHVyZS4gVGhpc1xuICAgKiBhbGxvd3MgdGhlIGNyZWF0aW9uIG9mIGN1c3RvbSB2YWxpZGF0aW9uIGZ1bmN0aW9ucy4gRm9yIGV4YW1wbGU6XG4gICAqXG4gICAqICB2YXIgTXlMaW5rID0gUmVhY3QuY3JlYXRlQ2xhc3Moe1xuICAgKiAgICBwcm9wVHlwZXM6IHtcbiAgICogICAgICAvLyBBbiBvcHRpb25hbCBzdHJpbmcgb3IgVVJJIHByb3AgbmFtZWQgXCJocmVmXCIuXG4gICAqICAgICAgaHJlZjogZnVuY3Rpb24ocHJvcHMsIHByb3BOYW1lLCBjb21wb25lbnROYW1lKSB7XG4gICAqICAgICAgICB2YXIgcHJvcFZhbHVlID0gcHJvcHNbcHJvcE5hbWVdO1xuICAgKiAgICAgICAgaWYgKHByb3BWYWx1ZSAhPSBudWxsICYmIHR5cGVvZiBwcm9wVmFsdWUgIT09ICdzdHJpbmcnICYmXG4gICAqICAgICAgICAgICAgIShwcm9wVmFsdWUgaW5zdGFuY2VvZiBVUkkpKSB7XG4gICAqICAgICAgICAgIHJldHVybiBuZXcgRXJyb3IoXG4gICAqICAgICAgICAgICAgJ0V4cGVjdGVkIGEgc3RyaW5nIG9yIGFuIFVSSSBmb3IgJyArIHByb3BOYW1lICsgJyBpbiAnICtcbiAgICogICAgICAgICAgICBjb21wb25lbnROYW1lXG4gICAqICAgICAgICAgICk7XG4gICAqICAgICAgICB9XG4gICAqICAgICAgfVxuICAgKiAgICB9LFxuICAgKiAgICByZW5kZXI6IGZ1bmN0aW9uKCkgey4uLn1cbiAgICogIH0pO1xuICAgKlxuICAgKiBAaW50ZXJuYWxcbiAgICovXG5cbiAgdmFyIEFOT05ZTU9VUyA9ICc8PGFub255bW91cz4+JztcblxuICAvLyBJbXBvcnRhbnQhXG4gIC8vIEtlZXAgdGhpcyBsaXN0IGluIHN5bmMgd2l0aCBwcm9kdWN0aW9uIHZlcnNpb24gaW4gYC4vZmFjdG9yeVdpdGhUaHJvd2luZ1NoaW1zLmpzYC5cbiAgdmFyIFJlYWN0UHJvcFR5cGVzID0ge1xuICAgIGFycmF5OiBjcmVhdGVQcmltaXRpdmVUeXBlQ2hlY2tlcignYXJyYXknKSxcbiAgICBib29sOiBjcmVhdGVQcmltaXRpdmVUeXBlQ2hlY2tlcignYm9vbGVhbicpLFxuICAgIGZ1bmM6IGNyZWF0ZVByaW1pdGl2ZVR5cGVDaGVja2VyKCdmdW5jdGlvbicpLFxuICAgIG51bWJlcjogY3JlYXRlUHJpbWl0aXZlVHlwZUNoZWNrZXIoJ251bWJlcicpLFxuICAgIG9iamVjdDogY3JlYXRlUHJpbWl0aXZlVHlwZUNoZWNrZXIoJ29iamVjdCcpLFxuICAgIHN0cmluZzogY3JlYXRlUHJpbWl0aXZlVHlwZUNoZWNrZXIoJ3N0cmluZycpLFxuICAgIHN5bWJvbDogY3JlYXRlUHJpbWl0aXZlVHlwZUNoZWNrZXIoJ3N5bWJvbCcpLFxuXG4gICAgYW55OiBjcmVhdGVBbnlUeXBlQ2hlY2tlcigpLFxuICAgIGFycmF5T2Y6IGNyZWF0ZUFycmF5T2ZUeXBlQ2hlY2tlcixcbiAgICBlbGVtZW50OiBjcmVhdGVFbGVtZW50VHlwZUNoZWNrZXIoKSxcbiAgICBpbnN0YW5jZU9mOiBjcmVhdGVJbnN0YW5jZVR5cGVDaGVja2VyLFxuICAgIG5vZGU6IGNyZWF0ZU5vZGVDaGVja2VyKCksXG4gICAgb2JqZWN0T2Y6IGNyZWF0ZU9iamVjdE9mVHlwZUNoZWNrZXIsXG4gICAgb25lT2Y6IGNyZWF0ZUVudW1UeXBlQ2hlY2tlcixcbiAgICBvbmVPZlR5cGU6IGNyZWF0ZVVuaW9uVHlwZUNoZWNrZXIsXG4gICAgc2hhcGU6IGNyZWF0ZVNoYXBlVHlwZUNoZWNrZXIsXG4gICAgZXhhY3Q6IGNyZWF0ZVN0cmljdFNoYXBlVHlwZUNoZWNrZXIsXG4gIH07XG5cbiAgLyoqXG4gICAqIGlubGluZWQgT2JqZWN0LmlzIHBvbHlmaWxsIHRvIGF2b2lkIHJlcXVpcmluZyBjb25zdW1lcnMgc2hpcCB0aGVpciBvd25cbiAgICogaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvSmF2YVNjcmlwdC9SZWZlcmVuY2UvR2xvYmFsX09iamVjdHMvT2JqZWN0L2lzXG4gICAqL1xuICAvKmVzbGludC1kaXNhYmxlIG5vLXNlbGYtY29tcGFyZSovXG4gIGZ1bmN0aW9uIGlzKHgsIHkpIHtcbiAgICAvLyBTYW1lVmFsdWUgYWxnb3JpdGhtXG4gICAgaWYgKHggPT09IHkpIHtcbiAgICAgIC8vIFN0ZXBzIDEtNSwgNy0xMFxuICAgICAgLy8gU3RlcHMgNi5iLTYuZTogKzAgIT0gLTBcbiAgICAgIHJldHVybiB4ICE9PSAwIHx8IDEgLyB4ID09PSAxIC8geTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gU3RlcCA2LmE6IE5hTiA9PSBOYU5cbiAgICAgIHJldHVybiB4ICE9PSB4ICYmIHkgIT09IHk7XG4gICAgfVxuICB9XG4gIC8qZXNsaW50LWVuYWJsZSBuby1zZWxmLWNvbXBhcmUqL1xuXG4gIC8qKlxuICAgKiBXZSB1c2UgYW4gRXJyb3ItbGlrZSBvYmplY3QgZm9yIGJhY2t3YXJkIGNvbXBhdGliaWxpdHkgYXMgcGVvcGxlIG1heSBjYWxsXG4gICAqIFByb3BUeXBlcyBkaXJlY3RseSBhbmQgaW5zcGVjdCB0aGVpciBvdXRwdXQuIEhvd2V2ZXIsIHdlIGRvbid0IHVzZSByZWFsXG4gICAqIEVycm9ycyBhbnltb3JlLiBXZSBkb24ndCBpbnNwZWN0IHRoZWlyIHN0YWNrIGFueXdheSwgYW5kIGNyZWF0aW5nIHRoZW1cbiAgICogaXMgcHJvaGliaXRpdmVseSBleHBlbnNpdmUgaWYgdGhleSBhcmUgY3JlYXRlZCB0b28gb2Z0ZW4sIHN1Y2ggYXMgd2hhdFxuICAgKiBoYXBwZW5zIGluIG9uZU9mVHlwZSgpIGZvciBhbnkgdHlwZSBiZWZvcmUgdGhlIG9uZSB0aGF0IG1hdGNoZWQuXG4gICAqL1xuICBmdW5jdGlvbiBQcm9wVHlwZUVycm9yKG1lc3NhZ2UpIHtcbiAgICB0aGlzLm1lc3NhZ2UgPSBtZXNzYWdlO1xuICAgIHRoaXMuc3RhY2sgPSAnJztcbiAgfVxuICAvLyBNYWtlIGBpbnN0YW5jZW9mIEVycm9yYCBzdGlsbCB3b3JrIGZvciByZXR1cm5lZCBlcnJvcnMuXG4gIFByb3BUeXBlRXJyb3IucHJvdG90eXBlID0gRXJyb3IucHJvdG90eXBlO1xuXG4gIGZ1bmN0aW9uIGNyZWF0ZUNoYWluYWJsZVR5cGVDaGVja2VyKHZhbGlkYXRlKSB7XG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgIHZhciBtYW51YWxQcm9wVHlwZUNhbGxDYWNoZSA9IHt9O1xuICAgICAgdmFyIG1hbnVhbFByb3BUeXBlV2FybmluZ0NvdW50ID0gMDtcbiAgICB9XG4gICAgZnVuY3Rpb24gY2hlY2tUeXBlKGlzUmVxdWlyZWQsIHByb3BzLCBwcm9wTmFtZSwgY29tcG9uZW50TmFtZSwgbG9jYXRpb24sIHByb3BGdWxsTmFtZSwgc2VjcmV0KSB7XG4gICAgICBjb21wb25lbnROYW1lID0gY29tcG9uZW50TmFtZSB8fCBBTk9OWU1PVVM7XG4gICAgICBwcm9wRnVsbE5hbWUgPSBwcm9wRnVsbE5hbWUgfHwgcHJvcE5hbWU7XG5cbiAgICAgIGlmIChzZWNyZXQgIT09IFJlYWN0UHJvcFR5cGVzU2VjcmV0KSB7XG4gICAgICAgIGlmICh0aHJvd09uRGlyZWN0QWNjZXNzKSB7XG4gICAgICAgICAgLy8gTmV3IGJlaGF2aW9yIG9ubHkgZm9yIHVzZXJzIG9mIGBwcm9wLXR5cGVzYCBwYWNrYWdlXG4gICAgICAgICAgaW52YXJpYW50KFxuICAgICAgICAgICAgZmFsc2UsXG4gICAgICAgICAgICAnQ2FsbGluZyBQcm9wVHlwZXMgdmFsaWRhdG9ycyBkaXJlY3RseSBpcyBub3Qgc3VwcG9ydGVkIGJ5IHRoZSBgcHJvcC10eXBlc2AgcGFja2FnZS4gJyArXG4gICAgICAgICAgICAnVXNlIGBQcm9wVHlwZXMuY2hlY2tQcm9wVHlwZXMoKWAgdG8gY2FsbCB0aGVtLiAnICtcbiAgICAgICAgICAgICdSZWFkIG1vcmUgYXQgaHR0cDovL2ZiLm1lL3VzZS1jaGVjay1wcm9wLXR5cGVzJ1xuICAgICAgICAgICk7XG4gICAgICAgIH0gZWxzZSBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJiB0eXBlb2YgY29uc29sZSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAvLyBPbGQgYmVoYXZpb3IgZm9yIHBlb3BsZSB1c2luZyBSZWFjdC5Qcm9wVHlwZXNcbiAgICAgICAgICB2YXIgY2FjaGVLZXkgPSBjb21wb25lbnROYW1lICsgJzonICsgcHJvcE5hbWU7XG4gICAgICAgICAgaWYgKFxuICAgICAgICAgICAgIW1hbnVhbFByb3BUeXBlQ2FsbENhY2hlW2NhY2hlS2V5XSAmJlxuICAgICAgICAgICAgLy8gQXZvaWQgc3BhbW1pbmcgdGhlIGNvbnNvbGUgYmVjYXVzZSB0aGV5IGFyZSBvZnRlbiBub3QgYWN0aW9uYWJsZSBleGNlcHQgZm9yIGxpYiBhdXRob3JzXG4gICAgICAgICAgICBtYW51YWxQcm9wVHlwZVdhcm5pbmdDb3VudCA8IDNcbiAgICAgICAgICApIHtcbiAgICAgICAgICAgIHdhcm5pbmcoXG4gICAgICAgICAgICAgIGZhbHNlLFxuICAgICAgICAgICAgICAnWW91IGFyZSBtYW51YWxseSBjYWxsaW5nIGEgUmVhY3QuUHJvcFR5cGVzIHZhbGlkYXRpb24gJyArXG4gICAgICAgICAgICAgICdmdW5jdGlvbiBmb3IgdGhlIGAlc2AgcHJvcCBvbiBgJXNgLiBUaGlzIGlzIGRlcHJlY2F0ZWQgJyArXG4gICAgICAgICAgICAgICdhbmQgd2lsbCB0aHJvdyBpbiB0aGUgc3RhbmRhbG9uZSBgcHJvcC10eXBlc2AgcGFja2FnZS4gJyArXG4gICAgICAgICAgICAgICdZb3UgbWF5IGJlIHNlZWluZyB0aGlzIHdhcm5pbmcgZHVlIHRvIGEgdGhpcmQtcGFydHkgUHJvcFR5cGVzICcgK1xuICAgICAgICAgICAgICAnbGlicmFyeS4gU2VlIGh0dHBzOi8vZmIubWUvcmVhY3Qtd2FybmluZy1kb250LWNhbGwtcHJvcHR5cGVzICcgKyAnZm9yIGRldGFpbHMuJyxcbiAgICAgICAgICAgICAgcHJvcEZ1bGxOYW1lLFxuICAgICAgICAgICAgICBjb21wb25lbnROYW1lXG4gICAgICAgICAgICApO1xuICAgICAgICAgICAgbWFudWFsUHJvcFR5cGVDYWxsQ2FjaGVbY2FjaGVLZXldID0gdHJ1ZTtcbiAgICAgICAgICAgIG1hbnVhbFByb3BUeXBlV2FybmluZ0NvdW50Kys7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAocHJvcHNbcHJvcE5hbWVdID09IG51bGwpIHtcbiAgICAgICAgaWYgKGlzUmVxdWlyZWQpIHtcbiAgICAgICAgICBpZiAocHJvcHNbcHJvcE5hbWVdID09PSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IFByb3BUeXBlRXJyb3IoJ1RoZSAnICsgbG9jYXRpb24gKyAnIGAnICsgcHJvcEZ1bGxOYW1lICsgJ2AgaXMgbWFya2VkIGFzIHJlcXVpcmVkICcgKyAoJ2luIGAnICsgY29tcG9uZW50TmFtZSArICdgLCBidXQgaXRzIHZhbHVlIGlzIGBudWxsYC4nKSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiBuZXcgUHJvcFR5cGVFcnJvcignVGhlICcgKyBsb2NhdGlvbiArICcgYCcgKyBwcm9wRnVsbE5hbWUgKyAnYCBpcyBtYXJrZWQgYXMgcmVxdWlyZWQgaW4gJyArICgnYCcgKyBjb21wb25lbnROYW1lICsgJ2AsIGJ1dCBpdHMgdmFsdWUgaXMgYHVuZGVmaW5lZGAuJykpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIHZhbGlkYXRlKHByb3BzLCBwcm9wTmFtZSwgY29tcG9uZW50TmFtZSwgbG9jYXRpb24sIHByb3BGdWxsTmFtZSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgdmFyIGNoYWluZWRDaGVja1R5cGUgPSBjaGVja1R5cGUuYmluZChudWxsLCBmYWxzZSk7XG4gICAgY2hhaW5lZENoZWNrVHlwZS5pc1JlcXVpcmVkID0gY2hlY2tUeXBlLmJpbmQobnVsbCwgdHJ1ZSk7XG5cbiAgICByZXR1cm4gY2hhaW5lZENoZWNrVHlwZTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGNyZWF0ZVByaW1pdGl2ZVR5cGVDaGVja2VyKGV4cGVjdGVkVHlwZSkge1xuICAgIGZ1bmN0aW9uIHZhbGlkYXRlKHByb3BzLCBwcm9wTmFtZSwgY29tcG9uZW50TmFtZSwgbG9jYXRpb24sIHByb3BGdWxsTmFtZSwgc2VjcmV0KSB7XG4gICAgICB2YXIgcHJvcFZhbHVlID0gcHJvcHNbcHJvcE5hbWVdO1xuICAgICAgdmFyIHByb3BUeXBlID0gZ2V0UHJvcFR5cGUocHJvcFZhbHVlKTtcbiAgICAgIGlmIChwcm9wVHlwZSAhPT0gZXhwZWN0ZWRUeXBlKSB7XG4gICAgICAgIC8vIGBwcm9wVmFsdWVgIGJlaW5nIGluc3RhbmNlIG9mLCBzYXksIGRhdGUvcmVnZXhwLCBwYXNzIHRoZSAnb2JqZWN0J1xuICAgICAgICAvLyBjaGVjaywgYnV0IHdlIGNhbiBvZmZlciBhIG1vcmUgcHJlY2lzZSBlcnJvciBtZXNzYWdlIGhlcmUgcmF0aGVyIHRoYW5cbiAgICAgICAgLy8gJ29mIHR5cGUgYG9iamVjdGAnLlxuICAgICAgICB2YXIgcHJlY2lzZVR5cGUgPSBnZXRQcmVjaXNlVHlwZShwcm9wVmFsdWUpO1xuXG4gICAgICAgIHJldHVybiBuZXcgUHJvcFR5cGVFcnJvcignSW52YWxpZCAnICsgbG9jYXRpb24gKyAnIGAnICsgcHJvcEZ1bGxOYW1lICsgJ2Agb2YgdHlwZSAnICsgKCdgJyArIHByZWNpc2VUeXBlICsgJ2Agc3VwcGxpZWQgdG8gYCcgKyBjb21wb25lbnROYW1lICsgJ2AsIGV4cGVjdGVkICcpICsgKCdgJyArIGV4cGVjdGVkVHlwZSArICdgLicpKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICByZXR1cm4gY3JlYXRlQ2hhaW5hYmxlVHlwZUNoZWNrZXIodmFsaWRhdGUpO1xuICB9XG5cbiAgZnVuY3Rpb24gY3JlYXRlQW55VHlwZUNoZWNrZXIoKSB7XG4gICAgcmV0dXJuIGNyZWF0ZUNoYWluYWJsZVR5cGVDaGVja2VyKGVtcHR5RnVuY3Rpb24udGhhdFJldHVybnNOdWxsKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGNyZWF0ZUFycmF5T2ZUeXBlQ2hlY2tlcih0eXBlQ2hlY2tlcikge1xuICAgIGZ1bmN0aW9uIHZhbGlkYXRlKHByb3BzLCBwcm9wTmFtZSwgY29tcG9uZW50TmFtZSwgbG9jYXRpb24sIHByb3BGdWxsTmFtZSkge1xuICAgICAgaWYgKHR5cGVvZiB0eXBlQ2hlY2tlciAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICByZXR1cm4gbmV3IFByb3BUeXBlRXJyb3IoJ1Byb3BlcnR5IGAnICsgcHJvcEZ1bGxOYW1lICsgJ2Agb2YgY29tcG9uZW50IGAnICsgY29tcG9uZW50TmFtZSArICdgIGhhcyBpbnZhbGlkIFByb3BUeXBlIG5vdGF0aW9uIGluc2lkZSBhcnJheU9mLicpO1xuICAgICAgfVxuICAgICAgdmFyIHByb3BWYWx1ZSA9IHByb3BzW3Byb3BOYW1lXTtcbiAgICAgIGlmICghQXJyYXkuaXNBcnJheShwcm9wVmFsdWUpKSB7XG4gICAgICAgIHZhciBwcm9wVHlwZSA9IGdldFByb3BUeXBlKHByb3BWYWx1ZSk7XG4gICAgICAgIHJldHVybiBuZXcgUHJvcFR5cGVFcnJvcignSW52YWxpZCAnICsgbG9jYXRpb24gKyAnIGAnICsgcHJvcEZ1bGxOYW1lICsgJ2Agb2YgdHlwZSAnICsgKCdgJyArIHByb3BUeXBlICsgJ2Agc3VwcGxpZWQgdG8gYCcgKyBjb21wb25lbnROYW1lICsgJ2AsIGV4cGVjdGVkIGFuIGFycmF5LicpKTtcbiAgICAgIH1cbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcHJvcFZhbHVlLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciBlcnJvciA9IHR5cGVDaGVja2VyKHByb3BWYWx1ZSwgaSwgY29tcG9uZW50TmFtZSwgbG9jYXRpb24sIHByb3BGdWxsTmFtZSArICdbJyArIGkgKyAnXScsIFJlYWN0UHJvcFR5cGVzU2VjcmV0KTtcbiAgICAgICAgaWYgKGVycm9yIGluc3RhbmNlb2YgRXJyb3IpIHtcbiAgICAgICAgICByZXR1cm4gZXJyb3I7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICByZXR1cm4gY3JlYXRlQ2hhaW5hYmxlVHlwZUNoZWNrZXIodmFsaWRhdGUpO1xuICB9XG5cbiAgZnVuY3Rpb24gY3JlYXRlRWxlbWVudFR5cGVDaGVja2VyKCkge1xuICAgIGZ1bmN0aW9uIHZhbGlkYXRlKHByb3BzLCBwcm9wTmFtZSwgY29tcG9uZW50TmFtZSwgbG9jYXRpb24sIHByb3BGdWxsTmFtZSkge1xuICAgICAgdmFyIHByb3BWYWx1ZSA9IHByb3BzW3Byb3BOYW1lXTtcbiAgICAgIGlmICghaXNWYWxpZEVsZW1lbnQocHJvcFZhbHVlKSkge1xuICAgICAgICB2YXIgcHJvcFR5cGUgPSBnZXRQcm9wVHlwZShwcm9wVmFsdWUpO1xuICAgICAgICByZXR1cm4gbmV3IFByb3BUeXBlRXJyb3IoJ0ludmFsaWQgJyArIGxvY2F0aW9uICsgJyBgJyArIHByb3BGdWxsTmFtZSArICdgIG9mIHR5cGUgJyArICgnYCcgKyBwcm9wVHlwZSArICdgIHN1cHBsaWVkIHRvIGAnICsgY29tcG9uZW50TmFtZSArICdgLCBleHBlY3RlZCBhIHNpbmdsZSBSZWFjdEVsZW1lbnQuJykpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIHJldHVybiBjcmVhdGVDaGFpbmFibGVUeXBlQ2hlY2tlcih2YWxpZGF0ZSk7XG4gIH1cblxuICBmdW5jdGlvbiBjcmVhdGVJbnN0YW5jZVR5cGVDaGVja2VyKGV4cGVjdGVkQ2xhc3MpIHtcbiAgICBmdW5jdGlvbiB2YWxpZGF0ZShwcm9wcywgcHJvcE5hbWUsIGNvbXBvbmVudE5hbWUsIGxvY2F0aW9uLCBwcm9wRnVsbE5hbWUpIHtcbiAgICAgIGlmICghKHByb3BzW3Byb3BOYW1lXSBpbnN0YW5jZW9mIGV4cGVjdGVkQ2xhc3MpKSB7XG4gICAgICAgIHZhciBleHBlY3RlZENsYXNzTmFtZSA9IGV4cGVjdGVkQ2xhc3MubmFtZSB8fCBBTk9OWU1PVVM7XG4gICAgICAgIHZhciBhY3R1YWxDbGFzc05hbWUgPSBnZXRDbGFzc05hbWUocHJvcHNbcHJvcE5hbWVdKTtcbiAgICAgICAgcmV0dXJuIG5ldyBQcm9wVHlwZUVycm9yKCdJbnZhbGlkICcgKyBsb2NhdGlvbiArICcgYCcgKyBwcm9wRnVsbE5hbWUgKyAnYCBvZiB0eXBlICcgKyAoJ2AnICsgYWN0dWFsQ2xhc3NOYW1lICsgJ2Agc3VwcGxpZWQgdG8gYCcgKyBjb21wb25lbnROYW1lICsgJ2AsIGV4cGVjdGVkICcpICsgKCdpbnN0YW5jZSBvZiBgJyArIGV4cGVjdGVkQ2xhc3NOYW1lICsgJ2AuJykpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIHJldHVybiBjcmVhdGVDaGFpbmFibGVUeXBlQ2hlY2tlcih2YWxpZGF0ZSk7XG4gIH1cblxuICBmdW5jdGlvbiBjcmVhdGVFbnVtVHlwZUNoZWNrZXIoZXhwZWN0ZWRWYWx1ZXMpIHtcbiAgICBpZiAoIUFycmF5LmlzQXJyYXkoZXhwZWN0ZWRWYWx1ZXMpKSB7XG4gICAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gd2FybmluZyhmYWxzZSwgJ0ludmFsaWQgYXJndW1lbnQgc3VwcGxpZWQgdG8gb25lT2YsIGV4cGVjdGVkIGFuIGluc3RhbmNlIG9mIGFycmF5LicpIDogdm9pZCAwO1xuICAgICAgcmV0dXJuIGVtcHR5RnVuY3Rpb24udGhhdFJldHVybnNOdWxsO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHZhbGlkYXRlKHByb3BzLCBwcm9wTmFtZSwgY29tcG9uZW50TmFtZSwgbG9jYXRpb24sIHByb3BGdWxsTmFtZSkge1xuICAgICAgdmFyIHByb3BWYWx1ZSA9IHByb3BzW3Byb3BOYW1lXTtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZXhwZWN0ZWRWYWx1ZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgaWYgKGlzKHByb3BWYWx1ZSwgZXhwZWN0ZWRWYWx1ZXNbaV0pKSB7XG4gICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgdmFyIHZhbHVlc1N0cmluZyA9IEpTT04uc3RyaW5naWZ5KGV4cGVjdGVkVmFsdWVzKTtcbiAgICAgIHJldHVybiBuZXcgUHJvcFR5cGVFcnJvcignSW52YWxpZCAnICsgbG9jYXRpb24gKyAnIGAnICsgcHJvcEZ1bGxOYW1lICsgJ2Agb2YgdmFsdWUgYCcgKyBwcm9wVmFsdWUgKyAnYCAnICsgKCdzdXBwbGllZCB0byBgJyArIGNvbXBvbmVudE5hbWUgKyAnYCwgZXhwZWN0ZWQgb25lIG9mICcgKyB2YWx1ZXNTdHJpbmcgKyAnLicpKTtcbiAgICB9XG4gICAgcmV0dXJuIGNyZWF0ZUNoYWluYWJsZVR5cGVDaGVja2VyKHZhbGlkYXRlKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGNyZWF0ZU9iamVjdE9mVHlwZUNoZWNrZXIodHlwZUNoZWNrZXIpIHtcbiAgICBmdW5jdGlvbiB2YWxpZGF0ZShwcm9wcywgcHJvcE5hbWUsIGNvbXBvbmVudE5hbWUsIGxvY2F0aW9uLCBwcm9wRnVsbE5hbWUpIHtcbiAgICAgIGlmICh0eXBlb2YgdHlwZUNoZWNrZXIgIT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBQcm9wVHlwZUVycm9yKCdQcm9wZXJ0eSBgJyArIHByb3BGdWxsTmFtZSArICdgIG9mIGNvbXBvbmVudCBgJyArIGNvbXBvbmVudE5hbWUgKyAnYCBoYXMgaW52YWxpZCBQcm9wVHlwZSBub3RhdGlvbiBpbnNpZGUgb2JqZWN0T2YuJyk7XG4gICAgICB9XG4gICAgICB2YXIgcHJvcFZhbHVlID0gcHJvcHNbcHJvcE5hbWVdO1xuICAgICAgdmFyIHByb3BUeXBlID0gZ2V0UHJvcFR5cGUocHJvcFZhbHVlKTtcbiAgICAgIGlmIChwcm9wVHlwZSAhPT0gJ29iamVjdCcpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBQcm9wVHlwZUVycm9yKCdJbnZhbGlkICcgKyBsb2NhdGlvbiArICcgYCcgKyBwcm9wRnVsbE5hbWUgKyAnYCBvZiB0eXBlICcgKyAoJ2AnICsgcHJvcFR5cGUgKyAnYCBzdXBwbGllZCB0byBgJyArIGNvbXBvbmVudE5hbWUgKyAnYCwgZXhwZWN0ZWQgYW4gb2JqZWN0LicpKTtcbiAgICAgIH1cbiAgICAgIGZvciAodmFyIGtleSBpbiBwcm9wVmFsdWUpIHtcbiAgICAgICAgaWYgKHByb3BWYWx1ZS5oYXNPd25Qcm9wZXJ0eShrZXkpKSB7XG4gICAgICAgICAgdmFyIGVycm9yID0gdHlwZUNoZWNrZXIocHJvcFZhbHVlLCBrZXksIGNvbXBvbmVudE5hbWUsIGxvY2F0aW9uLCBwcm9wRnVsbE5hbWUgKyAnLicgKyBrZXksIFJlYWN0UHJvcFR5cGVzU2VjcmV0KTtcbiAgICAgICAgICBpZiAoZXJyb3IgaW5zdGFuY2VvZiBFcnJvcikge1xuICAgICAgICAgICAgcmV0dXJuIGVycm9yO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIHJldHVybiBjcmVhdGVDaGFpbmFibGVUeXBlQ2hlY2tlcih2YWxpZGF0ZSk7XG4gIH1cblxuICBmdW5jdGlvbiBjcmVhdGVVbmlvblR5cGVDaGVja2VyKGFycmF5T2ZUeXBlQ2hlY2tlcnMpIHtcbiAgICBpZiAoIUFycmF5LmlzQXJyYXkoYXJyYXlPZlR5cGVDaGVja2VycykpIHtcbiAgICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyB3YXJuaW5nKGZhbHNlLCAnSW52YWxpZCBhcmd1bWVudCBzdXBwbGllZCB0byBvbmVPZlR5cGUsIGV4cGVjdGVkIGFuIGluc3RhbmNlIG9mIGFycmF5LicpIDogdm9pZCAwO1xuICAgICAgcmV0dXJuIGVtcHR5RnVuY3Rpb24udGhhdFJldHVybnNOdWxsO1xuICAgIH1cblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYXJyYXlPZlR5cGVDaGVja2Vycy5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIGNoZWNrZXIgPSBhcnJheU9mVHlwZUNoZWNrZXJzW2ldO1xuICAgICAgaWYgKHR5cGVvZiBjaGVja2VyICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIHdhcm5pbmcoXG4gICAgICAgICAgZmFsc2UsXG4gICAgICAgICAgJ0ludmFsaWQgYXJndW1lbnQgc3VwcGxpZWQgdG8gb25lT2ZUeXBlLiBFeHBlY3RlZCBhbiBhcnJheSBvZiBjaGVjayBmdW5jdGlvbnMsIGJ1dCAnICtcbiAgICAgICAgICAncmVjZWl2ZWQgJXMgYXQgaW5kZXggJXMuJyxcbiAgICAgICAgICBnZXRQb3N0Zml4Rm9yVHlwZVdhcm5pbmcoY2hlY2tlciksXG4gICAgICAgICAgaVxuICAgICAgICApO1xuICAgICAgICByZXR1cm4gZW1wdHlGdW5jdGlvbi50aGF0UmV0dXJuc051bGw7XG4gICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gdmFsaWRhdGUocHJvcHMsIHByb3BOYW1lLCBjb21wb25lbnROYW1lLCBsb2NhdGlvbiwgcHJvcEZ1bGxOYW1lKSB7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGFycmF5T2ZUeXBlQ2hlY2tlcnMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIGNoZWNrZXIgPSBhcnJheU9mVHlwZUNoZWNrZXJzW2ldO1xuICAgICAgICBpZiAoY2hlY2tlcihwcm9wcywgcHJvcE5hbWUsIGNvbXBvbmVudE5hbWUsIGxvY2F0aW9uLCBwcm9wRnVsbE5hbWUsIFJlYWN0UHJvcFR5cGVzU2VjcmV0KSA9PSBudWxsKSB7XG4gICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIG5ldyBQcm9wVHlwZUVycm9yKCdJbnZhbGlkICcgKyBsb2NhdGlvbiArICcgYCcgKyBwcm9wRnVsbE5hbWUgKyAnYCBzdXBwbGllZCB0byAnICsgKCdgJyArIGNvbXBvbmVudE5hbWUgKyAnYC4nKSk7XG4gICAgfVxuICAgIHJldHVybiBjcmVhdGVDaGFpbmFibGVUeXBlQ2hlY2tlcih2YWxpZGF0ZSk7XG4gIH1cblxuICBmdW5jdGlvbiBjcmVhdGVOb2RlQ2hlY2tlcigpIHtcbiAgICBmdW5jdGlvbiB2YWxpZGF0ZShwcm9wcywgcHJvcE5hbWUsIGNvbXBvbmVudE5hbWUsIGxvY2F0aW9uLCBwcm9wRnVsbE5hbWUpIHtcbiAgICAgIGlmICghaXNOb2RlKHByb3BzW3Byb3BOYW1lXSkpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBQcm9wVHlwZUVycm9yKCdJbnZhbGlkICcgKyBsb2NhdGlvbiArICcgYCcgKyBwcm9wRnVsbE5hbWUgKyAnYCBzdXBwbGllZCB0byAnICsgKCdgJyArIGNvbXBvbmVudE5hbWUgKyAnYCwgZXhwZWN0ZWQgYSBSZWFjdE5vZGUuJykpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIHJldHVybiBjcmVhdGVDaGFpbmFibGVUeXBlQ2hlY2tlcih2YWxpZGF0ZSk7XG4gIH1cblxuICBmdW5jdGlvbiBjcmVhdGVTaGFwZVR5cGVDaGVja2VyKHNoYXBlVHlwZXMpIHtcbiAgICBmdW5jdGlvbiB2YWxpZGF0ZShwcm9wcywgcHJvcE5hbWUsIGNvbXBvbmVudE5hbWUsIGxvY2F0aW9uLCBwcm9wRnVsbE5hbWUpIHtcbiAgICAgIHZhciBwcm9wVmFsdWUgPSBwcm9wc1twcm9wTmFtZV07XG4gICAgICB2YXIgcHJvcFR5cGUgPSBnZXRQcm9wVHlwZShwcm9wVmFsdWUpO1xuICAgICAgaWYgKHByb3BUeXBlICE9PSAnb2JqZWN0Jykge1xuICAgICAgICByZXR1cm4gbmV3IFByb3BUeXBlRXJyb3IoJ0ludmFsaWQgJyArIGxvY2F0aW9uICsgJyBgJyArIHByb3BGdWxsTmFtZSArICdgIG9mIHR5cGUgYCcgKyBwcm9wVHlwZSArICdgICcgKyAoJ3N1cHBsaWVkIHRvIGAnICsgY29tcG9uZW50TmFtZSArICdgLCBleHBlY3RlZCBgb2JqZWN0YC4nKSk7XG4gICAgICB9XG4gICAgICBmb3IgKHZhciBrZXkgaW4gc2hhcGVUeXBlcykge1xuICAgICAgICB2YXIgY2hlY2tlciA9IHNoYXBlVHlwZXNba2V5XTtcbiAgICAgICAgaWYgKCFjaGVja2VyKSB7XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGVycm9yID0gY2hlY2tlcihwcm9wVmFsdWUsIGtleSwgY29tcG9uZW50TmFtZSwgbG9jYXRpb24sIHByb3BGdWxsTmFtZSArICcuJyArIGtleSwgUmVhY3RQcm9wVHlwZXNTZWNyZXQpO1xuICAgICAgICBpZiAoZXJyb3IpIHtcbiAgICAgICAgICByZXR1cm4gZXJyb3I7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICByZXR1cm4gY3JlYXRlQ2hhaW5hYmxlVHlwZUNoZWNrZXIodmFsaWRhdGUpO1xuICB9XG5cbiAgZnVuY3Rpb24gY3JlYXRlU3RyaWN0U2hhcGVUeXBlQ2hlY2tlcihzaGFwZVR5cGVzKSB7XG4gICAgZnVuY3Rpb24gdmFsaWRhdGUocHJvcHMsIHByb3BOYW1lLCBjb21wb25lbnROYW1lLCBsb2NhdGlvbiwgcHJvcEZ1bGxOYW1lKSB7XG4gICAgICB2YXIgcHJvcFZhbHVlID0gcHJvcHNbcHJvcE5hbWVdO1xuICAgICAgdmFyIHByb3BUeXBlID0gZ2V0UHJvcFR5cGUocHJvcFZhbHVlKTtcbiAgICAgIGlmIChwcm9wVHlwZSAhPT0gJ29iamVjdCcpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBQcm9wVHlwZUVycm9yKCdJbnZhbGlkICcgKyBsb2NhdGlvbiArICcgYCcgKyBwcm9wRnVsbE5hbWUgKyAnYCBvZiB0eXBlIGAnICsgcHJvcFR5cGUgKyAnYCAnICsgKCdzdXBwbGllZCB0byBgJyArIGNvbXBvbmVudE5hbWUgKyAnYCwgZXhwZWN0ZWQgYG9iamVjdGAuJykpO1xuICAgICAgfVxuICAgICAgLy8gV2UgbmVlZCB0byBjaGVjayBhbGwga2V5cyBpbiBjYXNlIHNvbWUgYXJlIHJlcXVpcmVkIGJ1dCBtaXNzaW5nIGZyb21cbiAgICAgIC8vIHByb3BzLlxuICAgICAgdmFyIGFsbEtleXMgPSBhc3NpZ24oe30sIHByb3BzW3Byb3BOYW1lXSwgc2hhcGVUeXBlcyk7XG4gICAgICBmb3IgKHZhciBrZXkgaW4gYWxsS2V5cykge1xuICAgICAgICB2YXIgY2hlY2tlciA9IHNoYXBlVHlwZXNba2V5XTtcbiAgICAgICAgaWYgKCFjaGVja2VyKSB7XG4gICAgICAgICAgcmV0dXJuIG5ldyBQcm9wVHlwZUVycm9yKFxuICAgICAgICAgICAgJ0ludmFsaWQgJyArIGxvY2F0aW9uICsgJyBgJyArIHByb3BGdWxsTmFtZSArICdgIGtleSBgJyArIGtleSArICdgIHN1cHBsaWVkIHRvIGAnICsgY29tcG9uZW50TmFtZSArICdgLicgK1xuICAgICAgICAgICAgJ1xcbkJhZCBvYmplY3Q6ICcgKyBKU09OLnN0cmluZ2lmeShwcm9wc1twcm9wTmFtZV0sIG51bGwsICcgICcpICtcbiAgICAgICAgICAgICdcXG5WYWxpZCBrZXlzOiAnICsgIEpTT04uc3RyaW5naWZ5KE9iamVjdC5rZXlzKHNoYXBlVHlwZXMpLCBudWxsLCAnICAnKVxuICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGVycm9yID0gY2hlY2tlcihwcm9wVmFsdWUsIGtleSwgY29tcG9uZW50TmFtZSwgbG9jYXRpb24sIHByb3BGdWxsTmFtZSArICcuJyArIGtleSwgUmVhY3RQcm9wVHlwZXNTZWNyZXQpO1xuICAgICAgICBpZiAoZXJyb3IpIHtcbiAgICAgICAgICByZXR1cm4gZXJyb3I7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cblxuICAgIHJldHVybiBjcmVhdGVDaGFpbmFibGVUeXBlQ2hlY2tlcih2YWxpZGF0ZSk7XG4gIH1cblxuICBmdW5jdGlvbiBpc05vZGUocHJvcFZhbHVlKSB7XG4gICAgc3dpdGNoICh0eXBlb2YgcHJvcFZhbHVlKSB7XG4gICAgICBjYXNlICdudW1iZXInOlxuICAgICAgY2FzZSAnc3RyaW5nJzpcbiAgICAgIGNhc2UgJ3VuZGVmaW5lZCc6XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgY2FzZSAnYm9vbGVhbic6XG4gICAgICAgIHJldHVybiAhcHJvcFZhbHVlO1xuICAgICAgY2FzZSAnb2JqZWN0JzpcbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkocHJvcFZhbHVlKSkge1xuICAgICAgICAgIHJldHVybiBwcm9wVmFsdWUuZXZlcnkoaXNOb2RlKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAocHJvcFZhbHVlID09PSBudWxsIHx8IGlzVmFsaWRFbGVtZW50KHByb3BWYWx1ZSkpIHtcbiAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBpdGVyYXRvckZuID0gZ2V0SXRlcmF0b3JGbihwcm9wVmFsdWUpO1xuICAgICAgICBpZiAoaXRlcmF0b3JGbikge1xuICAgICAgICAgIHZhciBpdGVyYXRvciA9IGl0ZXJhdG9yRm4uY2FsbChwcm9wVmFsdWUpO1xuICAgICAgICAgIHZhciBzdGVwO1xuICAgICAgICAgIGlmIChpdGVyYXRvckZuICE9PSBwcm9wVmFsdWUuZW50cmllcykge1xuICAgICAgICAgICAgd2hpbGUgKCEoc3RlcCA9IGl0ZXJhdG9yLm5leHQoKSkuZG9uZSkge1xuICAgICAgICAgICAgICBpZiAoIWlzTm9kZShzdGVwLnZhbHVlKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAvLyBJdGVyYXRvciB3aWxsIHByb3ZpZGUgZW50cnkgW2ssdl0gdHVwbGVzIHJhdGhlciB0aGFuIHZhbHVlcy5cbiAgICAgICAgICAgIHdoaWxlICghKHN0ZXAgPSBpdGVyYXRvci5uZXh0KCkpLmRvbmUpIHtcbiAgICAgICAgICAgICAgdmFyIGVudHJ5ID0gc3RlcC52YWx1ZTtcbiAgICAgICAgICAgICAgaWYgKGVudHJ5KSB7XG4gICAgICAgICAgICAgICAgaWYgKCFpc05vZGUoZW50cnlbMV0pKSB7XG4gICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGlzU3ltYm9sKHByb3BUeXBlLCBwcm9wVmFsdWUpIHtcbiAgICAvLyBOYXRpdmUgU3ltYm9sLlxuICAgIGlmIChwcm9wVHlwZSA9PT0gJ3N5bWJvbCcpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cblxuICAgIC8vIDE5LjQuMy41IFN5bWJvbC5wcm90b3R5cGVbQEB0b1N0cmluZ1RhZ10gPT09ICdTeW1ib2wnXG4gICAgaWYgKHByb3BWYWx1ZVsnQEB0b1N0cmluZ1RhZyddID09PSAnU3ltYm9sJykge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuXG4gICAgLy8gRmFsbGJhY2sgZm9yIG5vbi1zcGVjIGNvbXBsaWFudCBTeW1ib2xzIHdoaWNoIGFyZSBwb2x5ZmlsbGVkLlxuICAgIGlmICh0eXBlb2YgU3ltYm9sID09PSAnZnVuY3Rpb24nICYmIHByb3BWYWx1ZSBpbnN0YW5jZW9mIFN5bWJvbCkge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuXG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgLy8gRXF1aXZhbGVudCBvZiBgdHlwZW9mYCBidXQgd2l0aCBzcGVjaWFsIGhhbmRsaW5nIGZvciBhcnJheSBhbmQgcmVnZXhwLlxuICBmdW5jdGlvbiBnZXRQcm9wVHlwZShwcm9wVmFsdWUpIHtcbiAgICB2YXIgcHJvcFR5cGUgPSB0eXBlb2YgcHJvcFZhbHVlO1xuICAgIGlmIChBcnJheS5pc0FycmF5KHByb3BWYWx1ZSkpIHtcbiAgICAgIHJldHVybiAnYXJyYXknO1xuICAgIH1cbiAgICBpZiAocHJvcFZhbHVlIGluc3RhbmNlb2YgUmVnRXhwKSB7XG4gICAgICAvLyBPbGQgd2Via2l0cyAoYXQgbGVhc3QgdW50aWwgQW5kcm9pZCA0LjApIHJldHVybiAnZnVuY3Rpb24nIHJhdGhlciB0aGFuXG4gICAgICAvLyAnb2JqZWN0JyBmb3IgdHlwZW9mIGEgUmVnRXhwLiBXZSdsbCBub3JtYWxpemUgdGhpcyBoZXJlIHNvIHRoYXQgL2JsYS9cbiAgICAgIC8vIHBhc3NlcyBQcm9wVHlwZXMub2JqZWN0LlxuICAgICAgcmV0dXJuICdvYmplY3QnO1xuICAgIH1cbiAgICBpZiAoaXNTeW1ib2wocHJvcFR5cGUsIHByb3BWYWx1ZSkpIHtcbiAgICAgIHJldHVybiAnc3ltYm9sJztcbiAgICB9XG4gICAgcmV0dXJuIHByb3BUeXBlO1xuICB9XG5cbiAgLy8gVGhpcyBoYW5kbGVzIG1vcmUgdHlwZXMgdGhhbiBgZ2V0UHJvcFR5cGVgLiBPbmx5IHVzZWQgZm9yIGVycm9yIG1lc3NhZ2VzLlxuICAvLyBTZWUgYGNyZWF0ZVByaW1pdGl2ZVR5cGVDaGVja2VyYC5cbiAgZnVuY3Rpb24gZ2V0UHJlY2lzZVR5cGUocHJvcFZhbHVlKSB7XG4gICAgaWYgKHR5cGVvZiBwcm9wVmFsdWUgPT09ICd1bmRlZmluZWQnIHx8IHByb3BWYWx1ZSA9PT0gbnVsbCkge1xuICAgICAgcmV0dXJuICcnICsgcHJvcFZhbHVlO1xuICAgIH1cbiAgICB2YXIgcHJvcFR5cGUgPSBnZXRQcm9wVHlwZShwcm9wVmFsdWUpO1xuICAgIGlmIChwcm9wVHlwZSA9PT0gJ29iamVjdCcpIHtcbiAgICAgIGlmIChwcm9wVmFsdWUgaW5zdGFuY2VvZiBEYXRlKSB7XG4gICAgICAgIHJldHVybiAnZGF0ZSc7XG4gICAgICB9IGVsc2UgaWYgKHByb3BWYWx1ZSBpbnN0YW5jZW9mIFJlZ0V4cCkge1xuICAgICAgICByZXR1cm4gJ3JlZ2V4cCc7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBwcm9wVHlwZTtcbiAgfVxuXG4gIC8vIFJldHVybnMgYSBzdHJpbmcgdGhhdCBpcyBwb3N0Zml4ZWQgdG8gYSB3YXJuaW5nIGFib3V0IGFuIGludmFsaWQgdHlwZS5cbiAgLy8gRm9yIGV4YW1wbGUsIFwidW5kZWZpbmVkXCIgb3IgXCJvZiB0eXBlIGFycmF5XCJcbiAgZnVuY3Rpb24gZ2V0UG9zdGZpeEZvclR5cGVXYXJuaW5nKHZhbHVlKSB7XG4gICAgdmFyIHR5cGUgPSBnZXRQcmVjaXNlVHlwZSh2YWx1ZSk7XG4gICAgc3dpdGNoICh0eXBlKSB7XG4gICAgICBjYXNlICdhcnJheSc6XG4gICAgICBjYXNlICdvYmplY3QnOlxuICAgICAgICByZXR1cm4gJ2FuICcgKyB0eXBlO1xuICAgICAgY2FzZSAnYm9vbGVhbic6XG4gICAgICBjYXNlICdkYXRlJzpcbiAgICAgIGNhc2UgJ3JlZ2V4cCc6XG4gICAgICAgIHJldHVybiAnYSAnICsgdHlwZTtcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHJldHVybiB0eXBlO1xuICAgIH1cbiAgfVxuXG4gIC8vIFJldHVybnMgY2xhc3MgbmFtZSBvZiB0aGUgb2JqZWN0LCBpZiBhbnkuXG4gIGZ1bmN0aW9uIGdldENsYXNzTmFtZShwcm9wVmFsdWUpIHtcbiAgICBpZiAoIXByb3BWYWx1ZS5jb25zdHJ1Y3RvciB8fCAhcHJvcFZhbHVlLmNvbnN0cnVjdG9yLm5hbWUpIHtcbiAgICAgIHJldHVybiBBTk9OWU1PVVM7XG4gICAgfVxuICAgIHJldHVybiBwcm9wVmFsdWUuY29uc3RydWN0b3IubmFtZTtcbiAgfVxuXG4gIFJlYWN0UHJvcFR5cGVzLmNoZWNrUHJvcFR5cGVzID0gY2hlY2tQcm9wVHlwZXM7XG4gIFJlYWN0UHJvcFR5cGVzLlByb3BUeXBlcyA9IFJlYWN0UHJvcFR5cGVzO1xuXG4gIHJldHVybiBSZWFjdFByb3BUeXBlcztcbn07XG5cblxuLyoqKi8gfSksXG4vKiAxMyAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcbi8qKlxuICogQ29weXJpZ2h0IChjKSAyMDEzLXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKi9cblxuXG5cbnZhciBlbXB0eUZ1bmN0aW9uID0gX193ZWJwYWNrX3JlcXVpcmVfXygxKTtcbnZhciBpbnZhcmlhbnQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDApO1xudmFyIFJlYWN0UHJvcFR5cGVzU2VjcmV0ID0gX193ZWJwYWNrX3JlcXVpcmVfXyg0KTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbigpIHtcbiAgZnVuY3Rpb24gc2hpbShwcm9wcywgcHJvcE5hbWUsIGNvbXBvbmVudE5hbWUsIGxvY2F0aW9uLCBwcm9wRnVsbE5hbWUsIHNlY3JldCkge1xuICAgIGlmIChzZWNyZXQgPT09IFJlYWN0UHJvcFR5cGVzU2VjcmV0KSB7XG4gICAgICAvLyBJdCBpcyBzdGlsbCBzYWZlIHdoZW4gY2FsbGVkIGZyb20gUmVhY3QuXG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGludmFyaWFudChcbiAgICAgIGZhbHNlLFxuICAgICAgJ0NhbGxpbmcgUHJvcFR5cGVzIHZhbGlkYXRvcnMgZGlyZWN0bHkgaXMgbm90IHN1cHBvcnRlZCBieSB0aGUgYHByb3AtdHlwZXNgIHBhY2thZ2UuICcgK1xuICAgICAgJ1VzZSBQcm9wVHlwZXMuY2hlY2tQcm9wVHlwZXMoKSB0byBjYWxsIHRoZW0uICcgK1xuICAgICAgJ1JlYWQgbW9yZSBhdCBodHRwOi8vZmIubWUvdXNlLWNoZWNrLXByb3AtdHlwZXMnXG4gICAgKTtcbiAgfTtcbiAgc2hpbS5pc1JlcXVpcmVkID0gc2hpbTtcbiAgZnVuY3Rpb24gZ2V0U2hpbSgpIHtcbiAgICByZXR1cm4gc2hpbTtcbiAgfTtcbiAgLy8gSW1wb3J0YW50IVxuICAvLyBLZWVwIHRoaXMgbGlzdCBpbiBzeW5jIHdpdGggcHJvZHVjdGlvbiB2ZXJzaW9uIGluIGAuL2ZhY3RvcnlXaXRoVHlwZUNoZWNrZXJzLmpzYC5cbiAgdmFyIFJlYWN0UHJvcFR5cGVzID0ge1xuICAgIGFycmF5OiBzaGltLFxuICAgIGJvb2w6IHNoaW0sXG4gICAgZnVuYzogc2hpbSxcbiAgICBudW1iZXI6IHNoaW0sXG4gICAgb2JqZWN0OiBzaGltLFxuICAgIHN0cmluZzogc2hpbSxcbiAgICBzeW1ib2w6IHNoaW0sXG5cbiAgICBhbnk6IHNoaW0sXG4gICAgYXJyYXlPZjogZ2V0U2hpbSxcbiAgICBlbGVtZW50OiBzaGltLFxuICAgIGluc3RhbmNlT2Y6IGdldFNoaW0sXG4gICAgbm9kZTogc2hpbSxcbiAgICBvYmplY3RPZjogZ2V0U2hpbSxcbiAgICBvbmVPZjogZ2V0U2hpbSxcbiAgICBvbmVPZlR5cGU6IGdldFNoaW0sXG4gICAgc2hhcGU6IGdldFNoaW0sXG4gICAgZXhhY3Q6IGdldFNoaW1cbiAgfTtcblxuICBSZWFjdFByb3BUeXBlcy5jaGVja1Byb3BUeXBlcyA9IGVtcHR5RnVuY3Rpb247XG4gIFJlYWN0UHJvcFR5cGVzLlByb3BUeXBlcyA9IFJlYWN0UHJvcFR5cGVzO1xuXG4gIHJldHVybiBSZWFjdFByb3BUeXBlcztcbn07XG5cblxuLyoqKi8gfSksXG4vKiAxNCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcblxuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuXG52YXIgX2JsYW5rID0gX193ZWJwYWNrX3JlcXVpcmVfXygxNSk7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCAnYmxhbmsnLCB7XG4gIGVudW1lcmFibGU6IHRydWUsXG4gIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgIHJldHVybiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9ibGFuaykuZGVmYXVsdDtcbiAgfVxufSk7XG5cbnZhciBfbG9hZGluZ0JhbGxzID0gX193ZWJwYWNrX3JlcXVpcmVfXygxNik7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCAnYmFsbHMnLCB7XG4gIGVudW1lcmFibGU6IHRydWUsXG4gIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgIHJldHVybiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9sb2FkaW5nQmFsbHMpLmRlZmF1bHQ7XG4gIH1cbn0pO1xuXG52YXIgX2xvYWRpbmdCYXJzID0gX193ZWJwYWNrX3JlcXVpcmVfXygxNyk7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCAnYmFycycsIHtcbiAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgcmV0dXJuIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2xvYWRpbmdCYXJzKS5kZWZhdWx0O1xuICB9XG59KTtcblxudmFyIF9sb2FkaW5nQnViYmxlcyA9IF9fd2VicGFja19yZXF1aXJlX18oMTgpO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgJ2J1YmJsZXMnLCB7XG4gIGVudW1lcmFibGU6IHRydWUsXG4gIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgIHJldHVybiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9sb2FkaW5nQnViYmxlcykuZGVmYXVsdDtcbiAgfVxufSk7XG5cbnZhciBfbG9hZGluZ0N1YmVzID0gX193ZWJwYWNrX3JlcXVpcmVfXygxOSk7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCAnY3ViZXMnLCB7XG4gIGVudW1lcmFibGU6IHRydWUsXG4gIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgIHJldHVybiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9sb2FkaW5nQ3ViZXMpLmRlZmF1bHQ7XG4gIH1cbn0pO1xuXG52YXIgX2xvYWRpbmdDeWxvbiA9IF9fd2VicGFja19yZXF1aXJlX18oMjApO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgJ2N5bG9uJywge1xuICBlbnVtZXJhYmxlOiB0cnVlLFxuICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICByZXR1cm4gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfbG9hZGluZ0N5bG9uKS5kZWZhdWx0O1xuICB9XG59KTtcblxudmFyIF9sb2FkaW5nU3BpbiA9IF9fd2VicGFja19yZXF1aXJlX18oMjEpO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgJ3NwaW4nLCB7XG4gIGVudW1lcmFibGU6IHRydWUsXG4gIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgIHJldHVybiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9sb2FkaW5nU3BpbikuZGVmYXVsdDtcbiAgfVxufSk7XG5cbnZhciBfbG9hZGluZ1NwaW5uaW5nQnViYmxlcyA9IF9fd2VicGFja19yZXF1aXJlX18oMjIpO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgJ3NwaW5uaW5nQnViYmxlcycsIHtcbiAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgcmV0dXJuIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2xvYWRpbmdTcGlubmluZ0J1YmJsZXMpLmRlZmF1bHQ7XG4gIH1cbn0pO1xuXG52YXIgX2xvYWRpbmdTcG9rZXMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDIzKTtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsICdzcG9rZXMnLCB7XG4gIGVudW1lcmFibGU6IHRydWUsXG4gIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgIHJldHVybiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9sb2FkaW5nU3Bva2VzKS5kZWZhdWx0O1xuICB9XG59KTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cblxuLyoqKi8gfSksXG4vKiAxNSAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cykge1xuXG5tb2R1bGUuZXhwb3J0cyA9IFwiPHN2ZyBjbGFzcz1cXFwiaWNvbi1ibGFua1xcXCIgeG1sbnM9XFxcImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXFxcIiB2aWV3Qm94PVxcXCIwIDAgMzIgMzJcXFwiPjwvc3ZnPlxcblwiXG5cbi8qKiovIH0pLFxuLyogMTYgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMpIHtcblxubW9kdWxlLmV4cG9ydHMgPSBcIjxzdmcgY2xhc3M9XFxcImljb24tbG9hZGluZ1xcXCIgeG1sbnM9XFxcImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXFxcIiB2aWV3Qm94PVxcXCIwIDAgMzIgMzJcXFwiPlxcbiAgPHBhdGggdHJhbnNmb3JtPVxcXCJ0cmFuc2xhdGUoLTggMClcXFwiIGQ9XFxcIk00IDEyIEE0IDQgMCAwIDAgNCAyMCBBNCA0IDAgMCAwIDQgMTJcXFwiPiBcXG4gICAgPGFuaW1hdGVUcmFuc2Zvcm0gYXR0cmlidXRlTmFtZT1cXFwidHJhbnNmb3JtXFxcIiB0eXBlPVxcXCJ0cmFuc2xhdGVcXFwiIHZhbHVlcz1cXFwiLTggMDsgMiAwOyAyIDA7XFxcIiBkdXI9XFxcIjAuOHNcXFwiIHJlcGVhdENvdW50PVxcXCJpbmRlZmluaXRlXFxcIiBiZWdpbj1cXFwiMFxcXCIga2V5dGltZXM9XFxcIjA7LjI1OzFcXFwiIGtleVNwbGluZXM9XFxcIjAuMiAwLjIgMC40IDAuODswLjIgMC42IDAuNCAwLjhcXFwiIGNhbGNNb2RlPVxcXCJzcGxpbmVcXFwiICAvPlxcbiAgPC9wYXRoPlxcbiAgPHBhdGggdHJhbnNmb3JtPVxcXCJ0cmFuc2xhdGUoMiAwKVxcXCIgZD1cXFwiTTQgMTIgQTQgNCAwIDAgMCA0IDIwIEE0IDQgMCAwIDAgNCAxMlxcXCI+IFxcbiAgICA8YW5pbWF0ZVRyYW5zZm9ybSBhdHRyaWJ1dGVOYW1lPVxcXCJ0cmFuc2Zvcm1cXFwiIHR5cGU9XFxcInRyYW5zbGF0ZVxcXCIgdmFsdWVzPVxcXCIyIDA7IDEyIDA7IDEyIDA7XFxcIiBkdXI9XFxcIjAuOHNcXFwiIHJlcGVhdENvdW50PVxcXCJpbmRlZmluaXRlXFxcIiBiZWdpbj1cXFwiMFxcXCIga2V5dGltZXM9XFxcIjA7LjM1OzFcXFwiIGtleVNwbGluZXM9XFxcIjAuMiAwLjIgMC40IDAuODswLjIgMC42IDAuNCAwLjhcXFwiIGNhbGNNb2RlPVxcXCJzcGxpbmVcXFwiICAvPlxcbiAgPC9wYXRoPlxcbiAgPHBhdGggdHJhbnNmb3JtPVxcXCJ0cmFuc2xhdGUoMTIgMClcXFwiIGQ9XFxcIk00IDEyIEE0IDQgMCAwIDAgNCAyMCBBNCA0IDAgMCAwIDQgMTJcXFwiPiBcXG4gICAgPGFuaW1hdGVUcmFuc2Zvcm0gYXR0cmlidXRlTmFtZT1cXFwidHJhbnNmb3JtXFxcIiB0eXBlPVxcXCJ0cmFuc2xhdGVcXFwiIHZhbHVlcz1cXFwiMTIgMDsgMjIgMDsgMjIgMDtcXFwiIGR1cj1cXFwiMC44c1xcXCIgcmVwZWF0Q291bnQ9XFxcImluZGVmaW5pdGVcXFwiIGJlZ2luPVxcXCIwXFxcIiBrZXl0aW1lcz1cXFwiMDsuNDU7MVxcXCIga2V5U3BsaW5lcz1cXFwiMC4yIDAuMiAwLjQgMC44OzAuMiAwLjYgMC40IDAuOFxcXCIgY2FsY01vZGU9XFxcInNwbGluZVxcXCIgIC8+XFxuICA8L3BhdGg+XFxuICA8cGF0aCB0cmFuc2Zvcm09XFxcInRyYW5zbGF0ZSgyNCAwKVxcXCIgZD1cXFwiTTQgMTIgQTQgNCAwIDAgMCA0IDIwIEE0IDQgMCAwIDAgNCAxMlxcXCI+IFxcbiAgICA8YW5pbWF0ZVRyYW5zZm9ybSBhdHRyaWJ1dGVOYW1lPVxcXCJ0cmFuc2Zvcm1cXFwiIHR5cGU9XFxcInRyYW5zbGF0ZVxcXCIgdmFsdWVzPVxcXCIyMiAwOyAzMiAwOyAzMiAwO1xcXCIgZHVyPVxcXCIwLjhzXFxcIiByZXBlYXRDb3VudD1cXFwiaW5kZWZpbml0ZVxcXCIgYmVnaW49XFxcIjBcXFwiIGtleXRpbWVzPVxcXCIwOy41NTsxXFxcIiBrZXlTcGxpbmVzPVxcXCIwLjIgMC4yIDAuNCAwLjg7MC4yIDAuNiAwLjQgMC44XFxcIiBjYWxjTW9kZT1cXFwic3BsaW5lXFxcIiAgLz5cXG4gIDwvcGF0aD5cXG48L3N2Zz5cXG5cIlxuXG4vKioqLyB9KSxcbi8qIDE3ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzKSB7XG5cbm1vZHVsZS5leHBvcnRzID0gXCI8c3ZnIHhtbG5zPVxcXCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1xcXCIgdmlld0JveD1cXFwiMCAwIDMyIDMyXFxcIj5cXG4gIDxwYXRoIHRyYW5zZm9ybT1cXFwidHJhbnNsYXRlKDIpXFxcIiBkPVxcXCJNMCAxMiBWMjAgSDQgVjEyelxcXCI+IFxcbiAgICA8YW5pbWF0ZSBhdHRyaWJ1dGVOYW1lPVxcXCJkXFxcIiB2YWx1ZXM9XFxcIk0wIDEyIFYyMCBINCBWMTJ6OyBNMCA0IFYyOCBINCBWNHo7IE0wIDEyIFYyMCBINCBWMTJ6OyBNMCAxMiBWMjAgSDQgVjEyelxcXCIgZHVyPVxcXCIxLjJzXFxcIiByZXBlYXRDb3VudD1cXFwiaW5kZWZpbml0ZVxcXCIgYmVnaW49XFxcIjBcXFwiIGtleXRpbWVzPVxcXCIwOy4yOy41OzFcXFwiIGtleVNwbGluZXM9XFxcIjAuMiAwLjIgMC40IDAuODswLjIgMC42IDAuNCAwLjg7MC4yIDAuOCAwLjQgMC44XFxcIiBjYWxjTW9kZT1cXFwic3BsaW5lXFxcIiAgLz5cXG4gIDwvcGF0aD5cXG4gIDxwYXRoIHRyYW5zZm9ybT1cXFwidHJhbnNsYXRlKDgpXFxcIiBkPVxcXCJNMCAxMiBWMjAgSDQgVjEyelxcXCI+XFxuICAgIDxhbmltYXRlIGF0dHJpYnV0ZU5hbWU9XFxcImRcXFwiIHZhbHVlcz1cXFwiTTAgMTIgVjIwIEg0IFYxMno7IE0wIDQgVjI4IEg0IFY0ejsgTTAgMTIgVjIwIEg0IFYxMno7IE0wIDEyIFYyMCBINCBWMTJ6XFxcIiBkdXI9XFxcIjEuMnNcXFwiIHJlcGVhdENvdW50PVxcXCJpbmRlZmluaXRlXFxcIiBiZWdpbj1cXFwiMC4yXFxcIiBrZXl0aW1lcz1cXFwiMDsuMjsuNTsxXFxcIiBrZXlTcGxpbmVzPVxcXCIwLjIgMC4yIDAuNCAwLjg7MC4yIDAuNiAwLjQgMC44OzAuMiAwLjggMC40IDAuOFxcXCIgY2FsY01vZGU9XFxcInNwbGluZVxcXCIgIC8+XFxuICA8L3BhdGg+XFxuICA8cGF0aCB0cmFuc2Zvcm09XFxcInRyYW5zbGF0ZSgxNClcXFwiIGQ9XFxcIk0wIDEyIFYyMCBINCBWMTJ6XFxcIj5cXG4gICAgPGFuaW1hdGUgYXR0cmlidXRlTmFtZT1cXFwiZFxcXCIgdmFsdWVzPVxcXCJNMCAxMiBWMjAgSDQgVjEyejsgTTAgNCBWMjggSDQgVjR6OyBNMCAxMiBWMjAgSDQgVjEyejsgTTAgMTIgVjIwIEg0IFYxMnpcXFwiIGR1cj1cXFwiMS4yc1xcXCIgcmVwZWF0Q291bnQ9XFxcImluZGVmaW5pdGVcXFwiIGJlZ2luPVxcXCIwLjRcXFwiIGtleXRpbWVzPVxcXCIwOy4yOy41OzFcXFwiIGtleVNwbGluZXM9XFxcIjAuMiAwLjIgMC40IDAuODswLjIgMC42IDAuNCAwLjg7MC4yIDAuOCAwLjQgMC44XFxcIiBjYWxjTW9kZT1cXFwic3BsaW5lXFxcIiAvPlxcbiAgPC9wYXRoPlxcbiAgPHBhdGggdHJhbnNmb3JtPVxcXCJ0cmFuc2xhdGUoMjApXFxcIiBkPVxcXCJNMCAxMiBWMjAgSDQgVjEyelxcXCI+XFxuICAgIDxhbmltYXRlIGF0dHJpYnV0ZU5hbWU9XFxcImRcXFwiIHZhbHVlcz1cXFwiTTAgMTIgVjIwIEg0IFYxMno7IE0wIDQgVjI4IEg0IFY0ejsgTTAgMTIgVjIwIEg0IFYxMno7IE0wIDEyIFYyMCBINCBWMTJ6XFxcIiBkdXI9XFxcIjEuMnNcXFwiIHJlcGVhdENvdW50PVxcXCJpbmRlZmluaXRlXFxcIiBiZWdpbj1cXFwiMC42XFxcIiBrZXl0aW1lcz1cXFwiMDsuMjsuNTsxXFxcIiBrZXlTcGxpbmVzPVxcXCIwLjIgMC4yIDAuNCAwLjg7MC4yIDAuNiAwLjQgMC44OzAuMiAwLjggMC40IDAuOFxcXCIgY2FsY01vZGU9XFxcInNwbGluZVxcXCIgLz5cXG4gIDwvcGF0aD5cXG4gIDxwYXRoIHRyYW5zZm9ybT1cXFwidHJhbnNsYXRlKDI2KVxcXCIgZD1cXFwiTTAgMTIgVjIwIEg0IFYxMnpcXFwiPlxcbiAgICA8YW5pbWF0ZSBhdHRyaWJ1dGVOYW1lPVxcXCJkXFxcIiB2YWx1ZXM9XFxcIk0wIDEyIFYyMCBINCBWMTJ6OyBNMCA0IFYyOCBINCBWNHo7IE0wIDEyIFYyMCBINCBWMTJ6OyBNMCAxMiBWMjAgSDQgVjEyelxcXCIgZHVyPVxcXCIxLjJzXFxcIiByZXBlYXRDb3VudD1cXFwiaW5kZWZpbml0ZVxcXCIgYmVnaW49XFxcIjAuOFxcXCIga2V5dGltZXM9XFxcIjA7LjI7LjU7MVxcXCIga2V5U3BsaW5lcz1cXFwiMC4yIDAuMiAwLjQgMC44OzAuMiAwLjYgMC40IDAuODswLjIgMC44IDAuNCAwLjhcXFwiIGNhbGNNb2RlPVxcXCJzcGxpbmVcXFwiIC8+XFxuICA8L3BhdGg+XFxuPC9zdmc+XFxuXCJcblxuLyoqKi8gfSksXG4vKiAxOCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cykge1xuXG5tb2R1bGUuZXhwb3J0cyA9IFwiPHN2ZyB4bWxucz1cXFwiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmdcXFwiIHZpZXdCb3g9XFxcIjAgMCAzMiAzMlxcXCI+XFxuICA8Y2lyY2xlIHRyYW5zZm9ybT1cXFwidHJhbnNsYXRlKDggMClcXFwiIGN4PVxcXCIwXFxcIiBjeT1cXFwiMTZcXFwiIHI9XFxcIjBcXFwiPiBcXG4gICAgPGFuaW1hdGUgYXR0cmlidXRlTmFtZT1cXFwiclxcXCIgdmFsdWVzPVxcXCIwOyA0OyAwOyAwXFxcIiBkdXI9XFxcIjEuMnNcXFwiIHJlcGVhdENvdW50PVxcXCJpbmRlZmluaXRlXFxcIiBiZWdpbj1cXFwiMFxcXCJcXG4gICAgICBrZXl0aW1lcz1cXFwiMDswLjI7MC43OzFcXFwiIGtleVNwbGluZXM9XFxcIjAuMiAwLjIgMC40IDAuODswLjIgMC42IDAuNCAwLjg7MC4yIDAuNiAwLjQgMC44XFxcIiBjYWxjTW9kZT1cXFwic3BsaW5lXFxcIiAvPlxcbiAgPC9jaXJjbGU+XFxuICA8Y2lyY2xlIHRyYW5zZm9ybT1cXFwidHJhbnNsYXRlKDE2IDApXFxcIiBjeD1cXFwiMFxcXCIgY3k9XFxcIjE2XFxcIiByPVxcXCIwXFxcIj4gXFxuICAgIDxhbmltYXRlIGF0dHJpYnV0ZU5hbWU9XFxcInJcXFwiIHZhbHVlcz1cXFwiMDsgNDsgMDsgMFxcXCIgZHVyPVxcXCIxLjJzXFxcIiByZXBlYXRDb3VudD1cXFwiaW5kZWZpbml0ZVxcXCIgYmVnaW49XFxcIjAuM1xcXCJcXG4gICAgICBrZXl0aW1lcz1cXFwiMDswLjI7MC43OzFcXFwiIGtleVNwbGluZXM9XFxcIjAuMiAwLjIgMC40IDAuODswLjIgMC42IDAuNCAwLjg7MC4yIDAuNiAwLjQgMC44XFxcIiBjYWxjTW9kZT1cXFwic3BsaW5lXFxcIiAvPlxcbiAgPC9jaXJjbGU+XFxuICA8Y2lyY2xlIHRyYW5zZm9ybT1cXFwidHJhbnNsYXRlKDI0IDApXFxcIiBjeD1cXFwiMFxcXCIgY3k9XFxcIjE2XFxcIiByPVxcXCIwXFxcIj4gXFxuICAgIDxhbmltYXRlIGF0dHJpYnV0ZU5hbWU9XFxcInJcXFwiIHZhbHVlcz1cXFwiMDsgNDsgMDsgMFxcXCIgZHVyPVxcXCIxLjJzXFxcIiByZXBlYXRDb3VudD1cXFwiaW5kZWZpbml0ZVxcXCIgYmVnaW49XFxcIjAuNlxcXCJcXG4gICAgICBrZXl0aW1lcz1cXFwiMDswLjI7MC43OzFcXFwiIGtleVNwbGluZXM9XFxcIjAuMiAwLjIgMC40IDAuODswLjIgMC42IDAuNCAwLjg7MC4yIDAuNiAwLjQgMC44XFxcIiBjYWxjTW9kZT1cXFwic3BsaW5lXFxcIiAvPlxcbiAgPC9jaXJjbGU+XFxuPC9zdmc+XFxuXCJcblxuLyoqKi8gfSksXG4vKiAxOSAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cykge1xuXG5tb2R1bGUuZXhwb3J0cyA9IFwiPHN2ZyB4bWxucz1cXFwiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmdcXFwiIHZpZXdCb3g9XFxcIjAgMCAzMiAzMlxcXCI+XFxuICA8cGF0aCB0cmFuc2Zvcm09XFxcInRyYW5zbGF0ZSgtOCAwKVxcXCIgZD1cXFwiTTAgMTIgVjIwIEg4IFYxMnpcXFwiPiBcXG4gICAgPGFuaW1hdGVUcmFuc2Zvcm0gYXR0cmlidXRlTmFtZT1cXFwidHJhbnNmb3JtXFxcIiB0eXBlPVxcXCJ0cmFuc2xhdGVcXFwiIHZhbHVlcz1cXFwiLTggMDsgMiAwOyAyIDA7XFxcIiBkdXI9XFxcIjAuOHNcXFwiIHJlcGVhdENvdW50PVxcXCJpbmRlZmluaXRlXFxcIiBiZWdpbj1cXFwiMFxcXCIga2V5dGltZXM9XFxcIjA7LjI1OzFcXFwiIGtleVNwbGluZXM9XFxcIjAuMiAwLjIgMC40IDAuODswLjIgMC42IDAuNCAwLjhcXFwiIGNhbGNNb2RlPVxcXCJzcGxpbmVcXFwiICAvPlxcbiAgPC9wYXRoPlxcbiAgPHBhdGggdHJhbnNmb3JtPVxcXCJ0cmFuc2xhdGUoMiAwKVxcXCIgZD1cXFwiTTAgMTIgVjIwIEg4IFYxMnpcXFwiPiBcXG4gICAgPGFuaW1hdGVUcmFuc2Zvcm0gYXR0cmlidXRlTmFtZT1cXFwidHJhbnNmb3JtXFxcIiB0eXBlPVxcXCJ0cmFuc2xhdGVcXFwiIHZhbHVlcz1cXFwiMiAwOyAxMiAwOyAxMiAwO1xcXCIgZHVyPVxcXCIwLjhzXFxcIiByZXBlYXRDb3VudD1cXFwiaW5kZWZpbml0ZVxcXCIgYmVnaW49XFxcIjBcXFwiIGtleXRpbWVzPVxcXCIwOy4zNTsxXFxcIiBrZXlTcGxpbmVzPVxcXCIwLjIgMC4yIDAuNCAwLjg7MC4yIDAuNiAwLjQgMC44XFxcIiBjYWxjTW9kZT1cXFwic3BsaW5lXFxcIiAgLz5cXG4gIDwvcGF0aD5cXG4gIDxwYXRoIHRyYW5zZm9ybT1cXFwidHJhbnNsYXRlKDEyIDApXFxcIiBkPVxcXCJNMCAxMiBWMjAgSDggVjEyelxcXCI+IFxcbiAgICA8YW5pbWF0ZVRyYW5zZm9ybSBhdHRyaWJ1dGVOYW1lPVxcXCJ0cmFuc2Zvcm1cXFwiIHR5cGU9XFxcInRyYW5zbGF0ZVxcXCIgdmFsdWVzPVxcXCIxMiAwOyAyMiAwOyAyMiAwO1xcXCIgZHVyPVxcXCIwLjhzXFxcIiByZXBlYXRDb3VudD1cXFwiaW5kZWZpbml0ZVxcXCIgYmVnaW49XFxcIjBcXFwiIGtleXRpbWVzPVxcXCIwOy40NTsxXFxcIiBrZXlTcGxpbmVzPVxcXCIwLjIgMC4yIDAuNCAwLjg7MC4yIDAuNiAwLjQgMC44XFxcIiBjYWxjTW9kZT1cXFwic3BsaW5lXFxcIiAgLz5cXG4gIDwvcGF0aD5cXG4gIDxwYXRoIHRyYW5zZm9ybT1cXFwidHJhbnNsYXRlKDI0IDApXFxcIiBkPVxcXCJNMCAxMiBWMjAgSDggVjEyelxcXCI+IFxcbiAgICA8YW5pbWF0ZVRyYW5zZm9ybSBhdHRyaWJ1dGVOYW1lPVxcXCJ0cmFuc2Zvcm1cXFwiIHR5cGU9XFxcInRyYW5zbGF0ZVxcXCIgdmFsdWVzPVxcXCIyMiAwOyAzMiAwOyAzMiAwO1xcXCIgZHVyPVxcXCIwLjhzXFxcIiByZXBlYXRDb3VudD1cXFwiaW5kZWZpbml0ZVxcXCIgYmVnaW49XFxcIjBcXFwiIGtleXRpbWVzPVxcXCIwOy41NTsxXFxcIiBrZXlTcGxpbmVzPVxcXCIwLjIgMC4yIDAuNCAwLjg7MC4yIDAuNiAwLjQgMC44XFxcIiBjYWxjTW9kZT1cXFwic3BsaW5lXFxcIiAgLz5cXG4gIDwvcGF0aD5cXG48L3N2Zz5cXG5cIlxuXG4vKioqLyB9KSxcbi8qIDIwICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzKSB7XG5cbm1vZHVsZS5leHBvcnRzID0gXCI8c3ZnIHhtbG5zPVxcXCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1xcXCIgdmlld0JveD1cXFwiMCAwIDMyIDMyXFxcIj5cXG4gIDxwYXRoIHRyYW5zZm9ybT1cXFwidHJhbnNsYXRlKDAgMClcXFwiIGQ9XFxcIk0wIDEyIFYyMCBINCBWMTJ6XFxcIj5cXG4gICAgPGFuaW1hdGVUcmFuc2Zvcm0gYXR0cmlidXRlTmFtZT1cXFwidHJhbnNmb3JtXFxcIiB0eXBlPVxcXCJ0cmFuc2xhdGVcXFwiIHZhbHVlcz1cXFwiMCAwOyAyOCAwOyAwIDA7IDAgMFxcXCIgZHVyPVxcXCIxLjVzXFxcIiBiZWdpbj1cXFwiMFxcXCIgcmVwZWF0Q291bnQ9XFxcImluZGVmaW5pdGVcXFwiIGtleXRpbWVzPVxcXCIwOzAuMzswLjY7MVxcXCIga2V5U3BsaW5lcz1cXFwiMC4yIDAuMiAwLjQgMC44OzAuMiAwLjIgMC40IDAuODswLjIgMC4yIDAuNCAwLjhcXFwiIGNhbGNNb2RlPVxcXCJzcGxpbmVcXFwiIC8+XFxuICA8L3BhdGg+XFxuICA8cGF0aCBvcGFjaXR5PVxcXCIwLjVcXFwiIHRyYW5zZm9ybT1cXFwidHJhbnNsYXRlKDAgMClcXFwiIGQ9XFxcIk0wIDEyIFYyMCBINCBWMTJ6XFxcIj5cXG4gICAgPGFuaW1hdGVUcmFuc2Zvcm0gYXR0cmlidXRlTmFtZT1cXFwidHJhbnNmb3JtXFxcIiB0eXBlPVxcXCJ0cmFuc2xhdGVcXFwiIHZhbHVlcz1cXFwiMCAwOyAyOCAwOyAwIDA7IDAgMFxcXCIgZHVyPVxcXCIxLjVzXFxcIiBiZWdpbj1cXFwiMC4xc1xcXCIgcmVwZWF0Q291bnQ9XFxcImluZGVmaW5pdGVcXFwiIGtleXRpbWVzPVxcXCIwOzAuMzswLjY7MVxcXCIga2V5U3BsaW5lcz1cXFwiMC4yIDAuMiAwLjQgMC44OzAuMiAwLjIgMC40IDAuODswLjIgMC4yIDAuNCAwLjhcXFwiIGNhbGNNb2RlPVxcXCJzcGxpbmVcXFwiIC8+XFxuICA8L3BhdGg+XFxuICA8cGF0aCBvcGFjaXR5PVxcXCIwLjI1XFxcIiB0cmFuc2Zvcm09XFxcInRyYW5zbGF0ZSgwIDApXFxcIiBkPVxcXCJNMCAxMiBWMjAgSDQgVjEyelxcXCI+XFxuICAgIDxhbmltYXRlVHJhbnNmb3JtIGF0dHJpYnV0ZU5hbWU9XFxcInRyYW5zZm9ybVxcXCIgdHlwZT1cXFwidHJhbnNsYXRlXFxcIiB2YWx1ZXM9XFxcIjAgMDsgMjggMDsgMCAwOyAwIDBcXFwiIGR1cj1cXFwiMS41c1xcXCIgYmVnaW49XFxcIjAuMnNcXFwiIHJlcGVhdENvdW50PVxcXCJpbmRlZmluaXRlXFxcIiBrZXl0aW1lcz1cXFwiMDswLjM7MC42OzFcXFwiIGtleVNwbGluZXM9XFxcIjAuMiAwLjIgMC40IDAuODswLjIgMC4yIDAuNCAwLjg7MC4yIDAuMiAwLjQgMC44XFxcIiBjYWxjTW9kZT1cXFwic3BsaW5lXFxcIiAvPlxcbiAgPC9wYXRoPlxcbjwvc3ZnPlxcblwiXG5cbi8qKiovIH0pLFxuLyogMjEgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMpIHtcblxubW9kdWxlLmV4cG9ydHMgPSBcIjxzdmcgeG1sbnM9XFxcImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXFxcIiB2aWV3Qm94PVxcXCIwIDAgMzIgMzJcXFwiPlxcbiAgPHBhdGggb3BhY2l0eT1cXFwiLjI1XFxcIiBkPVxcXCJNMTYgMCBBMTYgMTYgMCAwIDAgMTYgMzIgQTE2IDE2IDAgMCAwIDE2IDAgTTE2IDQgQTEyIDEyIDAgMCAxIDE2IDI4IEExMiAxMiAwIDAgMSAxNiA0XFxcIi8+XFxuICA8cGF0aCBkPVxcXCJNMTYgMCBBMTYgMTYgMCAwIDEgMzIgMTYgTDI4IDE2IEExMiAxMiAwIDAgMCAxNiA0elxcXCI+XFxuICAgIDxhbmltYXRlVHJhbnNmb3JtIGF0dHJpYnV0ZU5hbWU9XFxcInRyYW5zZm9ybVxcXCIgdHlwZT1cXFwicm90YXRlXFxcIiBmcm9tPVxcXCIwIDE2IDE2XFxcIiB0bz1cXFwiMzYwIDE2IDE2XFxcIiBkdXI9XFxcIjAuOHNcXFwiIHJlcGVhdENvdW50PVxcXCJpbmRlZmluaXRlXFxcIiAvPlxcbiAgPC9wYXRoPlxcbjwvc3ZnPlxcblwiXG5cbi8qKiovIH0pLFxuLyogMjIgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMpIHtcblxubW9kdWxlLmV4cG9ydHMgPSBcIjxzdmcgeG1sbnM9XFxcImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXFxcIiB2aWV3Qm94PVxcXCIwIDAgMzIgMzJcXFwiPlxcbiAgPGNpcmNsZSBjeD1cXFwiMTZcXFwiIGN5PVxcXCIzXFxcIiByPVxcXCIwXFxcIj5cXG4gICAgPGFuaW1hdGUgYXR0cmlidXRlTmFtZT1cXFwiclxcXCIgdmFsdWVzPVxcXCIwOzM7MDswXFxcIiBkdXI9XFxcIjFzXFxcIiByZXBlYXRDb3VudD1cXFwiaW5kZWZpbml0ZVxcXCIgYmVnaW49XFxcIjBcXFwiIGtleVNwbGluZXM9XFxcIjAuMiAwLjIgMC40IDAuODswLjIgMC4yIDAuNCAwLjg7MC4yIDAuMiAwLjQgMC44XFxcIiBjYWxjTW9kZT1cXFwic3BsaW5lXFxcIiAvPlxcbiAgPC9jaXJjbGU+XFxuICA8Y2lyY2xlIHRyYW5zZm9ybT1cXFwicm90YXRlKDQ1IDE2IDE2KVxcXCIgY3g9XFxcIjE2XFxcIiBjeT1cXFwiM1xcXCIgcj1cXFwiMFxcXCI+XFxuICAgIDxhbmltYXRlIGF0dHJpYnV0ZU5hbWU9XFxcInJcXFwiIHZhbHVlcz1cXFwiMDszOzA7MFxcXCIgZHVyPVxcXCIxc1xcXCIgcmVwZWF0Q291bnQ9XFxcImluZGVmaW5pdGVcXFwiIGJlZ2luPVxcXCIwLjEyNXNcXFwiIGtleVNwbGluZXM9XFxcIjAuMiAwLjIgMC40IDAuODswLjIgMC4yIDAuNCAwLjg7MC4yIDAuMiAwLjQgMC44XFxcIiBjYWxjTW9kZT1cXFwic3BsaW5lXFxcIiAvPlxcbiAgPC9jaXJjbGU+XFxuICA8Y2lyY2xlIHRyYW5zZm9ybT1cXFwicm90YXRlKDkwIDE2IDE2KVxcXCIgY3g9XFxcIjE2XFxcIiBjeT1cXFwiM1xcXCIgcj1cXFwiMFxcXCI+XFxuICAgIDxhbmltYXRlIGF0dHJpYnV0ZU5hbWU9XFxcInJcXFwiIHZhbHVlcz1cXFwiMDszOzA7MFxcXCIgZHVyPVxcXCIxc1xcXCIgcmVwZWF0Q291bnQ9XFxcImluZGVmaW5pdGVcXFwiIGJlZ2luPVxcXCIwLjI1c1xcXCIga2V5U3BsaW5lcz1cXFwiMC4yIDAuMiAwLjQgMC44OzAuMiAwLjIgMC40IDAuODswLjIgMC4yIDAuNCAwLjhcXFwiIGNhbGNNb2RlPVxcXCJzcGxpbmVcXFwiIC8+XFxuICA8L2NpcmNsZT5cXG4gIDxjaXJjbGUgdHJhbnNmb3JtPVxcXCJyb3RhdGUoMTM1IDE2IDE2KVxcXCIgY3g9XFxcIjE2XFxcIiBjeT1cXFwiM1xcXCIgcj1cXFwiMFxcXCI+XFxuICAgIDxhbmltYXRlIGF0dHJpYnV0ZU5hbWU9XFxcInJcXFwiIHZhbHVlcz1cXFwiMDszOzA7MFxcXCIgZHVyPVxcXCIxc1xcXCIgcmVwZWF0Q291bnQ9XFxcImluZGVmaW5pdGVcXFwiIGJlZ2luPVxcXCIwLjM3NXNcXFwiIGtleVNwbGluZXM9XFxcIjAuMiAwLjIgMC40IDAuODswLjIgMC4yIDAuNCAwLjg7MC4yIDAuMiAwLjQgMC44XFxcIiBjYWxjTW9kZT1cXFwic3BsaW5lXFxcIiAvPlxcbiAgPC9jaXJjbGU+XFxuICA8Y2lyY2xlIHRyYW5zZm9ybT1cXFwicm90YXRlKDE4MCAxNiAxNilcXFwiIGN4PVxcXCIxNlxcXCIgY3k9XFxcIjNcXFwiIHI9XFxcIjBcXFwiPlxcbiAgICA8YW5pbWF0ZSBhdHRyaWJ1dGVOYW1lPVxcXCJyXFxcIiB2YWx1ZXM9XFxcIjA7MzswOzBcXFwiIGR1cj1cXFwiMXNcXFwiIHJlcGVhdENvdW50PVxcXCJpbmRlZmluaXRlXFxcIiBiZWdpbj1cXFwiMC41c1xcXCIga2V5U3BsaW5lcz1cXFwiMC4yIDAuMiAwLjQgMC44OzAuMiAwLjIgMC40IDAuODswLjIgMC4yIDAuNCAwLjhcXFwiIGNhbGNNb2RlPVxcXCJzcGxpbmVcXFwiIC8+XFxuICA8L2NpcmNsZT5cXG4gIDxjaXJjbGUgdHJhbnNmb3JtPVxcXCJyb3RhdGUoMjI1IDE2IDE2KVxcXCIgY3g9XFxcIjE2XFxcIiBjeT1cXFwiM1xcXCIgcj1cXFwiMFxcXCI+XFxuICAgIDxhbmltYXRlIGF0dHJpYnV0ZU5hbWU9XFxcInJcXFwiIHZhbHVlcz1cXFwiMDszOzA7MFxcXCIgZHVyPVxcXCIxc1xcXCIgcmVwZWF0Q291bnQ9XFxcImluZGVmaW5pdGVcXFwiIGJlZ2luPVxcXCIwLjYyNXNcXFwiIGtleVNwbGluZXM9XFxcIjAuMiAwLjIgMC40IDAuODswLjIgMC4yIDAuNCAwLjg7MC4yIDAuMiAwLjQgMC44XFxcIiBjYWxjTW9kZT1cXFwic3BsaW5lXFxcIiAvPlxcbiAgPC9jaXJjbGU+XFxuICA8Y2lyY2xlIHRyYW5zZm9ybT1cXFwicm90YXRlKDI3MCAxNiAxNilcXFwiIGN4PVxcXCIxNlxcXCIgY3k9XFxcIjNcXFwiIHI9XFxcIjBcXFwiPlxcbiAgICA8YW5pbWF0ZSBhdHRyaWJ1dGVOYW1lPVxcXCJyXFxcIiB2YWx1ZXM9XFxcIjA7MzswOzBcXFwiIGR1cj1cXFwiMXNcXFwiIHJlcGVhdENvdW50PVxcXCJpbmRlZmluaXRlXFxcIiBiZWdpbj1cXFwiMC43NXNcXFwiIGtleVNwbGluZXM9XFxcIjAuMiAwLjIgMC40IDAuODswLjIgMC4yIDAuNCAwLjg7MC4yIDAuMiAwLjQgMC44XFxcIiBjYWxjTW9kZT1cXFwic3BsaW5lXFxcIiAvPlxcbiAgPC9jaXJjbGU+XFxuICA8Y2lyY2xlIHRyYW5zZm9ybT1cXFwicm90YXRlKDMxNSAxNiAxNilcXFwiIGN4PVxcXCIxNlxcXCIgY3k9XFxcIjNcXFwiIHI9XFxcIjBcXFwiPlxcbiAgICA8YW5pbWF0ZSBhdHRyaWJ1dGVOYW1lPVxcXCJyXFxcIiB2YWx1ZXM9XFxcIjA7MzswOzBcXFwiIGR1cj1cXFwiMXNcXFwiIHJlcGVhdENvdW50PVxcXCJpbmRlZmluaXRlXFxcIiBiZWdpbj1cXFwiMC44NzVzXFxcIiBrZXlTcGxpbmVzPVxcXCIwLjIgMC4yIDAuNCAwLjg7MC4yIDAuMiAwLjQgMC44OzAuMiAwLjIgMC40IDAuOFxcXCIgY2FsY01vZGU9XFxcInNwbGluZVxcXCIgLz5cXG4gIDwvY2lyY2xlPlxcbiAgPGNpcmNsZSB0cmFuc2Zvcm09XFxcInJvdGF0ZSgxODAgMTYgMTYpXFxcIiBjeD1cXFwiMTZcXFwiIGN5PVxcXCIzXFxcIiByPVxcXCIwXFxcIj5cXG4gICAgPGFuaW1hdGUgYXR0cmlidXRlTmFtZT1cXFwiclxcXCIgdmFsdWVzPVxcXCIwOzM7MDswXFxcIiBkdXI9XFxcIjFzXFxcIiByZXBlYXRDb3VudD1cXFwiaW5kZWZpbml0ZVxcXCIgYmVnaW49XFxcIjAuNXNcXFwiIGtleVNwbGluZXM9XFxcIjAuMiAwLjIgMC40IDAuODswLjIgMC4yIDAuNCAwLjg7MC4yIDAuMiAwLjQgMC44XFxcIiBjYWxjTW9kZT1cXFwic3BsaW5lXFxcIiAvPlxcbiAgPC9jaXJjbGU+XFxuPC9zdmc+XFxuXCJcblxuLyoqKi8gfSksXG4vKiAyMyAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cykge1xuXG5tb2R1bGUuZXhwb3J0cyA9IFwiPHN2ZyBpZD1cXFwibG9hZGluZ1xcXCIgeG1sbnM9XFxcImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXFxcIiB2aWV3Qm94PVxcXCIwIDAgMzIgMzJcXFwiPlxcbiAgPHBhdGggb3BhY2l0eT1cXFwiLjFcXFwiIGQ9XFxcIk0xNCAwIEgxOCBWOCBIMTQgelxcXCIgdHJhbnNmb3JtPVxcXCJyb3RhdGUoMCAxNiAxNilcXFwiPlxcbiAgICA8YW5pbWF0ZSBhdHRyaWJ1dGVOYW1lPVxcXCJvcGFjaXR5XFxcIiBmcm9tPVxcXCIxXFxcIiB0bz1cXFwiLjFcXFwiIGR1cj1cXFwiMXNcXFwiIHJlcGVhdENvdW50PVxcXCJpbmRlZmluaXRlXFxcIiBiZWdpbj1cXFwiMFxcXCIvPlxcbiAgPC9wYXRoPlxcbiAgPHBhdGggb3BhY2l0eT1cXFwiLjFcXFwiIGQ9XFxcIk0xNCAwIEgxOCBWOCBIMTQgelxcXCIgdHJhbnNmb3JtPVxcXCJyb3RhdGUoNDUgMTYgMTYpXFxcIj5cXG4gICAgPGFuaW1hdGUgYXR0cmlidXRlTmFtZT1cXFwib3BhY2l0eVxcXCIgZnJvbT1cXFwiMVxcXCIgdG89XFxcIi4xXFxcIiBkdXI9XFxcIjFzXFxcIiByZXBlYXRDb3VudD1cXFwiaW5kZWZpbml0ZVxcXCIgYmVnaW49XFxcIjAuMTI1c1xcXCIvPlxcbiAgPC9wYXRoPlxcbiAgPHBhdGggb3BhY2l0eT1cXFwiLjFcXFwiIGQ9XFxcIk0xNCAwIEgxOCBWOCBIMTQgelxcXCIgdHJhbnNmb3JtPVxcXCJyb3RhdGUoOTAgMTYgMTYpXFxcIj5cXG4gICAgPGFuaW1hdGUgYXR0cmlidXRlTmFtZT1cXFwib3BhY2l0eVxcXCIgZnJvbT1cXFwiMVxcXCIgdG89XFxcIi4xXFxcIiBkdXI9XFxcIjFzXFxcIiByZXBlYXRDb3VudD1cXFwiaW5kZWZpbml0ZVxcXCIgYmVnaW49XFxcIjAuMjVzXFxcIi8+XFxuICA8L3BhdGg+XFxuICA8cGF0aCBvcGFjaXR5PVxcXCIuMVxcXCIgZD1cXFwiTTE0IDAgSDE4IFY4IEgxNCB6XFxcIiB0cmFuc2Zvcm09XFxcInJvdGF0ZSgxMzUgMTYgMTYpXFxcIj5cXG4gICAgPGFuaW1hdGUgYXR0cmlidXRlTmFtZT1cXFwib3BhY2l0eVxcXCIgZnJvbT1cXFwiMVxcXCIgdG89XFxcIi4xXFxcIiBkdXI9XFxcIjFzXFxcIiByZXBlYXRDb3VudD1cXFwiaW5kZWZpbml0ZVxcXCIgYmVnaW49XFxcIjAuMzc1c1xcXCIvPlxcbiAgPC9wYXRoPlxcbiAgPHBhdGggb3BhY2l0eT1cXFwiLjFcXFwiIGQ9XFxcIk0xNCAwIEgxOCBWOCBIMTQgelxcXCIgdHJhbnNmb3JtPVxcXCJyb3RhdGUoMTgwIDE2IDE2KVxcXCI+XFxuICAgIDxhbmltYXRlIGF0dHJpYnV0ZU5hbWU9XFxcIm9wYWNpdHlcXFwiIGZyb209XFxcIjFcXFwiIHRvPVxcXCIuMVxcXCIgZHVyPVxcXCIxc1xcXCIgcmVwZWF0Q291bnQ9XFxcImluZGVmaW5pdGVcXFwiIGJlZ2luPVxcXCIwLjVzXFxcIi8+XFxuICA8L3BhdGg+XFxuICA8cGF0aCBvcGFjaXR5PVxcXCIuMVxcXCIgZD1cXFwiTTE0IDAgSDE4IFY4IEgxNCB6XFxcIiB0cmFuc2Zvcm09XFxcInJvdGF0ZSgyMjUgMTYgMTYpXFxcIj5cXG4gICAgPGFuaW1hdGUgYXR0cmlidXRlTmFtZT1cXFwib3BhY2l0eVxcXCIgZnJvbT1cXFwiMVxcXCIgdG89XFxcIi4xXFxcIiBkdXI9XFxcIjFzXFxcIiByZXBlYXRDb3VudD1cXFwiaW5kZWZpbml0ZVxcXCIgYmVnaW49XFxcIjAuNjc1c1xcXCIvPlxcbiAgPC9wYXRoPlxcbiAgPHBhdGggb3BhY2l0eT1cXFwiLjFcXFwiIGQ9XFxcIk0xNCAwIEgxOCBWOCBIMTQgelxcXCIgdHJhbnNmb3JtPVxcXCJyb3RhdGUoMjcwIDE2IDE2KVxcXCI+XFxuICAgIDxhbmltYXRlIGF0dHJpYnV0ZU5hbWU9XFxcIm9wYWNpdHlcXFwiIGZyb209XFxcIjFcXFwiIHRvPVxcXCIuMVxcXCIgZHVyPVxcXCIxc1xcXCIgcmVwZWF0Q291bnQ9XFxcImluZGVmaW5pdGVcXFwiIGJlZ2luPVxcXCIwLjc1c1xcXCIvPlxcbiAgPC9wYXRoPlxcbiAgPHBhdGggb3BhY2l0eT1cXFwiLjFcXFwiIGQ9XFxcIk0xNCAwIEgxOCBWOCBIMTQgelxcXCIgdHJhbnNmb3JtPVxcXCJyb3RhdGUoMzE1IDE2IDE2KVxcXCI+XFxuICAgIDxhbmltYXRlIGF0dHJpYnV0ZU5hbWU9XFxcIm9wYWNpdHlcXFwiIGZyb209XFxcIjFcXFwiIHRvPVxcXCIuMVxcXCIgZHVyPVxcXCIxc1xcXCIgcmVwZWF0Q291bnQ9XFxcImluZGVmaW5pdGVcXFwiIGJlZ2luPVxcXCIwLjg3NXNcXFwiLz5cXG4gIDwvcGF0aD5cXG48L3N2Zz5cXG5cIlxuXG4vKioqLyB9KVxuLyoqKioqKi8gXSk7XG59KTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXJlYWN0LWxvYWRpbmcuanMubWFwIl0sIm5hbWVzIjpbIndlYnBhY2tVbml2ZXJzYWxNb2R1bGVEZWZpbml0aW9uIiwicm9vdCIsImZhY3RvcnkiLCJleHBvcnRzIiwibW9kdWxlIiwiZGVmaW5lIiwiYW1kIiwic2VsZiIsIm1vZHVsZXMiLCJpbnN0YWxsZWRNb2R1bGVzIiwiX193ZWJwYWNrX3JlcXVpcmVfXyIsIm1vZHVsZUlkIiwiaSIsImwiLCJjYWxsIiwibSIsImMiLCJkIiwibmFtZSIsImdldHRlciIsIm8iLCJPYmplY3QiLCJkZWZpbmVQcm9wZXJ0eSIsImNvbmZpZ3VyYWJsZSIsImVudW1lcmFibGUiLCJnZXQiLCJuIiwiX19lc01vZHVsZSIsImdldERlZmF1bHQiLCJnZXRNb2R1bGVFeHBvcnRzIiwib2JqZWN0IiwicHJvcGVydHkiLCJwcm90b3R5cGUiLCJoYXNPd25Qcm9wZXJ0eSIsInAiLCJzIiwidmFsaWRhdGVGb3JtYXQiLCJmb3JtYXQiLCJwcm9jZXNzIiwidW5kZWZpbmVkIiwiRXJyb3IiLCJpbnZhcmlhbnQiLCJjb25kaXRpb24iLCJhIiwiYiIsImUiLCJmIiwiZXJyb3IiLCJhcmdzIiwiYXJnSW5kZXgiLCJyZXBsYWNlIiwiZnJhbWVzVG9Qb3AiLCJtYWtlRW1wdHlGdW5jdGlvbiIsImFyZyIsImVtcHR5RnVuY3Rpb24iLCJ0aGF0UmV0dXJucyIsInRoYXRSZXR1cm5zRmFsc2UiLCJ0aGF0UmV0dXJuc1RydWUiLCJ0aGF0UmV0dXJuc051bGwiLCJ0aGF0UmV0dXJuc1RoaXMiLCJ0aGF0UmV0dXJuc0FyZ3VtZW50IiwiZ2V0T3duUHJvcGVydHlTeW1ib2xzIiwicHJvcElzRW51bWVyYWJsZSIsInByb3BlcnR5SXNFbnVtZXJhYmxlIiwidG9PYmplY3QiLCJ2YWwiLCJUeXBlRXJyb3IiLCJzaG91bGRVc2VOYXRpdmUiLCJhc3NpZ24iLCJ0ZXN0MSIsIlN0cmluZyIsImdldE93blByb3BlcnR5TmFtZXMiLCJ0ZXN0MiIsImZyb21DaGFyQ29kZSIsIm9yZGVyMiIsIm1hcCIsImpvaW4iLCJ0ZXN0MyIsInNwbGl0IiwiZm9yRWFjaCIsImxldHRlciIsImtleXMiLCJlcnIiLCJ0YXJnZXQiLCJzb3VyY2UiLCJmcm9tIiwidG8iLCJzeW1ib2xzIiwiYXJndW1lbnRzIiwibGVuZ3RoIiwia2V5Iiwid2FybmluZyIsInByaW50V2FybmluZyIsIl9sZW4iLCJBcnJheSIsIl9rZXkiLCJtZXNzYWdlIiwiY29uc29sZSIsIngiLCJpbmRleE9mIiwiX2xlbjIiLCJfa2V5MiIsImFwcGx5IiwiY29uY2F0IiwiUmVhY3RQcm9wVHlwZXNTZWNyZXQiLCJlbXB0eU9iamVjdCIsImZyZWV6ZSIsImxvZ2dlZFR5cGVGYWlsdXJlcyIsImNoZWNrUHJvcFR5cGVzIiwidHlwZVNwZWNzIiwidmFsdWVzIiwibG9jYXRpb24iLCJjb21wb25lbnROYW1lIiwiZ2V0U3RhY2siLCJ0eXBlU3BlY05hbWUiLCJleCIsInN0YWNrIiwidmFsdWUiLCJfZXh0ZW5kcyIsIl9jcmVhdGVDbGFzcyIsImRlZmluZVByb3BlcnRpZXMiLCJwcm9wcyIsImRlc2NyaXB0b3IiLCJ3cml0YWJsZSIsIkNvbnN0cnVjdG9yIiwicHJvdG9Qcm9wcyIsInN0YXRpY1Byb3BzIiwiX3JlYWN0IiwiX3JlYWN0MiIsIl9pbnRlcm9wUmVxdWlyZURlZmF1bHQiLCJfcHJvcFR5cGVzIiwiX3Byb3BUeXBlczIiLCJfc3ZnIiwic3ZnU291cmNlcyIsIl9pbnRlcm9wUmVxdWlyZVdpbGRjYXJkIiwib2JqIiwibmV3T2JqIiwiZGVmYXVsdCIsIl9vYmplY3RXaXRob3V0UHJvcGVydGllcyIsIl9jbGFzc0NhbGxDaGVjayIsImluc3RhbmNlIiwiX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4iLCJSZWZlcmVuY2VFcnJvciIsIl9pbmhlcml0cyIsInN1YkNsYXNzIiwic3VwZXJDbGFzcyIsImNyZWF0ZSIsImNvbnN0cnVjdG9yIiwic2V0UHJvdG90eXBlT2YiLCJfX3Byb3RvX18iLCJMb2FkaW5nIiwiX0NvbXBvbmVudCIsIl9yZWYiLCJfdGVtcCIsIl90aGlzIiwiX3JldCIsImdldFByb3RvdHlwZU9mIiwic3RhdGUiLCJkZWxheWVkIiwiZGVsYXkiLCJjb21wb25lbnREaWRNb3VudCIsIl90aGlzMiIsInRpbWVvdXQiLCJzZXRUaW1lb3V0Iiwic2V0U3RhdGUiLCJjb21wb25lbnRXaWxsVW5tb3VudCIsImNsZWFyVGltZW91dCIsInJlbmRlciIsIl9wcm9wcyIsImNvbG9yIiwidHlwZSIsImhlaWdodCIsIndpZHRoIiwicmVzdFByb3BzIiwic2VsZWN0ZWRUeXBlIiwic3ZnIiwic3R5bGUiLCJmaWxsIiwiY3JlYXRlRWxlbWVudCIsImRhbmdlcm91c2x5U2V0SW5uZXJIVE1MIiwiX19odG1sIiwiQ29tcG9uZW50IiwicHJvcFR5cGVzIiwic3RyaW5nIiwibnVtYmVyIiwib25lT2ZUeXBlIiwiZGVmYXVsdFByb3BzIiwicSIsInIiLCJTeW1ib2wiLCJ0IiwidSIsInYiLCJ3IiwieSIsInoiLCJBIiwiQiIsIml0ZXJhdG9yIiwiQyIsImVuY29kZVVSSUNvbXBvbmVudCIsIkQiLCJpc01vdW50ZWQiLCJlbnF1ZXVlRm9yY2VVcGRhdGUiLCJlbnF1ZXVlUmVwbGFjZVN0YXRlIiwiZW5xdWV1ZVNldFN0YXRlIiwiRSIsImNvbnRleHQiLCJyZWZzIiwidXBkYXRlciIsImlzUmVhY3RDb21wb25lbnQiLCJmb3JjZVVwZGF0ZSIsIkYiLCJHIiwiSCIsImlzUHVyZVJlYWN0Q29tcG9uZW50IiwiSSIsImN1cnJlbnQiLCJKIiwiSyIsInJlZiIsIl9fc2VsZiIsIl9fc291cmNlIiwiTCIsImciLCJoIiwiY2hpbGRyZW4iLCJrIiwiJCR0eXBlb2YiLCJfb3duZXIiLCJNIiwiZXNjYXBlIiwiTiIsIk8iLCJQIiwicG9wIiwicmVzdWx0Iiwia2V5UHJlZml4IiwiZnVuYyIsImNvdW50IiwiUSIsInB1c2giLCJSIiwiUyIsImlzQXJyYXkiLCJuZXh0IiwiZG9uZSIsInRvU3RyaW5nIiwiVCIsIlUiLCJWIiwiVyIsIkNoaWxkcmVuIiwidG9BcnJheSIsIm9ubHkiLCJjcmVhdGVSZWYiLCJQdXJlQ29tcG9uZW50IiwiY3JlYXRlQ29udGV4dCIsIl9jYWxjdWxhdGVDaGFuZ2VkQml0cyIsIl9kZWZhdWx0VmFsdWUiLCJfY3VycmVudFZhbHVlIiwiX2NoYW5nZWRCaXRzIiwiUHJvdmlkZXIiLCJDb25zdW1lciIsIl9jb250ZXh0IiwiZm9yd2FyZFJlZiIsIkZyYWdtZW50IiwiU3RyaWN0TW9kZSIsInVuc3RhYmxlX0FzeW5jTW9kZSIsImNsb25lRWxlbWVudCIsImNyZWF0ZUZhY3RvcnkiLCJiaW5kIiwiaXNWYWxpZEVsZW1lbnQiLCJ2ZXJzaW9uIiwiX19TRUNSRVRfSU5URVJOQUxTX0RPX05PVF9VU0VfT1JfWU9VX1dJTExfQkVfRklSRUQiLCJSZWFjdEN1cnJlbnRPd25lciIsIlgiLCJZIiwiX2Fzc2lnbiIsIlJlYWN0VmVyc2lvbiIsImhhc1N5bWJvbCIsIlJFQUNUX0VMRU1FTlRfVFlQRSIsIlJFQUNUX0NBTExfVFlQRSIsIlJFQUNUX1JFVFVSTl9UWVBFIiwiUkVBQ1RfUE9SVEFMX1RZUEUiLCJSRUFDVF9GUkFHTUVOVF9UWVBFIiwiUkVBQ1RfU1RSSUNUX01PREVfVFlQRSIsIlJFQUNUX1BST1ZJREVSX1RZUEUiLCJSRUFDVF9DT05URVhUX1RZUEUiLCJSRUFDVF9BU1lOQ19NT0RFX1RZUEUiLCJSRUFDVF9GT1JXQVJEX1JFRl9UWVBFIiwiTUFZQkVfSVRFUkFUT1JfU1lNQk9MIiwiRkFVWF9JVEVSQVRPUl9TWU1CT0wiLCJnZXRJdGVyYXRvckZuIiwibWF5YmVJdGVyYWJsZSIsIm1heWJlSXRlcmF0b3IiLCJsb3dQcmlvcml0eVdhcm5pbmciLCJ3YXJuIiwibG93UHJpb3JpdHlXYXJuaW5nJDEiLCJkaWRXYXJuU3RhdGVVcGRhdGVGb3JVbm1vdW50ZWRDb21wb25lbnQiLCJ3YXJuTm9vcCIsInB1YmxpY0luc3RhbmNlIiwiY2FsbGVyTmFtZSIsIl9jb25zdHJ1Y3RvciIsImRpc3BsYXlOYW1lIiwid2FybmluZ0tleSIsIlJlYWN0Tm9vcFVwZGF0ZVF1ZXVlIiwiY2FsbGJhY2siLCJjb21wbGV0ZVN0YXRlIiwicGFydGlhbFN0YXRlIiwiZGVwcmVjYXRlZEFQSXMiLCJyZXBsYWNlU3RhdGUiLCJkZWZpbmVEZXByZWNhdGlvbldhcm5pbmciLCJtZXRob2ROYW1lIiwiaW5mbyIsImZuTmFtZSIsIkNvbXBvbmVudER1bW15IiwicHVyZUNvbXBvbmVudFByb3RvdHlwZSIsInJlZk9iamVjdCIsInNlYWwiLCJSRVNFUlZFRF9QUk9QUyIsInNwZWNpYWxQcm9wS2V5V2FybmluZ1Nob3duIiwic3BlY2lhbFByb3BSZWZXYXJuaW5nU2hvd24iLCJoYXNWYWxpZFJlZiIsImNvbmZpZyIsImdldE93blByb3BlcnR5RGVzY3JpcHRvciIsImlzUmVhY3RXYXJuaW5nIiwiaGFzVmFsaWRLZXkiLCJkZWZpbmVLZXlQcm9wV2FybmluZ0dldHRlciIsIndhcm5BYm91dEFjY2Vzc2luZ0tleSIsImRlZmluZVJlZlByb3BXYXJuaW5nR2V0dGVyIiwid2FybkFib3V0QWNjZXNzaW5nUmVmIiwiUmVhY3RFbGVtZW50Iiwib3duZXIiLCJlbGVtZW50IiwiX3N0b3JlIiwicHJvcE5hbWUiLCJjaGlsZHJlbkxlbmd0aCIsImNoaWxkQXJyYXkiLCJjbG9uZUFuZFJlcGxhY2VLZXkiLCJvbGRFbGVtZW50IiwibmV3S2V5IiwibmV3RWxlbWVudCIsIl9zZWxmIiwiX3NvdXJjZSIsIlJlYWN0RGVidWdDdXJyZW50RnJhbWUiLCJnZXRDdXJyZW50U3RhY2siLCJnZXRTdGFja0FkZGVuZHVtIiwiaW1wbCIsIlNFUEFSQVRPUiIsIlNVQlNFUEFSQVRPUiIsImVzY2FwZVJlZ2V4IiwiZXNjYXBlckxvb2t1cCIsImVzY2FwZWRTdHJpbmciLCJtYXRjaCIsImRpZFdhcm5BYm91dE1hcHMiLCJ1c2VyUHJvdmlkZWRLZXlFc2NhcGVSZWdleCIsImVzY2FwZVVzZXJQcm92aWRlZEtleSIsInRleHQiLCJQT09MX1NJWkUiLCJ0cmF2ZXJzZUNvbnRleHRQb29sIiwiZ2V0UG9vbGVkVHJhdmVyc2VDb250ZXh0IiwibWFwUmVzdWx0IiwibWFwRnVuY3Rpb24iLCJtYXBDb250ZXh0IiwidHJhdmVyc2VDb250ZXh0IiwicmVsZWFzZVRyYXZlcnNlQ29udGV4dCIsInRyYXZlcnNlQWxsQ2hpbGRyZW5JbXBsIiwibmFtZVNvRmFyIiwiaW52b2tlQ2FsbGJhY2siLCJnZXRDb21wb25lbnRLZXkiLCJjaGlsZCIsIm5leHROYW1lIiwic3VidHJlZUNvdW50IiwibmV4dE5hbWVQcmVmaXgiLCJpdGVyYXRvckZuIiwiZW50cmllcyIsInN0ZXAiLCJpaSIsImFkZGVuZHVtIiwiY2hpbGRyZW5TdHJpbmciLCJ0cmF2ZXJzZUFsbENoaWxkcmVuIiwiY29tcG9uZW50IiwiaW5kZXgiLCJmb3JFYWNoU2luZ2xlQ2hpbGQiLCJib29rS2VlcGluZyIsImZvckVhY2hDaGlsZHJlbiIsImZvckVhY2hGdW5jIiwiZm9yRWFjaENvbnRleHQiLCJtYXBTaW5nbGVDaGlsZEludG9Db250ZXh0IiwiY2hpbGRLZXkiLCJtYXBwZWRDaGlsZCIsIm1hcEludG9XaXRoS2V5UHJlZml4SW50ZXJuYWwiLCJhcnJheSIsInByZWZpeCIsImVzY2FwZWRQcmVmaXgiLCJtYXBDaGlsZHJlbiIsImNvdW50Q2hpbGRyZW4iLCJvbmx5Q2hpbGQiLCJkZWZhdWx0VmFsdWUiLCJjYWxjdWxhdGVDaGFuZ2VkQml0cyIsIl9jdXJyZW50UmVuZGVyZXIiLCJkZXNjcmliZUNvbXBvbmVudEZyYW1lIiwib3duZXJOYW1lIiwiZmlsZU5hbWUiLCJsaW5lTnVtYmVyIiwiaXNWYWxpZEVsZW1lbnRUeXBlIiwiZ2V0Q29tcG9uZW50TmFtZSIsImZpYmVyIiwiZnVuY3Rpb25OYW1lIiwiY3VycmVudGx5VmFsaWRhdGluZ0VsZW1lbnQiLCJwcm9wVHlwZXNNaXNzcGVsbFdhcm5pbmdTaG93biIsImdldERpc3BsYXlOYW1lIiwiZ2V0RGVjbGFyYXRpb25FcnJvckFkZGVuZHVtIiwiZ2V0U291cmNlSW5mb0Vycm9yQWRkZW5kdW0iLCJlbGVtZW50UHJvcHMiLCJvd25lckhhc0tleVVzZVdhcm5pbmciLCJnZXRDdXJyZW50Q29tcG9uZW50RXJyb3JJbmZvIiwicGFyZW50VHlwZSIsInBhcmVudE5hbWUiLCJ2YWxpZGF0ZUV4cGxpY2l0S2V5IiwidmFsaWRhdGVkIiwiY3VycmVudENvbXBvbmVudEVycm9ySW5mbyIsImNoaWxkT3duZXIiLCJ2YWxpZGF0ZUNoaWxkS2V5cyIsIm5vZGUiLCJ2YWxpZGF0ZVByb3BUeXBlcyIsImNvbXBvbmVudENsYXNzIiwiUHJvcFR5cGVzIiwiZ2V0RGVmYXVsdFByb3BzIiwiaXNSZWFjdENsYXNzQXBwcm92ZWQiLCJ2YWxpZGF0ZUZyYWdtZW50UHJvcHMiLCJmcmFnbWVudCIsImNyZWF0ZUVsZW1lbnRXaXRoVmFsaWRhdGlvbiIsInZhbGlkVHlwZSIsInNvdXJjZUluZm8iLCJ0eXBlU3RyaW5nIiwiY3JlYXRlRmFjdG9yeVdpdGhWYWxpZGF0aW9uIiwidmFsaWRhdGVkRmFjdG9yeSIsImNsb25lRWxlbWVudFdpdGhWYWxpZGF0aW9uIiwiUmVhY3QiLCJSZWFjdENvbXBvbmVudFRyZWVIb29rIiwiUmVhY3QkMiIsIlJlYWN0JDMiLCJyZWFjdCIsImZvciIsInRocm93T25EaXJlY3RBY2Nlc3MiLCJJVEVSQVRPUl9TWU1CT0wiLCJBTk9OWU1PVVMiLCJSZWFjdFByb3BUeXBlcyIsImNyZWF0ZVByaW1pdGl2ZVR5cGVDaGVja2VyIiwiYm9vbCIsInN5bWJvbCIsImFueSIsImNyZWF0ZUFueVR5cGVDaGVja2VyIiwiYXJyYXlPZiIsImNyZWF0ZUFycmF5T2ZUeXBlQ2hlY2tlciIsImNyZWF0ZUVsZW1lbnRUeXBlQ2hlY2tlciIsImluc3RhbmNlT2YiLCJjcmVhdGVJbnN0YW5jZVR5cGVDaGVja2VyIiwiY3JlYXRlTm9kZUNoZWNrZXIiLCJvYmplY3RPZiIsImNyZWF0ZU9iamVjdE9mVHlwZUNoZWNrZXIiLCJvbmVPZiIsImNyZWF0ZUVudW1UeXBlQ2hlY2tlciIsImNyZWF0ZVVuaW9uVHlwZUNoZWNrZXIiLCJzaGFwZSIsImNyZWF0ZVNoYXBlVHlwZUNoZWNrZXIiLCJleGFjdCIsImNyZWF0ZVN0cmljdFNoYXBlVHlwZUNoZWNrZXIiLCJpcyIsIlByb3BUeXBlRXJyb3IiLCJjcmVhdGVDaGFpbmFibGVUeXBlQ2hlY2tlciIsInZhbGlkYXRlIiwibWFudWFsUHJvcFR5cGVDYWxsQ2FjaGUiLCJtYW51YWxQcm9wVHlwZVdhcm5pbmdDb3VudCIsImNoZWNrVHlwZSIsImlzUmVxdWlyZWQiLCJwcm9wRnVsbE5hbWUiLCJzZWNyZXQiLCJjYWNoZUtleSIsImNoYWluZWRDaGVja1R5cGUiLCJleHBlY3RlZFR5cGUiLCJwcm9wVmFsdWUiLCJwcm9wVHlwZSIsImdldFByb3BUeXBlIiwicHJlY2lzZVR5cGUiLCJnZXRQcmVjaXNlVHlwZSIsInR5cGVDaGVja2VyIiwiZXhwZWN0ZWRDbGFzcyIsImV4cGVjdGVkQ2xhc3NOYW1lIiwiYWN0dWFsQ2xhc3NOYW1lIiwiZ2V0Q2xhc3NOYW1lIiwiZXhwZWN0ZWRWYWx1ZXMiLCJ2YWx1ZXNTdHJpbmciLCJKU09OIiwic3RyaW5naWZ5IiwiYXJyYXlPZlR5cGVDaGVja2VycyIsImNoZWNrZXIiLCJnZXRQb3N0Zml4Rm9yVHlwZVdhcm5pbmciLCJpc05vZGUiLCJzaGFwZVR5cGVzIiwiYWxsS2V5cyIsImV2ZXJ5IiwiZW50cnkiLCJpc1N5bWJvbCIsIlJlZ0V4cCIsIkRhdGUiLCJzaGltIiwiZ2V0U2hpbSIsIl9ibGFuayIsIl9sb2FkaW5nQmFsbHMiLCJfbG9hZGluZ0JhcnMiLCJfbG9hZGluZ0J1YmJsZXMiLCJfbG9hZGluZ0N1YmVzIiwiX2xvYWRpbmdDeWxvbiIsIl9sb2FkaW5nU3BpbiIsIl9sb2FkaW5nU3Bpbm5pbmdCdWJibGVzIiwiX2xvYWRpbmdTcG9rZXMiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/react-loading/dist/react-loading.js\n");

/***/ })

};
;